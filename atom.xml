<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei’s Blog</title>
  <subtitle>不忘初心，淡然前行</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://LeiHolmes.github.io/"/>
  <updated>2017-05-15T02:54:32.000Z</updated>
  <id>http://LeiHolmes.github.io/</id>
  
  <author>
    <name>徐雷</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android开发之RecyclerView初尝试</title>
    <link href="http://LeiHolmes.github.io/2017/03/28/Android%E5%BC%80%E5%8F%91%E4%B9%8BRecyclerView%E5%88%9D%E5%B0%9D%E8%AF%95/"/>
    <id>http://LeiHolmes.github.io/2017/03/28/Android开发之RecyclerView初尝试/</id>
    <published>2017-03-28T02:26:00.000Z</published>
    <updated>2017-05-15T02:54:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>　　RecyclerView是一种新的视图组，目标是为任何基于适配器的视图提供相似的渲染方式。它被作为ListView和GridView控件的继承者，具有更优的灵活性与可替代性。在最新的support-v7版本中提供支持。本文将讲解RecyclerView的简单实现，添加删除条目，点击事件添加与瀑布流的实现。<br><a id="more"></a>  </p>
<h3 id="相关原理与简单实现"><a href="#相关原理与简单实现" class="headerlink" title="相关原理与简单实现"></a>相关原理与简单实现</h3><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>　　在AndroidStudio的build.gradle中添加依赖：  </p>
<pre><code class="python">dependencies {
    ...
    compile <span class="string">'com.android.support:recyclerview-v7:25.3.0'</span>
}
</code></pre>
<h4 id="在布局中使用"><a href="#在布局中使用" class="headerlink" title="在布局中使用"></a>在布局中使用</h4><p>　　添加完依赖后就可以在布局中使用RecyclerView了：  </p>
<pre><code class="python">&lt;android.support.v7.widget.RecyclerView
    android:id=<span class="string">"@+id/main_recyclerview"</span>
    android:layout_width=<span class="string">"match_parent"</span>
    android:layout_height=<span class="string">"match_parent"</span> /&gt;
</code></pre>
<h4 id="RecyclerView-Adapter"><a href="#RecyclerView-Adapter" class="headerlink" title="RecyclerView.Adapter"></a>RecyclerView.Adapter</h4><p>　　RecyclerView封装了一种新型的适配器，与现在使用的适配器大同小异。它强制用户使用RecyclerView提供的ViewHolder，使用时主要需要重写onCreateViewHolder与onBindViewHolder方法。前者用来展现视图及其持有者，且只有真正需要一个新view时才会被回调，不需要检查是否已经被回收。后者用来绑定数据到View上。  </p>
<pre><code class="python">import android.content.Context;
import android.support.v7.widget.RecyclerView;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;
import java.util.List;

public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; {
    private Context context;
    private List&lt;String&gt; list;
    private LayoutInflater inflater;

    public MyAdapter(Context context, List&lt;String&gt; list) {
        this.context = context;
        this.list = list;
        inflater = LayoutInflater.from(context);
    }

    @Override
    public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View view = inflater.inflate(R.layout.item_recyclerview, parent, false);
        MyViewHolder holder = new MyViewHolder(view);
        return holder;
    }

    @Override
    public void onBindViewHolder(MyViewHolder holder, int position) {
        holder.textView.setText(list.get(position));
    }

    @Override
    public int getItemCount() {
        return list.size();
    }

    class MyViewHolder extends RecyclerView.ViewHolder {
        TextView textView;
        public MyViewHolder(View itemView) {
            super(itemView);
            textView = (TextView) itemView.findViewById(R.id.item_textview);
        }
    }
}
</code></pre>
<h4 id="LayoutManager"><a href="#LayoutManager" class="headerlink" title="LayoutManager"></a>LayoutManager</h4><p>　　RecyclerView通过布局管理器LayoutManager控制每一个item如何进行排列摆放，何时展示和隐藏。回收或重用一个View时LayoutManager会向适配器请求新的数据来替换旧的数据，这种机制避免了创建过多的View和频繁的调用findViewById方法，目前其自带的主要有以下三种：<br>　　- LinearLayoutManager：ListView样式<br>　　- GridLayoutManager：GridView样式<br>　　- StaggeredGridLayoutManager：瀑布流样式  </p>
<h4 id="ItemDecoration"><a href="#ItemDecoration" class="headerlink" title="ItemDecoration"></a>ItemDecoration</h4><p>　　RecyclerView并不能像ListView一样直接在xml布局中修改item分割线样式。需要在Activity动态设置，当然更推荐在单个条目布局中设置margin或者padding来实现分割线效果，这里提供一个分割线。  </p>
<pre><code class="python">import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.view.View;

public class DividerItemDecoration extends RecyclerView.ItemDecoration {
    private static final int[] ATTRS = new int[]{
            android.R.attr.listDivider
    };
    public static final int HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL;
    public static final int VERTICAL_LIST = LinearLayoutManager.VERTICAL;
    private Drawable mDivider;
    private int mOrientation;

    public DividerItemDecoration(Context context, int orientation) {
        final TypedArray a = context.obtainStyledAttributes(ATTRS);
        mDivider = a.getDrawable(0);
        a.recycle();
        setOrientation(orientation);
    }

    public void setOrientation(int orientation) {
        if (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) {
            throw new IllegalArgumentException("invalid orientation");
        }
        mOrientation = orientation;
    }

    @Override
    public void onDraw(Canvas c, RecyclerView parent) {
        if (mOrientation == VERTICAL_LIST) {
            drawVertical(c, parent);
        } else {
            drawHorizontal(c, parent);
        }
    }

    public void drawVertical(Canvas c, RecyclerView parent) {
        final int left = parent.getPaddingLeft();
        final int right = parent.getWidth() - parent.getPaddingRight();
        final int childCount = parent.getChildCount();
        for (int i = 0; i &lt; childCount; i++) {
            final View child = parent.getChildAt(i);
            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child                     .getLayoutParams();
            final int top = child.getBottom() + params.bottomMargin;
            final int bottom = top + mDivider.getIntrinsicHeight();
            mDivider.setBounds(left, top, right, bottom);
            mDivider.draw(c);
        }
    }

    public void drawHorizontal(Canvas c, RecyclerView parent) {
        final int top = parent.getPaddingTop();
        final int bottom = parent.getHeight() - parent.getPaddingBottom();
        final int childCount = parent.getChildCount();
        for (int i = 0; i &lt; childCount; i++) {
            final View child = parent.getChildAt(i);
            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child                     .getLayoutParams();
            final int left = child.getRight() + params.rightMargin;
            final int right = left + mDivider.getIntrinsicHeight();
            mDivider.setBounds(left, top, right, bottom);
            mDivider.draw(c);
        }
    }

    @Override
    public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) {
        if (mOrientation == VERTICAL_LIST) {
            outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());
        } else {
            outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);
            }
    }
}
</code></pre>
<h4 id="ItemAnimator"><a href="#ItemAnimator" class="headerlink" title="ItemAnimator"></a>ItemAnimator</h4><p>　　ItemAnimator会根据适配器上收到的通知来动画显示视图组的修改，比如item的添加与删除。DefaultItemAnimator已经能很好的展现动画效果了。  </p>
<h4 id="RecyclerView初始化"><a href="#RecyclerView初始化" class="headerlink" title="RecyclerView初始化"></a>RecyclerView初始化</h4><p>　　若想初始化一个RecyclerView使其进入工作状态，你需要在Activity中做以下的操作：  </p>
<pre><code class="python">RecyclerView recyclerView = (RecyclerView)findViewById(R.id.recycler_view_main);
MyAdapter adapter = new MyAdapter(this, list);
//设置RecyclerView保持固定的大小
recyclerView.setHasFixedSize(true);
//设置适配器
recyclerView.setAdapter(adapter);
//设置RecyclerView ListView样式布局管理
recyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false));
//设置RecyclerView的Item分割线
recyclerView.addItemDecoration(new DividerItemDecoration(this, DividerItemDecoration.VERTICAL_LIST));
//设置RecyclerView的动画
recyclerView.setItemAnimator(new DefaultItemAnimator());

//设置RecyclerView GridView样式
//recyclerView.setLayoutManager(new GridLayoutManager(MainActivity.this, <span class="number">3</span>));
//设置RecyclerView 水平GridView样式
//recyclerView.setLayoutManager(new StaggeredGridLayoutManager(<span class="number">5</span>, StaggeredGridLayoutManager.HORIZONTAL));
//设置RecyclerView 瀑布流样式
//recyclerView.setLayoutManager(new StaggeredGridLayoutManager(<span class="number">3</span>,StaggeredGridLayoutManager.VERTICAL));
</code></pre>
<h3 id="点击事件与添加删除Item"><a href="#点击事件与添加删除Item" class="headerlink" title="点击事件与添加删除Item"></a>点击事件与添加删除Item</h3><p>　　美中不足的是RecyclerView并没有提供像ListView一样的Item点击与Item长点击事件，不提供咱们就自己造，通过接口回调来实现。  </p>
<h4 id="Adapter中"><a href="#Adapter中" class="headerlink" title="Adapter中"></a>Adapter中</h4><pre><code class="python">import android.content.Context;
import android.support.v7.widget.RecyclerView;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import java.util.ArrayList;

public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; {
    private Context context;
    private LayoutInflater inflater;
    protected ArrayList&lt;String&gt; datas;
    private onItemClickedListener onItemClickedListener;

    public MyAdapter(Context context, ArrayList&lt;String&gt; datas) {
        this.context = context;
        this.datas = datas;
        inflater = LayoutInflater.from(context);
    }

    public void setOnItemClickedListener(MyAdapter.onItemClickedListener onItemClickedListener) {
        this.onItemClickedListener = onItemClickedListener;
    }

    @Override
    public void onBindViewHolder(MyViewHolder holder, int position) {
        holder.textView.setText(datas.get(position));
    }

    @Override
    public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
    View view = inflater.inflate(R.layout.item_recycler_view, parent, false);
        MyViewHolder myViewHolder = new MyViewHolder(view);
        return myViewHolder;
    }

    @Override
    public int getItemCount() {
        return datas.size();
    }

   /**
    * 添加条目
    */
    public void addItem(int position) {
        datas.add(position, "xulei");
    //        notifyDataSetChanged();
        notifyItemInserted(position);//调用这个才有动画效果
    }

   /**
    * 移除条目
    */
    public void removeItem(int position) {
        datas.remove(position);
        notifyItemRemoved(position);
    }

    class MyViewHolder extends RecyclerView.ViewHolder {
        TextView textView;

        public MyViewHolder(View itemView) {
            super(itemView);
            //初始化控件
            textView = (TextView) itemView.findViewById(R.id.item_textview);
            //设置当前条目单击监听
            itemView.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    if (onItemClickedListener != null)
                        onItemClickedListener.onClick(view, getAdapterPosition());//可立刻获取到当前position
//                        onItemClickedListener.onClick(view, getLayoutPosition());//需等当前视图更新完才能获取到当前position，&lt;16ms。
                }
            });
            //设置当前条目长按监听
            itemView.setOnLongClickListener(new View.OnLongClickListener() {
                @Override
                public boolean onLongClick(View view) {
                    if (onItemClickedListener != null)
                        onItemClickedListener.onLongClick(view, getAdapterPosition());
                    return false;
                }
            });
        }
    }

   /**
    * 点击回调的接口
    */
    interface onItemClickedListener {
        void onClick(View view, int position);

        void onLongClick(View view, int position);
    }
}
</code></pre>
<h4 id="Activity中"><a href="#Activity中" class="headerlink" title="Activity中"></a>Activity中</h4><p>　　在Activity中实例化Adapter之后添加如下代码：</p>
<pre><code class="python">adapter.setOnItemClickedListener(new MyAdapter.onItemClickedListener() {
<span class="meta">    @Override</span>
    public void onClick(View view, int position) {
        adapter.addItem(position);
        Toast.makeText(MainActivity.this, <span class="string">"点击click:"</span> + position, Toast.LENGTH_SHORT).show();
    }

<span class="meta">    @Override</span>
    public void onLongClick(View view, int position) {
        adapter.removeItem(position);
        Toast.makeText(MainActivity.this, <span class="string">"长按click:"</span> + position, Toast.LENGTH_SHORT).show();
    }
});
</code></pre>
<h3 id="瀑布流的实现"><a href="#瀑布流的实现" class="headerlink" title="瀑布流的实现"></a>瀑布流的实现</h3><p>　　想实现瀑布流的样式通过使用RecyclerView也很容易就能实现。</p>
<h4 id="首先在Activity中设置LayoutManager时选择："><a href="#首先在Activity中设置LayoutManager时选择：" class="headerlink" title="首先在Activity中设置LayoutManager时选择："></a>首先在Activity中设置LayoutManager时选择：</h4><pre><code class="python">recyclerView.setLayoutManager(new StaggeredGridLayoutManager(<span class="number">3</span>,StaggeredGridLayoutManager.VERTICAL));
</code></pre>
<h4 id="修改Adapter"><a href="#修改Adapter" class="headerlink" title="修改Adapter"></a>修改Adapter</h4><p>　　瀑布流自然是每个条目的高度不同才能出现瀑布的效果（水平布局则是宽度不同），那么只需在每个条目绑定数据时动态改变下其高度即可，贴出瀑布流Adapter代码：</p>
<pre><code class="python">import android.content.Context;
import android.view.ViewGroup;

import java.util.ArrayList;
import java.util.List;

public class StaggerAdapter extends MyAdapter {
    private List&lt;Integer&gt; heights;
    public StaggerAdapter(Context context, ArrayList&lt;String&gt; datas) {
        super(context, datas);
        heights = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; datas.size(); i++) {
            heights.add((int) (100 + Math.random() * 300));
        }
    }

    @Override
    public void onBindViewHolder(MyViewHolder holder, int position) {
        ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams();
        layoutParams.height = heights.get(position);
//        layoutParams.width = heights.get(position);
        holder.itemView.setLayoutParams(layoutParams);
        holder.textView.setText(datas.get(position));
    }
}
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　通过实践发现RecyclerView相较于ListView与GridView确实强大很多，更加的灵活与方便，提高了开发效率。但也有不足之处，如并未封装点击事件的回调，确实是比较头疼。期待Google的完善。<br>附上GitHub源码：<br><a href="https://github.com/ShylockXu/RecyclerViewDemo" target="_blank" rel="external">RecyclerViewDemo</a><br><a href="https://github.com/ShylockXu/RecyclerViewDevelop" target="_blank" rel="external">RecyclerViewDevelop</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;　　RecyclerView是一种新的视图组，目标是为任何基于适配器的视图提供相似的渲染方式。它被作为ListView和GridView控件的继承者，具有更优的灵活性与可替代性。在最新的support-v7版本中提供支持。本文将讲解RecyclerView的简单实现，添加删除条目，点击事件添加与瀑布流的实现。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="RecyclerView" scheme="http://LeiHolmes.github.io/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>Android开发之AlarmManager闹钟+Notification通知</title>
    <link href="http://LeiHolmes.github.io/2016/12/13/Android%E5%BC%80%E5%8F%91%E4%B9%8BAlarmManager%E9%97%B9%E9%92%9F+Notification%E9%80%9A%E7%9F%A5/"/>
    <id>http://LeiHolmes.github.io/2016/12/13/Android开发之AlarmManager闹钟+Notification通知/</id>
    <published>2016-12-13T03:11:11.000Z</published>
    <updated>2017-05-15T02:54:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>　　AlarmManager实质是一个全局的定时器，是Android中常用的一种系统级别的提示服务，在指定时间或周期性启动其它组件（包括Activity,Service,BroadcastReceiver）。本文将讲解一下如何使用AlarmManager实现定时提醒功能。<br><a id="more"></a></p>
<h3 id="闹钟配置"><a href="#闹钟配置" class="headerlink" title="闹钟配置"></a>闹钟配置</h3><h4 id="周期闹钟"><a href="#周期闹钟" class="headerlink" title="周期闹钟"></a>周期闹钟</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent();</div><div class="line">intent.setAction(GlobalValues.TIMER_ACTION_REPEATING);</div><div class="line">PendingIntent sender = PendingIntent.getBroadcast(context, <span class="number">0</span>, intent, <span class="number">0</span>);</div><div class="line">AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);</div><div class="line">alarm.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + <span class="number">5</span> * <span class="number">1000</span>, <span class="number">3</span> * <span class="number">1000</span>, sender);</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setRepeating(int type,long startTime,long intervalTime,PendingIntent pi)</div></pre></td></tr></table></figure>
<p>　　该方法用于设置周期性执行的定时服务。type：闹钟类型，startTime：闹钟首次执行时间，intervalTime：闹钟两次执行的间隔时间，pi：闹钟响应动作。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setInexactRepeating(int type,long startTime,long intervalTime,PendingIntent pi)</div></pre></td></tr></table></figure></p>
<p>　　该方法也用于设置周期定式服务，与上一种类似。不过其两个闹钟执行的间隔时间不是固定的。它相对而言更省电一些，因为系统可能会将几个差不多的闹钟合并为一个来执行，减少设备的唤醒次数。  </p>
<h5 id="intervalTime内置变量"><a href="#intervalTime内置变量" class="headerlink" title="intervalTime内置变量"></a>intervalTime内置变量</h5><p>间隔一天： 　　INTERVAL_DAY<br>间隔半天： 　　INTERVAL_HALF_DAY<br>间隔15分钟： 　INTERVAL_FIFTEEN_MINUTES<br>间隔半个小时： INTERVAL_HALF_HOUR<br>间隔一个小时： INTERVAL_HOUR  </p>
<h4 id="定时闹钟"><a href="#定时闹钟" class="headerlink" title="定时闹钟"></a>定时闹钟</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//获得系统提供的AlarmManager服务的对象</div><div class="line">AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);</div><div class="line">//Intent设置要启动的组件，这里启动广播</div><div class="line">Intent myIntent = new Intent();</div><div class="line">myIntent.setAction(GlobalValues.TIMER_ACTION);</div><div class="line">//PendingIntent对象设置动作,启动的是Activity还是Service,或广播!</div><div class="line">PendingIntent sender = PendingIntent.getBroadcast(context, <span class="number">0</span>, myIntent,<span class="number">0</span>);</div><div class="line">//注册闹钟</div><div class="line">alarm.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + <span class="number">5</span> * <span class="number">1000</span>, sender);</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set(int type,long startTime,PendingIntent pi)</div></pre></td></tr></table></figure>
<p>　　该方法用于设置一次性定时服务。type：闹钟类型，startTime：闹钟执行时间，pi：闹钟响应动作。  </p>
<h4 id="取消闹钟"><a href="#取消闹钟" class="headerlink" title="取消闹钟"></a>取消闹钟</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Intent myIntent = new Intent();</div><div class="line">myIntent.setAction(GlobalValues.TIMER_ACTION);</div><div class="line">//myIntent.setAction(GlobalValues.TIMER_ACTION_REPEATING);</div><div class="line">PendingIntent sender = PendingIntent.getBroadcast(context, <span class="number">0</span>, myIntent,<span class="number">0</span>);</div><div class="line">AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);</div><div class="line">alarm.cancel(sender);</div></pre></td></tr></table></figure>
<h4 id="设置多个闹钟："><a href="#设置多个闹钟：" class="headerlink" title="设置多个闹钟："></a>设置多个闹钟：</h4><p>　　若连续设置多个闹钟，则只有最后一个闹钟会生效，那么这种情况我们怎么处理呢？其实很简单。我们可以给每个闹钟设置唯一的id，传入getBroadcast()第二个参数。在这里我是每设置一个id则自增1存入Shareprefrence里，保证id唯一性。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> //给每个闹钟设置不同ID防止覆盖</div><div class="line">int alarmId = SharedPreUtils.getInteger(context, <span class="string">"alarm_id"</span>, <span class="number">0</span>);</div><div class="line">SharedPreUtils.setInteger(context, <span class="string">"alarm_id"</span>, ++alarmId);</div><div class="line">PendingIntent sender = PendingIntent.getBroadcast(context, alarmId, myIntent, <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>　　在取消闹钟时我们也可以根据这个id关闭不同的闹钟。  </p>
<h4 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h4><h5 id="type：闹钟类型"><a href="#type：闹钟类型" class="headerlink" title="type：闹钟类型"></a>type：闹钟类型</h5><p>ELAPSED_REALTIME：<br>　　在指定的延时过后，发送广播，但不唤醒设备（闹钟在睡眠状态下不可用）。如果在系统休眠时闹钟触发，它将不会被传递，直到下一次设备唤醒。<br>ELAPSED_REALTIME_WAKEUP：<br>　　在指定的延时过后，发送广播，并唤醒设备（即使关机也会执行operation所对应的组件） 。延时是要把系统启动的时间<code>SystemClock.elapsedRealtime()</code>算进去的。<br>RTC：<br>　　指定当系统调用<code>System.currentTimeMillis()</code>方法返回的值与triggerAtTime相等时启动operation所对应的设备（在指定的时刻，发送广播，但不唤醒设备）。如果在系统休眠时闹钟触发，它将不会被传递，直到下一次设备唤醒（闹钟在睡眠状态下不可用）。<br>RTC_WAKEUP：<br>　　指定当系统调用<code>System.currentTimeMillis()</code>方法返回的值与triggerAtTime相等时启动operation所对应的设备（在指定的时刻，发送广播，并唤醒设备）。即使系统关机也会执行operation所对应的组件。<br>POWER_OFF_WAKEUP：<br>　　表示闹钟在手机关机状态下也能正常进行提示功能，所以是5个状态中用的最多的状态之一，该状态下闹钟也是用绝对时间，状态值为4；不过本状态好像受SDK版本影响，某些版本并不支持。  </p>
<h5 id="long-intervalTime：执行时间"><a href="#long-intervalTime：执行时间" class="headerlink" title="long intervalTime：执行时间"></a>long intervalTime：执行时间</h5><p>　　闹钟的第一次执行时间，以毫秒为单位，可以自定义时间，不过一般使用当前时间。需要注意的是，本属性与第一个属性（type）密切相关，如果第一个参数对应的闹钟使用的是相对时间（ELAPSED_REALTIME和ELAPSED_REALTIME_WAKEUP），那么本属性就得使用相对时间（相对于系统启动时间来说），比如当前时间就表示为：<code>SystemClock.elapsedRealtime();</code>如果第一个参数对应的闹钟使用的是绝对时间（RTC、RTC_WAKEUP、POWER_OFF_WAKEUP），那么本属性就得使用绝对时间，比如当前时间就表示为：<code>System.currentTimeMillis()</code>  </p>
<h5 id="long-startTime：间隔时间"><a href="#long-startTime：间隔时间" class="headerlink" title="long startTime：间隔时间"></a>long startTime：间隔时间</h5><p>　　对于周期定时方式来说，存在本属性，表示两次闹钟执行的间隔时间，也是以毫秒为单位。</p>
<h5 id="PendingIntent-pi：执行动作"><a href="#PendingIntent-pi：执行动作" class="headerlink" title="PendingIntent pi：执行动作"></a>PendingIntent pi：执行动作</h5><p>　　是闹钟的执行动作，比如发送一个广播、给出提示等等。PendingIntent是Intent的封装类。需要注意的是，如果是通过启动服务来实现闹钟提示的话，PendingIntent对象的获取就应该采用<code>Pending.getService(Context c,int i,Intent intent,int j)</code>方法；如果是通过广播来实现闹钟提示的话，PendingIntent对象的获取就应该采<code>用PendingIntent.getBroadcast(Context c,int i,Intent intent,int j)</code>方法；如果是采用Activity的方式来实现闹钟提示的话，PendingIntent对象的获取就应该采用<code>PendingIntent.getActivity(Context c,int i,Intent intent,int j)</code>方法。如果这三种方法错用了的话，虽然不会报错，但是看不到闹钟提示效果。。</p>
<h3 id="广播配置"><a href="#广播配置" class="headerlink" title="广播配置"></a>广播配置</h3><h4 id="新建闹钟BroadCastReceiver："><a href="#新建闹钟BroadCastReceiver：" class="headerlink" title="新建闹钟BroadCastReceiver："></a>新建闹钟BroadCastReceiver：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class AlarmReceiver extends BroadcastReceiver &#123;</div><div class="line">    private NotificationManager m_notificationMgr = null;</div><div class="line">    private static final int NOTIFICATION_FLAG = 3;</div><div class="line">    @Override</div><div class="line">    public void onReceive(Context context, Intent intent) &#123;</div><div class="line">        m_notificationMgr = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVIC</div><div class="line">        if (intent.getAction().equals(GlobalValues.TIMER_ACTION_REPEATING)) &#123;</div><div class="line">            Log.e("alarm_receiver", "周期闹钟");</div><div class="line">        &#125; else if (intent.getAction().equals(GlobalValues.TIMER_ACTION)) &#123;</div><div class="line">            Log.e("alarm_receiver", "定时闹钟");</div><div class="line">                        Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.logo);</div><div class="line">            Intent intent1 = new Intent(context, WriteDiaryActivity.class);</div><div class="line">            PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent1, 0);</div><div class="line">            Notification notify = new Notification.Builder(context)</div><div class="line">                    .setSmallIcon(R.drawable.logo) // 设置状态栏中的小图片，尺寸一般建议在24×24</div><div class="line">                    .setLargeIcon(bitmap) // 这里也可以设置大图标</div><div class="line">                    .setTicker("亲情日历") // 设置显示的提示文字</div><div class="line">                    .setContentTitle("亲情日历") // 设置显示的标题</div><div class="line">                    .setContentText("您有日记提醒哦") // 消息的详细内容</div><div class="line">                    .setContentIntent(pendingIntent) // 关联PendingIntent</div><div class="line">                    .setNumber(1) // 在TextView的右方显示的数字，可以在外部定义一个变量，点击累加setNumber(count),这时显示的和</div><div class="line">                    .getNotification(); // 需要注意build()是在API level16及之后增加的，在API11中可以使用getNotificatin()来</div><div class="line">            notify.flags |= Notification.FLAG_AUTO_CANCEL;</div><div class="line">            NotificationManager manager = (NotificationManager) context.getSystemService(Context.NOTIF</div><div class="line">            manager.notify(NOTIFICATION_FLAG, notify);</div><div class="line">            bitmap.recycle(); //回收bitmap</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="注册BroadCastReceiver："><a href="#注册BroadCastReceiver：" class="headerlink" title="注册BroadCastReceiver："></a>注册BroadCastReceiver：</h4><p>　　最后别忘了在清单里注册广播。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;!--闹钟接收广播--&gt;</div><div class="line">&lt;receiver android:name=".util.service.AlarmReceiver"&gt;</div><div class="line">    &lt;intent-filter&gt;</div><div class="line">        &lt;action android:name="com.e_eduspace.TIMER_ACTION_REPEATING" /&gt;</div><div class="line">        &lt;action android:name="com.e_eduspace.TIMER_ACTION" /&gt;</div><div class="line">    &lt;/intent-filter&gt;</div><div class="line">&lt;/receiver&gt;</div></pre></td></tr></table></figure></p>
<h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><h4 id="常量："><a href="#常量：" class="headerlink" title="常量："></a>常量：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class GlobalValues &#123;</div><div class="line">    // 周期性的闹钟</div><div class="line">    public final static String TIMER_ACTION_REPEATING = "com.e_eduspace.TIMER_ACTION_REPEATING";</div><div class="line">    // 定时闹钟</div><div class="line">    public final static String TIMER_ACTION = "com.e_eduspace.TIMER_ACTION";</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">package com.e_eduspace.familycalendar.util;</div><div class="line"></div><div class="line">import android.app.AlarmManager;</div><div class="line">import android.app.PendingIntent;</div><div class="line">import android.content.Context;</div><div class="line">import android.content.Intent;</div><div class="line"></div><div class="line">import com.prolificinteractive.materialcalendarview.CalendarDay;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 闹钟定时工具类</div><div class="line"> *</div><div class="line"> * @author xulei</div><div class="line"> * @time 2016/12/13 10:03</div><div class="line"> */</div><div class="line"></div><div class="line">public class AlarmTimer &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 设置周期性闹钟</div><div class="line">     *</div><div class="line">     * @param context</div><div class="line">     * @param firstTime</div><div class="line">     * @param cycTime</div><div class="line">     * @param action</div><div class="line">     * @param AlarmManagerType 闹钟的类型，常用的有5个值：AlarmManager.ELAPSED_REALTIME、</div><div class="line">     *                         AlarmManager.ELAPSED_REALTIME_WAKEUP、AlarmManager.RTC、</div><div class="line">     *                         AlarmManager.RTC_WAKEUP、AlarmManager.POWER_OFF_WAKEUP</div><div class="line">     */</div><div class="line">    public static void setRepeatingAlarmTimer(Context context, long firstTime,</div><div class="line">                                              long cycTime, String action, int AlarmManagerType) &#123;</div><div class="line">        Intent myIntent = new Intent();</div><div class="line">        myIntent.setAction(action);</div><div class="line">        PendingIntent sender = PendingIntent.getBroadcast(context, 0, myIntent, 0);</div><div class="line">        AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);</div><div class="line">        alarm.setRepeating(AlarmManagerType, firstTime, cycTime, sender);</div><div class="line">        //param1：闹钟类型，param1：闹钟首次执行时间，param1：闹钟两次执行的间隔时间，param1：闹钟响应动作。</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 设置定时闹钟</div><div class="line">     *</div><div class="line">     * @param context</div><div class="line">     * @param cycTime</div><div class="line">     * @param action</div><div class="line">     * @param AlarmManagerType 闹钟的类型，常用的有5个值：AlarmManager.ELAPSED_REALTIME、</div><div class="line">     *                         AlarmManager.ELAPSED_REALTIME_WAKEUP、AlarmManager.RTC、</div><div class="line">     *                         AlarmManager.RTC_WAKEUP、AlarmManager.POWER_OFF_WAKEUP</div><div class="line">     */</div><div class="line">    public static void setAlarmTimer(Context context, long cycTime,</div><div class="line">                                     String action, int AlarmManagerType, CalendarDay date) &#123;</div><div class="line">        Intent myIntent = new Intent();</div><div class="line">        //传递定时日期</div><div class="line">        myIntent.putExtra("date", date);</div><div class="line">        myIntent.setAction(action);</div><div class="line">        //给每个闹钟设置不同ID防止覆盖</div><div class="line">        int alarmId = SharedPreUtils.getInteger(context, "alarm_id", 0);</div><div class="line">        SharedPreUtils.setInteger(context, "alarm_id", ++alarmId);</div><div class="line">        PendingIntent sender = PendingIntent.getBroadcast(context, alarmId, myIntent, 0);</div><div class="line">        AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);</div><div class="line">        alarm.set(AlarmManagerType, cycTime, sender);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 取消闹钟</div><div class="line">     *</div><div class="line">     * @param context</div><div class="line">     * @param action</div><div class="line">     */</div><div class="line">    public static void cancelAlarmTimer(Context context, String action) &#123;</div><div class="line">        Intent myIntent = new Intent();</div><div class="line">        myIntent.setAction(action);</div><div class="line">        PendingIntent sender = PendingIntent.getBroadcast(context, 0, myIntent,0);</div><div class="line">        AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);</div><div class="line">        alarm.cancel(sender);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;　　AlarmManager实质是一个全局的定时器，是Android中常用的一种系统级别的提示服务，在指定时间或周期性启动其它组件（包括Activity,Service,BroadcastReceiver）。本文将讲解一下如何使用AlarmManager实现定时提醒功能。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="AlarmManager" scheme="http://LeiHolmes.github.io/tags/AlarmManager/"/>
    
  </entry>
  
  <entry>
    <title>Android开发之Retrofit2.0网络请求框架初尝试</title>
    <link href="http://LeiHolmes.github.io/2016/04/29/Android%E5%BC%80%E5%8F%91%E4%B9%8BRetrofit%E5%88%9D%E5%B0%9D%E8%AF%95/"/>
    <id>http://LeiHolmes.github.io/2016/04/29/Android开发之Retrofit初尝试/</id>
    <published>2016-04-29T07:41:00.000Z</published>
    <updated>2017-05-15T02:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Retrofit2-0简介"><a href="#Retrofit2-0简介" class="headerlink" title="Retrofit2.0简介"></a>Retrofit2.0简介</h3><p>　　Retrofit是一套RESTful架构的Android(Java)客户端实现，基于注解，提供JSON to POJO(Plain Ordinary Java Object,简单Java对象)，POJO to JSON，网络请求(POST，GET,PUT，DELETE等)封装。用官方自己的介绍就是:</p>
<blockquote>
<p>A type-safe REST client for Android and Java</p>
</blockquote>
<p>　　现已更新到2.0的版本，与1.0版本的使用上还是不小的差别，我也是第一次用，这里主要和大家研究研究2.0版本简单使用。也可参详<a href="http://square.github.io/retrofit/" target="_blank" rel="external">官方示例</a>。<br><a id="more"></a>  </p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="添加权限"><a href="#添加权限" class="headerlink" title="添加权限"></a>添加权限</h4><p>首先添加网络请求权限  </p>
<pre><code class="xml"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span>/&gt;</span>
</code></pre>
<h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>Retrofit2.0版本后只支持okhttp请求，也已经封装好了，就不需要添加okhttp的依赖了。  </p>
<pre><code class="xml">dependencies {
    compile &#39;com.squareup.retrofit2:retrofit:2.0.2&#39;
    compile &#39;com.squareup.retrofit2:converter-gson:2.0.0-beta3&#39;
}
</code></pre>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>接下来瞧一瞧Retrofit初始化以及如何请求数据。</p>
<h4 id="初始化Retrofit对象"><a href="#初始化Retrofit对象" class="headerlink" title="初始化Retrofit对象"></a>初始化Retrofit对象</h4><pre><code class="java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASE_URL = <span class="string">"https://api.github.com/"</span>;
Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()
        .baseUrl(BASE_URL)
        .addConverterFactory(GsonConverterFactory.create())
        .build();
</code></pre>
<p>BASE_URL就是你请求的Server地址。  </p>
<pre><code class="java">.addConverterFactory(GsonConverterFactory.create())
</code></pre>
<p>Retrofit2.0不提供返回JSON数据的默认解析方式，需要手动指定，支持Jackson等多种解析方式。需要哪种就添加相应的依赖，这里添加的是Retrofit提供的converter-gson依赖。有点不爽的就是不支持FastJson解析，有需要的话可以自己写一个FastjsonConverterFactory继承Converter.Factory实现。  </p>
<p>虽然Retrofit2.0后只支持okhttp请求，但你也可以自定义一个okhttp再配置进Retrofit。  </p>
<pre><code class="java">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();
client.interceptors().add(<span class="keyword">new</span> Interceptor() {
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>{
            Response response = chain.proceed(chain.request());
            <span class="comment">// Do anything with response here</span>
            <span class="keyword">return</span> response;
        }
Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()
        .baseUrl(BASE_URL)
        .client(client)
        .addConverterFactory(GsonConverterFactory.create())
        .build();
});
</code></pre>
<h4 id="定义请求接口"><a href="#定义请求接口" class="headerlink" title="定义请求接口"></a>定义请求接口</h4><p>实现转换HTTP API为Java接口，Retrofit提供了5种内置的注解：GET、POST、PUT、DELETE和HEAD，在注解中指定的资源的相对URL。  </p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NetWorkService</span> </span>{
    <span class="meta">@GET</span>(<span class="string">"users/basil2style"</span>)
    <span class="function">Call&lt;DataBean&gt; <span class="title">getData</span><span class="params">()</span></span>;
}
</code></pre>
<p>使用替换块和参数进行动态更新,替换块是{ and }包围的字母数字组成的字符串，相应的参数必须使用相同的字符串被@Path进行注释。  </p>
<pre><code class="java"><span class="meta">@GET</span>(<span class="string">"repos/{params1}/{params2}/contributors"</span>)
Call&lt;List&lt;DataBean2&gt;&gt; getData(
        <span class="meta">@Path</span>(<span class="string">"params1"</span>) String params1,
        <span class="meta">@Path</span>(<span class="string">"params2"</span>) String params2,
);
</code></pre>
<p>当我们调用getData()这个方法的时候，Retrofit会创建这个URL。如果我们传入Square和Retrofit字符串，分别作为owner和repo参数。我们就会得到这个URL：<a href="https://api.github.com/repos/square/retrofit/contributors" target="_blank" rel="external">https://api.github.com/repos/square/retrofit/contributors</a>  </p>
<p>添加查询参数  </p>
<pre><code class="java"><span class="meta">@GET</span>(<span class="string">"repos/square/{retrofit}/contributors"</span>)
Call&lt;List&lt;DataBean2&gt;&gt; groupData(<span class="meta">@Path</span>(<span class="string">"retrofit"</span>) String retrofit, <span class="meta">@Query</span>(<span class="string">"sort"</span>) String sort);
</code></pre>
<p>当我们调用getData()方法时，传入一个查询参数字符串”ok”,这样我们就能得到URL：<a href="https://api.github.com/repos/square/retrofit/contributors?sort=ok" target="_blank" rel="external">https://api.github.com/repos/square/retrofit/contributors?sort=ok</a></p>
<p>当然如果查询参数过多，我们也可以使用Map进行组合再传进来。  </p>
<pre><code class="java"><span class="meta">@GET</span>(<span class="string">"repos/square/{retrofit}/contributors"</span>)
Call&lt;List&lt;DataBean2&gt;&gt; getData(<span class="meta">@Path</span>(<span class="string">"repos"</span>) String repos, <span class="meta">@QueryMap</span> Map&lt;String, String&gt; parameters);
</code></pre>
<h4 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h4><p>Retrifot支持同步和异步的请求方式，先使用Retrofit类生成接口NetWorkService的实现。  </p>
<pre><code class="java">NetWorkService service = retrofit.create(NetWorkService.class);
</code></pre>
<h5 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h5><pre><code class="java">Call&lt;DataBean&gt; call = service.getData(Square,Retrofit);
DataBean bean = call.execute().body();
</code></pre>
<p>注意同步请求不可在主线程执行，你懂得。且call只能执行execute()方法一次，若要再次请求可通过<code>Call&lt;DataBean&gt; call = call.clone()</code>来再复制一个Call对象。  </p>
<h5 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h5><pre><code class="java">call.enqueue(<span class="keyword">new</span> Callback&lt;DataBean&gt;() {
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;DataBean&gt; call, Response&lt;DataBean&gt; response)</span> </span>{
        Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"请求成功"</span>, Toast.LENGTH_SHORT).show();
        DataBean bean = response.body();
        tvMain.setText(bean.toString());
    }
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;DataBean&gt; call, Throwable t)</span> </span>{
    }
});
</code></pre>
<p>当我们执行的同步或异步加入队列后，可以随时使用call.cancel()方法取消请求。  </p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>注解中参数的写法与BASE_URL的拼接一定要注意，请看以下写法。  </p>
<h4 id="错误示例1"><a href="#错误示例1" class="headerlink" title="错误示例1"></a>错误示例1</h4><p>BASE_URL：<a href="https://api.github.com/repos/square" target="_blank" rel="external">https://api.github.com/repos/square</a><br>Get注解：　@GET(“/basil2style”)<br>结果URL：　<a href="https://api.github.com/basil2style" target="_blank" rel="external">https://api.github.com/basil2style</a>  </p>
<h4 id="错误示例2"><a href="#错误示例2" class="headerlink" title="错误示例2"></a>错误示例2</h4><p>BASE_URL：<a href="https://api.github.com/repos/square" target="_blank" rel="external">https://api.github.com/repos/square</a><br>Get注解：　@GET(“basil2style”)<br>结果URL：　<a href="https://api.github.com/repos/basil2style" target="_blank" rel="external">https://api.github.com/repos/basil2style</a>  </p>
<h4 id="推荐写法"><a href="#推荐写法" class="headerlink" title="推荐写法"></a>推荐写法</h4><p>BASE_URL：<a href="https://api.github.com/repos/square/" target="_blank" rel="external">https://api.github.com/repos/square/</a><br>Get注解：　@GET(“basil2style”)<br>结果URL：　<a href="https://api.github.com/repos/square/basil2style" target="_blank" rel="external">https://api.github.com/repos/square/basil2style</a>  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最简单的Retrofit实现流程完毕，Retrofit+Okhttp+Gson可以算是目前来说相当快的超级网络请求框架了。相比较于Volley都快不少，亲测结果：爽爽爽。小伙伴们赶紧整起来吧！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Retrofit2-0简介&quot;&gt;&lt;a href=&quot;#Retrofit2-0简介&quot; class=&quot;headerlink&quot; title=&quot;Retrofit2.0简介&quot;&gt;&lt;/a&gt;Retrofit2.0简介&lt;/h3&gt;&lt;p&gt;　　Retrofit是一套RESTful架构的Android(Java)客户端实现，基于注解，提供JSON to POJO(Plain Ordinary Java Object,简单Java对象)，POJO to JSON，网络请求(POST，GET,PUT，DELETE等)封装。用官方自己的介绍就是:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A type-safe REST client for Android and Java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　现已更新到2.0的版本，与1.0版本的使用上还是不小的差别，我也是第一次用，这里主要和大家研究研究2.0版本简单使用。也可参详&lt;a href=&quot;http://square.github.io/retrofit/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方示例&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="Retrofit" scheme="http://LeiHolmes.github.io/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>Android开发之神器Stetho调试Volley</title>
    <link href="http://LeiHolmes.github.io/2016/04/19/Android%E5%BC%80%E5%8F%91%E4%B9%8B%E7%A5%9E%E5%99%A8Stetho%E8%B0%83%E8%AF%95Volley/"/>
    <id>http://LeiHolmes.github.io/2016/04/19/Android开发之神器Stetho调试Volley/</id>
    <published>2016-04-19T04:19:16.000Z</published>
    <updated>2017-05-15T02:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Stetho简介"><a href="#Stetho简介" class="headerlink" title="Stetho简介"></a>Stetho简介</h3><p>Stetho 是 Facebook 开源的一个 Android 调试工具。是一个 Chrome Developer Tools 的扩展，可用来检测应用的网络、数据库、WebKit 等方面的功能。开发者也可通过它的 dumpapp 工具提供强大的命令行接口来访问应用内部。无需root查看sqlite文件、sharedpreference文件等等。更多详细介绍可以进入<a href="http://facebook.github.io/stetho/" target="_blank" rel="external">Stetho官网</a>。<br><a id="more"></a></p>
<h3 id="Stetho结合OkHttp使用"><a href="#Stetho结合OkHttp使用" class="headerlink" title="Stetho结合OkHttp使用"></a>Stetho结合OkHttp使用</h3><h5 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Gradle dependency on Stetho </div><div class="line">  dependencies &#123; </div><div class="line">    compile 'com.facebook.stetho:stetho:1.1.1' </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h5 id="Stetho初始化配置"><a href="#Stetho初始化配置" class="headerlink" title="Stetho初始化配置"></a>Stetho初始化配置</h5><p>在App的Application中完成初始化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate();</div><div class="line">    Stetho.initialize(</div><div class="line">      Stetho.newInitializerBuilder(<span class="keyword">this</span>)</div><div class="line">        .enableDumpapp(</div><div class="line">            Stetho.defaultDumperPluginsProvider(<span class="keyword">this</span>))</div><div class="line">        .enableWebKitInspector(</div><div class="line">            Stetho.defaultInspectorModulesProvider(<span class="keyword">this</span>))</div><div class="line">        .build());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>官网中使用OkHttp为实例，使用如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line">client.networkInterceptors().add(<span class="keyword">new</span> StethoInterceptor());</div></pre></td></tr></table></figure></p>
<p>然后就可以运行App进行调试，基本上可以满足调试需求了。</p>
<h3 id="Stetho结合Volley使用"><a href="#Stetho结合Volley使用" class="headerlink" title="Stetho结合Volley使用"></a>Stetho结合Volley使用</h3><p>官网中Stetho是结合OkHttp的使用，如果项目中使用Volley做为网络请求框架，可以做如下修改。还是使用OkHttp做为Volley中HttpStack的实现，我们知道，Volley中网络请求在Android2.3及以上基于HttpURLConnection，2.3以下基于HttpClient实现，通过增加HttpStack的具体实现即可。这里使用<a href="https://gist.github.com/bryanstern/4e8f1cb5a8e14c202750" target="_blank" rel="external">Bryan Stern分享的代码</a>。（网页可能被墙，可以通过VPN访问。需要VPN的可以<a href="http://reftizi.com/?r=bf31aecac9700bac" target="_blank" rel="external">点击这里</a>）</p>
<h5 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">compile 'com.facebook.stetho:stetho:1.1.1'</div><div class="line">compile 'com.facebook.stetho:stetho-okhttp:1.1.1'</div><div class="line">compile 'com.squareup.okhttp:okhttp:2.3.0'</div></pre></td></tr></table></figure>
<h5 id="Stetho初始化配置-1"><a href="#Stetho初始化配置-1" class="headerlink" title="Stetho初始化配置"></a>Stetho初始化配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line">client.networkInterceptors().add(<span class="keyword">new</span> StethoInterceptor());</div><div class="line">mRequestQueue = Volley.newRequestQueue(getApplicationContext(), <span class="keyword">new</span> OkHttpStack(client));</div></pre></td></tr></table></figure>
<p>好了，基本上这样就能使用Stetho神器调试你的App了，感觉到强大了么~。</p>
<h3 id="补充：使用中遇到的坑"><a href="#补充：使用中遇到的坑" class="headerlink" title="补充：使用中遇到的坑"></a>补充：使用中遇到的坑</h3><ul>
<li><p>Stetho inspect窗口空白 </p>
<p>如果出现调试窗口空白，先升级下Chrome吧。升级最新版后再试一下（我被这个坑了）。</p>
</li>
<li><p>Stetho inspect窗口还是空白 </p>
<p>如果Chrome是最新版，无论如何刷新都是空白，那么恭喜你你可能被墙了~用VPN试试吧 <a href="!http://reftizi.com/?r=bf31aecac9700bac">可以戳这里哦</a></p>
</li>
</ul>
<h3 id="我的测试代码和效果图如下："><a href="#我的测试代码和效果图如下：" class="headerlink" title="我的测试代码和效果图如下："></a>我的测试代码和效果图如下：</h3><p>自定义Application类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppliation</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onCreate();</div><div class="line">		context = getApplicationContext();</div><div class="line">		instance = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">		Stetho.initialize(</div><div class="line">				Stetho.newInitializerBuilder(<span class="keyword">this</span>)</div><div class="line">						.enableDumpapp(Stetho.defaultDumperPluginsProvider(<span class="keyword">this</span>))</div><div class="line">						.enableWebKitInspector(Stetho.defaultInspectorModulesProvider(<span class="keyword">this</span>))</div><div class="line">						.build());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@return</span> The Volley Request queue</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> RequestQueue <span class="title">getRequestQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// lazy initialize the request queue, the queue instance will be</span></div><div class="line">		<span class="comment">// created when it is accessed for the first time</span></div><div class="line">		<span class="keyword">synchronized</span> (App.class) &#123;</div><div class="line">			<span class="keyword">if</span> (mRequestQueue == <span class="keyword">null</span>) &#123;</div><div class="line">				OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line">				client.networkInterceptors().add(<span class="keyword">new</span> StethoInterceptor());</div><div class="line">				mRequestQueue = Volley.newRequestQueue(getApplicationContext(), <span class="keyword">new</span> OkHttpStack(client));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> mRequestQueue;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Activity类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> TextView tv;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.layout_main);</div><div class="line">        tv = (TextView)findViewById(R.id.tv);</div><div class="line"></div><div class="line">        RequestQueue queue = App.getInstance().getRequestQueue();</div><div class="line">        String url = <span class="string">"https://publicobject.com/helloworld.txt"</span>;</div><div class="line">        StringRequest request = <span class="keyword">new</span> StringRequest(Request.Method.GET, url, <span class="keyword">new</span> Response.Listener&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">                LogUtil.d(s);</div><div class="line">                tv.setText(s);</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="keyword">new</span> com.android.volley.Response.ErrorListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError volleyError)</span> </span>&#123;</div><div class="line">                LogUtil.e(volleyError.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        queue.add(request);</div><div class="line"></div><div class="line">        SharedPrfUtil.setInt(<span class="string">"uid"</span>,<span class="number">669</span>);</div><div class="line">        SharedPrfUtil.setString(<span class="string">"username"</span>,<span class="string">"dongye"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现效果如下图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://dongyeforever.qiniudn.com/stetho-all.png" alt="Stetho调试效果图" title="">
                </div>
                <div class="image-caption">Stetho调试效果图</div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://dongyeforever.qiniudn.com/stetho-inspect.png" alt="调试程序列表" title="">
                </div>
                <div class="image-caption">调试程序列表</div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://dongyeforever.qiniudn.com/inspect-network.png" alt="调试网络请求" title="">
                </div>
                <div class="image-caption">调试网络请求</div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://dongyeforever.qiniudn.com/inspect-sharedpreference.png" alt="读取数据存储" title="">
                </div>
                <div class="image-caption">读取数据存储</div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Stetho简介&quot;&gt;&lt;a href=&quot;#Stetho简介&quot; class=&quot;headerlink&quot; title=&quot;Stetho简介&quot;&gt;&lt;/a&gt;Stetho简介&lt;/h3&gt;&lt;p&gt;Stetho 是 Facebook 开源的一个 Android 调试工具。是一个 Chrome Developer Tools 的扩展，可用来检测应用的网络、数据库、WebKit 等方面的功能。开发者也可通过它的 dumpapp 工具提供强大的命令行接口来访问应用内部。无需root查看sqlite文件、sharedpreference文件等等。更多详细介绍可以进入&lt;a href=&quot;http://facebook.github.io/stetho/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Stetho官网&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="Stetho" scheme="http://LeiHolmes.github.io/tags/Stetho/"/>
    
  </entry>
  
</feed>
