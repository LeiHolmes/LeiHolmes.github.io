<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lei’s Blog</title>
  <subtitle>自信源于准备！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://LeiHolmes.github.io/"/>
  <updated>2019-12-05T09:32:03.005Z</updated>
  <id>http://LeiHolmes.github.io/</id>
  
  <author>
    <name>徐雷</name>
    <email>17611595118@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见问题：浮点数据超长变科学计数</title>
    <link href="http://LeiHolmes.github.io/2019/12/05/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%EF%BC%9A%E6%B5%AE%E7%82%B9%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0/"/>
    <id>http://LeiHolmes.github.io/2019/12/05/常见问题：浮点数据科学计数/</id>
    <published>2019-12-04T16:00:00.000Z</published>
    <updated>2019-12-05T09:32:03.005Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　在项目开发中发现当Double类型的小数整数部分超过8位时，会自动转换为科学计数来展示，这肯定是不符合需求的，通过下面的方法可轻松搞定科学计数的问题，并进行保留2位小数与去除无用0的处理。<br>　　<a id="more"></a></p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>　　抽出一个文本格式化工具类TextFormatUtil。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextFormatUtil</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DecimalFormat mDecimalFormat = <span class="keyword">new</span> DecimalFormat(<span class="string">"0.##"</span>);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 格式化小数</div><div class="line">     * 保留两位，并做位数过大处理</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDouble</span><span class="params">(<span class="keyword">double</span> number)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (number != <span class="number">0.00</span>) <span class="keyword">return</span> mDecimalFormat.format(number);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"0"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　使用时直接调用即可：<code>TextFormatUtil.formatDouble(formatNumber)</code>。简单解释一下，DecimalFormat是由Java提供的用于对十进制数字进行格式化的工具，按照符号进行填充，区分整数部分与小数部分：</p>
<ul>
<li>整数：从个位向高位填充，若位上有值则为原来的值，无值则看符号，符号为“0”则以“0”填充，符号为“#”则空着不填充。</li>
<li>小数：符号为“0”或者“#”的个数都代表保留小数点后的几位，区别是“0”代表小数不足的部分以“0”填充，“#”代表小数不足的部分空着不填充。  </li>
</ul>
<p>　　当然DecimalFormat还有更多的符号用法，需要的大家自行百度啦，这里就不赘述了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　博客好久没更新了，近期准备整理一下平时遇到的常见问题分享出来，有问题的话欢迎大家指正。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;　　在项目开发中发现当Double类型的小数整数部分超过8位时，会自动转换为科学计数来展示，这肯定是不符合需求的，通过下面的方法可轻松搞定科学计数的问题，并进行保留2位小数与去除无用0的处理。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="Bug" scheme="http://LeiHolmes.github.io/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>Android面试技术点总结</title>
    <link href="http://LeiHolmes.github.io/2019/01/29/Android%E9%9D%A2%E8%AF%95%E6%8A%80%E6%9C%AF%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://LeiHolmes.github.io/2019/01/29/Android面试技术点总结/</id>
    <published>2019-01-28T16:00:00.000Z</published>
    <updated>2019-01-29T07:22:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　年末一周不忙了，总结了下在Android开发面试中易问的一些Android相关基础知识与面试题，不太全，大家查缺补漏吧。开始Review！<br>　　<a id="more"></a></p>
<h2 id="Android组件"><a href="#Android组件" class="headerlink" title="Android组件"></a>Android组件</h2><h3 id="Android四大组件"><a href="#Android四大组件" class="headerlink" title="Android四大组件"></a>Android四大组件</h3><ul>
<li><strong>Activity</strong>：一个Activity通常就是一个单独的屏幕，它上面可以显示一些控件也可以监听并处理用户的事件做出响应。</li>
<li><strong>Service</strong>：服务，一段长生命周期的，没有用户界面的程序，可以用来开发如监控类程序。<ul>
<li><strong>bindingService()</strong>：调用者与服务绑定在一起，不同生，但同死。</li>
<li><strong>startService()</strong>：调用者与服务无关联，调用者退出，服务依然继续。</li>
</ul>
</li>
<li><strong>BroadcastReceiver</strong>：广播接收器，对外部事件进行过滤只对感兴趣的外部事件进行接收并做出响应。</li>
<li><strong>ContentProvider</strong>：内容提供者，使一个应用程序的指定数据集提供给其他应用程序。</li>
</ul>
<h3 id="Activity启动模式"><a href="#Activity启动模式" class="headerlink" title="Activity启动模式"></a>Activity启动模式</h3><ul>
<li><strong>Standard</strong>：每次都创建新实例加入启动它的Activity的栈中。注意不可使用ApplicationContext来启动，由于非Activity的Context没有任务栈，所以会报错，可通过设置FLAG_ACTIVITY_NEW_TASK标志从而创建新的任务栈将其压入栈中。</li>
<li><strong>SingleTop</strong>：若新实例已位于栈顶，则复用并调用其onNewIntent，不调用onCreate与onStart。否则新建。</li>
<li><strong>SingleTask</strong>：若新实例已位于其需要的栈中，则复用并将其栈上的Activity都弹出。否则新建。</li>
<li><strong>SingleInstance</strong>：具有SingleTask的特性，每个不同类型的Activity都只能独占一个栈，遵循栈内复用。</li>
</ul>
<h3 id="Activity的TaskAffinity属性"><a href="#Activity的TaskAffinity属性" class="headerlink" title="Activity的TaskAffinity属性"></a>Activity的TaskAffinity属性</h3><ul>
<li><strong>TaskAffinity</strong>：指Activity的归属，控制Activity所属的任务栈。每个Activity都有TaskAffinity属性，指出了它希望进入的Task。若没有显性指定它的属性等于Application指明的TaskAffinity，若Application也没有指明，那么该TaskAffinity的值等于其应用包名。只对启动模式为<strong>SingleTask/SingleInstance</strong>的Activity起作用。</li>
<li><strong>与allowTaskReparenting属性配合使用</strong>：当把Activity的allowTaskReparenting属性设置成true时，Activity就可以从启动的任务栈移动到TaskAffinity指定的任务栈。例：在TaskA中启动了TaskB的ActivityC，若ActivityC的allowTaskReparenting为true，且ActivityC与TaskB的TaskAffinity相同，那么当TaskB被启动时，ActivityC会直接从TaskA转移到TaskB中。</li>
<li><strong>与SingleTask启动模式配合使用</strong>：当指定Activity启动模式为SingleTask或设置FLAG_ACTIVITY_NEW_TASK标识时，系统会先检查当前Task与Activity的TaskAffinity是否相同，相同则放入当前Task，不同则寻找有无与其TaskAffinity相同的Task，有则放入那个Task中，无则新建一个与其TaskAffinity值相同的Task并加入其中，加入的Task会被调至前台。</li>
</ul>
<h3 id="Activity的Flags"><a href="#Activity的Flags" class="headerlink" title="Activity的Flags"></a>Activity的Flags</h3><ul>
<li><strong>FLAG_ACTIVITY_NEW_TASK</strong>：指定Activity的启动模式为“singleTask”。优先级大于清单中配置。</li>
<li><strong>FLAG_ACTIVITY_SINGLE_TOP</strong>：指定Activity的启动模式为“singleTop”。优先级大于清单中配置。</li>
<li><strong>FLAG_ACTIVITY_CLEAR_TOP</strong>：具有此标记且为“standard”模式的Activity启动时，同一栈中它连同它之上的Activity都出栈，再创建新的实例压入栈中。</li>
<li><strong>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</strong>：具有此标记的Activity不会出现在Activity的历史列表中。等同于在清单中指定Activity的属性<code>android:excludeFromRecents = &quot;true&quot;</code></li>
</ul>
<h3 id="Intent七大属性"><a href="#Intent七大属性" class="headerlink" title="Intent七大属性"></a>Intent七大属性</h3><ul>
<li><strong>ComponentName</strong>：主要用于跨应用访问Activity，进行显式意图访问。（显式 setAction(Intent.xxx)）</li>
<li><strong>Action</strong>：表示想要启动的Activity要完成什么动作，例如: 调用系统的app打电话, 发短信等程序。（隐式 setComponent(ComponentName cn)）</li>
<li><strong>Category</strong>：为Action增加附加类别信息，它是Action大动作的子动作。（隐式 addCategory(Intent.CATEGORY_XXX)）</li>
<li><strong>Extras</strong>：保存需要传递的额外数据，比如邮件标题、正文、收件人、抄送人、短信内容等。（隐式、显式 putExtra(String key,String value);）</li>
<li><strong>Data</strong>：保存需要传递的数据Uri格式(Uri:统一资源标识符)，比如  tel:  mailto:  smsto等。（隐式 setData(Uri.parse(“tel:xxxxx”))）</li>
<li><strong>Type</strong>：区分文件类型(MIME大类型/子类型)，例如audio/mp3等。（隐式 setType(“XXX/xxx”) ）</li>
<li><strong>Flags</strong>：动态配置Activity的启动模式。（addFlags(int)或setFlags(int)）</li>
</ul>
<h3 id="数据存储方式"><a href="#数据存储方式" class="headerlink" title="数据存储方式"></a>数据存储方式</h3><ul>
<li><strong>SharePreferences</strong>：使用模式Context.MODE_PRIVATE，故不可被其他应用访问，但可获取到目标App的Context即可实现跨进程使用。</li>
<li><strong>ContentProvider</strong></li>
<li><strong>SQLite数据库</strong></li>
<li><strong>File文件</strong></li>
<li><strong>网络存储</strong></li>
</ul>
<h3 id="Android布局方式及特点"><a href="#Android布局方式及特点" class="headerlink" title="Android布局方式及特点"></a>Android布局方式及特点</h3><ul>
<li><strong>FrameLayout</strong>：帧布局，所有元素都被放入左上区域，且无法指定确切位置，下一个元素覆盖上一个元素。</li>
<li><strong>LinearLayout</strong>：线性布局，每个子元素都以垂直或水平的方式来线性排布。</li>
<li><strong>AbsoluteLayout</strong>：绝对布局，采用坐标位置的方式排列元素。</li>
<li><strong>RelativeLayout</strong>：相对布局，以某元素为参照物，来定位下一个元素位置。</li>
<li><strong>TableLayout</strong>：表格布局，以表格的形式排列子元素。</li>
<li><strong>线性与相对加载效率</strong>：<ol>
<li>RelativeLayout会对子View进行两次measure(一横一纵)，LinearLayout只对子View进行一次measure(横或纵)，若设置weight属性也会进行两次（带与不带weight属性的View各一次），一般情况LinearLayout性能高于RelativeLayout。</li>
<li>视图层级简单时，用LinearLayout效率更高，避免使用weight属性。</li>
<li>视图层级复杂时，用RelativeLayout可减少层级嵌套，提高效率。</li>
</ol>
</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h3><ul>
<li><strong>打开A，切到B</strong>：A:onCreate()—&gt;A:onStart()—&gt;A:onResume()—&gt;A:onPause()—&gt;B:onCreate()—&gt;B:onStart()—&gt; B:onResume()—&gt;A:onStop()</li>
<li><strong>Back返回A</strong>：B:onPause()—&gt;A:onRestart()—&gt;A:onStart()—&gt;A:onResume()—&gt;B:onStop()—&gt;B:onDestroy()</li>
</ul>
<h3 id="Fragment生命周期"><a href="#Fragment生命周期" class="headerlink" title="Fragment生命周期"></a>Fragment生命周期</h3><ul>
<li><strong>打开A</strong>：onAttach()—&gt;onCreate()—&gt;onCreateView()—&gt;onViewCreated()—&gt;onActivityCreated()—&gt;onStart()—&gt;onResume()—&gt;onPause()—&gt;onStop()—&gt;onDestroyView()—&gt;onDestroy()—&gt;onDetach()</li>
<li><strong>切到B</strong>：A:onPause()—&gt;B:onAttach()—&gt;……—&gt;B:onResume()—&gt;A:onStop()</li>
<li><strong>Back返回A</strong>：B:onPause()—&gt;A:onStart()—&gt;A:onResume()—&gt;B:onStop()—&gt;B:onDestroyView()—&gt;B:onDestroy()—&gt;B:onDetach()</li>
</ul>
<h3 id="Service生命周期"><a href="#Service生命周期" class="headerlink" title="Service生命周期"></a>Service生命周期</h3><ul>
<li><strong>Started Service</strong>：startService()—&gt;onCreate()—&gt;onStartCommand()—&gt;onDestroy()</li>
<li><strong>Bound Service</strong>：bindService()—&gt;onCreate()—&gt;onBind()—&gt;onUnbind()—&gt;onDestroy()</li>
<li><strong>注意</strong>：若Service已经启动，则只执行onStart()。<strong>Bound Service</strong>的生命周期与其绑定的组件同生死，<strong>Started Service</strong>不受限制。</li>
</ul>
<h3 id="横竖屏切换生命周期"><a href="#横竖屏切换生命周期" class="headerlink" title="横竖屏切换生命周期"></a>横竖屏切换生命周期</h3><ul>
<li><strong>configChanges设置为<code>orientation</code>或者<code>orientation|keyboardHidden</code></strong>：onCreate()—&gt;onStart()—&gt;onResume()—&gt;onPause()—&gt;onStop()—&gt;onDestroy()—&gt;onCreate()—&gt;onStart()—&gt;onResume()</li>
<li><strong>configChanges设置为<code>orientation|screenSize</code>或者<code>orientation|screenSize|keyboardHidden</code></strong>：onCreate()—&gt;onStart()—&gt;onResume()—&gt;onConfigurationChanged()</li>
<li><strong>注意</strong>：targetSdkVersion<12的话，设置为orientation|keyboardhidden，也不重新创建activity，只调用onconfigurationchanged()。而targetsdkversion>=12的话，activity还是会重新创建(需要加上screenSize才有效果)。</12的话，设置为orientation|keyboardhidden，也不重新创建activity，只调用onconfigurationchanged()。而targetsdkversion></li>
</ul>
<h2 id="异步多线程"><a href="#异步多线程" class="headerlink" title="异步多线程"></a>异步多线程</h2><h3 id="AsyncTask执行方法"><a href="#AsyncTask执行方法" class="headerlink" title="AsyncTask执行方法"></a>AsyncTask执行方法</h3><ul>
<li><strong>onPreExecute()</strong>：初始化操作。</li>
<li><strong>doInBackground()</strong>：后台耗时操作。</li>
<li><strong>onProgressUpdate()</strong>：doInBackground()中调用publishProgress(Progress…)，可进行进度条进度更新</li>
<li><strong>onPostExecute()</strong>：耗时操作完成，可刷新UI。</li>
<li>完全可使用RxJava异步数据流代替</li>
</ul>
<h3 id="异步消息处理Handler、Looper、Message关系"><a href="#异步消息处理Handler、Looper、Message关系" class="headerlink" title="异步消息处理Handler、Looper、Message关系"></a>异步消息处理Handler、Looper、Message关系</h3><p>　　Looper负责创建一个MessageQueue，然后无限循环从中读取由Handler创建发送的一个或多个Message。消息队列为空，线程则会阻塞等待。  </p>
<ul>
<li><strong>Looper</strong>：构造中创建一个MessageQueue并绑定当前线程，方法主要为prepare()与loop()，prepare将Looper对象放入ThreadLocal初始化，在loop方法中循环从MessageQueue中读取消息，没有则线程阻塞等待。读到消息后调用消息来源Handler中的dispathMessage()方法，其内部最终调用handleMessage()方法。</li>
<li><strong>Handler</strong>：内部通过Looper.myLooper()获取了当前线程保存的Looper实例并与其MessageQueue进行关联，向其MessageQueue发送Message。</li>
<li><strong>Message</strong>：存储消息内容。</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h3><ul>
<li><strong>内存溢出</strong>：所需内存超过系统所能提供内存的上限。</li>
<li><strong>案例</strong><ol>
<li>大量使用Bitmap未recycle()回收。</li>
<li>循环中大量创建对象。</li>
</ol>
</li>
<li><strong>内存泄露</strong>：分配出去的内存无法回收。</li>
<li><strong>案例</strong><ol>
<li>静态变量（静态Context持有Activity本身引用，导致其无法被回收）</li>
<li>非静态内部类和匿名内部类（Handler问题，Handler持有Activity的引用导致其无法被回收，可使用静态内部类加WeakReference弱引用实现）</li>
<li>既是静态变量又是非静态内部对象（非静态内部对象持有Activity的引用，而其静态变量导致Activity无法被回收）</li>
<li>单例模式没有解绑（使用EventBus生成单例并注册一个Activity，页面结束时没有解除注册，会导致Activity无法被回收）</li>
<li>属性动画造成内存泄漏（无限循环的属性动画没有将其停止，View动画则不会）</li>
<li>RxJava 使用不当（没有及时取消订阅）</li>
</ol>
</li>
</ul>
<h3 id="ANR异常Application-Not-Responding"><a href="#ANR异常Application-Not-Responding" class="headerlink" title="ANR异常Application Not Responding"></a>ANR异常Application Not Responding</h3><ul>
<li>5秒内无法响应用户输入时间（键盘输入，触摸屏幕等）</li>
<li>BroadcastReceiver10s内无法结束</li>
<li><strong>解决方案</strong>：避免在UI主线程进行耗时操作（文件读写、数据库、网络请求），交给子线程去完成。</li>
</ul>
<h3 id="Runtime-Exception"><a href="#Runtime-Exception" class="headerlink" title="Runtime Exception"></a>Runtime Exception</h3><ul>
<li><strong>运行时异常</strong>：NullPointerException，ClassCastException，IllegalArgumentException，ArithmeticException，ArrayStoreException，IndexOutOfBoundsException，NegativeArraySizeException，NumberFormatException，NoSuchElementException，SecurityException，UnsupportedOperationException，BufferUnderflowException，BufferOverflowException，MissingResourceException</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="MVC，MVP，MVVVM"><a href="#MVC，MVP，MVVVM" class="headerlink" title="MVC，MVP，MVVVM"></a>MVC，MVP，MVVVM</h3><ul>
<li><strong>MVC</strong>：通过Controller的控制去操作Model层的数据并交给View层展示。xml布局文件相当于View层，JavaBean类相当于Model层，Activity相当于Controller层。Activity会比较臃肿。</li>
<li><strong>MVP</strong>：MVC升级版，Activity与Fragment只作为View层，Model层处理数据，而数据与View的交互都交给Presenter层，实现View与Model的解耦。给Activity减压，后期维护与测试更为便利。逻辑复杂的界面会导致接口过多。</li>
<li><strong>MVVM</strong>：与MVP区别不大，Presenter层替换为ViewModel层，View层与ViewModel层是绑定关系，当更新ViewModel层数据时，View层ui会自动更新。绑定可使用DataBinding实现。View层还是会过重。publishProgress(Progress…)，可进行进度条进度更新</li>
<li><strong>MVP+DataBinding</strong>：使用DataBinding节省数据绑定的时间，又使用Presenter将业务逻辑和view层分离。</li>
</ul>
<h2 id="屏幕适配"><a href="#屏幕适配" class="headerlink" title="屏幕适配"></a>屏幕适配</h2><h3 id="屏幕适配-1"><a href="#屏幕适配-1" class="headerlink" title="屏幕适配"></a>屏幕适配</h3><ul>
<li>种像素密度机型，做5套图。比例 1：1.5：2：3：4</li>
<li>多用相对布局</li>
<li>尺寸限定符</li>
<li>点九图</li>
<li>不同图片填充类型ScaleType</li>
</ul>
<h2 id="事件分发与消费"><a href="#事件分发与消费" class="headerlink" title="事件分发与消费"></a>事件分发与消费</h2><h3 id="事件分发消费机制"><a href="#事件分发消费机制" class="headerlink" title="事件分发消费机制"></a>事件分发消费机制</h3><ul>
<li>Activity-&gt;View  </li>
<li>dispatchTouchEvent：用来分发TouchEvent。</li>
<li>onInterceptTouchEvent：用来拦截TouchEvent，ViewGroup特有。</li>
<li>onTouchEvent：用来处理TouchEvent。</li>
</ul>
<h3 id="Touch事件的传递流程"><a href="#Touch事件的传递流程" class="headerlink" title="Touch事件的传递流程"></a>Touch事件的传递流程</h3><ul>
<li>一次完整的Touch事件由一个Down、一个Up和若干个Move组成。Down事件通过dispatchTouchEvent进行分发，目的是为了找到真正需要处理Touch请求的View。当某View或ViewGroup的onTouchEvent事件返回true时，便表示它是真正要处理这次请求的View，之后的Aciton_UP和Action_MOVE将由它处理。当所有子View的onTouchEvent都返回false时，这次的Touch请求就由根ViewGroup，即Activity自己处理了。</li>
<li><strong>无拦截</strong><br>　　E/Activity:　　　dispatchTouchEvent<br>　　E/ViewGroup:　　dispatchTouchEvent<br>　　E/ViewGroup:　　onInterceptTouchEvent<br>　　E/View:　　　　　dispatchTouchEvent<br>　　E/View:　　　　　onTouchEvent：返回false不处理<br>　　E/ViewGroup:　　onTouchEvent<br>　　E/Activity:　　　onTouchEvent：ACTION_DOWN<br>　　E/Activity:　　　dispatchTouchEvent<br>　　E/Activity:　　　onTouchEvent：ACTION_UP<br>　　分发过程无拦截，事件一直向下分发至View，View在onTouchEvent中返回false表示不处理，则向上传递至Activity处理。由于ACTION_DOWN事件确定了事件交给Activity处理，所以ACTION_UP事件直接分发给Activity处理，不再下传了。</li>
<li><strong>Intercept拦截</strong><br>　　E/Activity:　　　dispatchTouchEvent<br>　　E/ViewGroup:　　　dispatchTouchEvent<br>　　E/ViewGroup:　　onInterceptTouchEvent<br>　　E/View:　　　　dispatchTouchEvent<br>　　E/View:　　　　onTouchEvent<br>　　E/ViewGroup:　　onTouchEvent：ACTION_DOWN：返回true消费<br>　　E/Activity:　　　dispatchTouchEvent<br>　　E/ViewGroup:　　dispatchTouchEvent<br>　　E/ViewGroup:　　onTouchEvent：ACTION_MOVE：返回true消费<br>　　E/Activity:　　　　dispatchTouchEvent<br>　　E/ViewGroup:　　dispatchTouchEvent<br>　　E/ViewGroup:　　onTouchEvent：ACTION_UP：返回true消费<br>　　事件在回传过程中被ViewGroup在onTouchEvent中返回true消费了，则不继续向上回传。Up与Move事件原理同上，直接分发到ViewGroup中进行处理。</li>
<li><strong>Dispatch拦截</strong><br>　　E/Activity:　　　dispatchTouchEvent<br>　　E/ViewGroup:　　dispatchTouchEvent：返回true拦截<br>　　E/Activity:　　　dispatchTouchEvent<br>　　E/ViewGroup:　　dispatchTouchEvent：返回true拦截<br>　　事件在分发过程中被ViewGroup在dispatchTouchEvent中返回true拦截了，则不继续向下分发，Down事件就此结束，也没有定位到事件的View，所以Move与Up事件还需重新进行分发过程。</li>
</ul>
<h2 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h2><h3 id="自定义View生命周期"><a href="#自定义View生命周期" class="headerlink" title="自定义View生命周期"></a>自定义View生命周期</h3><ul>
<li><strong>onFinishInflate()</strong>：初始准备完毕。</li>
<li><strong>onAttachedToWindow()</strong>：将View绑定到Activity所在Window上。</li>
<li><strong>onMeasure()</strong>：计算当前View的宽高大小。</li>
<li><strong>onLayout()</strong>：计算当前View的位置。</li>
<li><strong>onDraw()</strong>：绘制View。</li>
<li><strong>onWindowFocusChanged()</strong>：View焦点变化。</li>
<li><strong>onDetachedFromWindow()</strong>：Activity销毁后，View会从Window上。剥离</li>
</ul>
<h2 id="三方框架"><a href="#三方框架" class="headerlink" title="三方框架"></a>三方框架</h2><h3 id="ButterKnife原理"><a href="#ButterKnife原理" class="headerlink" title="ButterKnife原理"></a>ButterKnife原理</h3><p>　　根据注解生成一个Java类，里面动态的去做一些FindViewById的事。
　　</p>
<h3 id="Dragger2好处"><a href="#Dragger2好处" class="headerlink" title="Dragger2好处"></a>Dragger2好处</h3><ul>
<li>避免重复去new，及单例之类的工作，增加开发效率。</li>
<li>更好的管理类实例。</li>
<li>解耦。</li>
</ul>
<h3 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h3><ul>
<li>Retrofit使用注解+java接口来定义后台服务API接口。</li>
<li>使用Retrofit.create函数创建接口动态代理的示例。</li>
<li>可将http请求解耦，配合RxJava会更加的灵活。</li>
</ul>
<h3 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h3><ul>
<li>Request：每一个HTTP请求包含一个URL、一个方法（GET或POST或其他）、一些HTTP头。请求还可能包含一个特定内容类型的数据类的主体部分。</li>
<li>Response：响应是对请求的回复，包含状态码、HTTP头和主体部分。</li>
<li>Call：OkHttp使用Call抽象出一个满足请求的模型，尽管中间可能会有多个请求或响应。执行Call有两种方式，同步或异步。</li>
</ul>
<h3 id="Volley"><a href="#Volley" class="headerlink" title="Volley"></a>Volley</h3><h3 id="xUtils：快速开发框架"><a href="#xUtils：快速开发框架" class="headerlink" title="xUtils：快速开发框架"></a>xUtils：快速开发框架</h3><ul>
<li>DbUtils</li>
<li>ViewUtils</li>
<li>HttpUtils</li>
<li>BitmapUtils</li>
</ul>
<h3 id="Mqtt即时通讯协议"><a href="#Mqtt即时通讯协议" class="headerlink" title="Mqtt即时通讯协议"></a>Mqtt即时通讯协议</h3><ul>
<li>使用发布/消息订阅模式。</li>
<li>TCP/IP提供网络连接。</li>
<li>提供一对多的消息发布，解除应用程序耦合。</li>
<li>小型传输，开销很小。</li>
</ul>
<h3 id="Jpush极光推送"><a href="#Jpush极光推送" class="headerlink" title="Jpush极光推送"></a>Jpush极光推送</h3><h3 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h3><ul>
<li>响应式编程</li>
<li>采用升级版观察者模式的异步事件流</li>
<li>空调（观察者）、遥控器（被观察者）、红外信号（操作符）的例子</li>
</ul>
<h3 id="GreenDao"><a href="#GreenDao" class="headerlink" title="GreenDao"></a>GreenDao</h3><h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h3><ul>
<li>Realm 是一个 MVCC （多版本并发控制）数据库，本质上是一个嵌入式数据库，它不是基于SQLite所构建的，它拥有自己的数据库存储引擎，可以高效且快速地完成数据库的构建操作。和SQLite不同，它可在持久层直接和数据对象工作。在它之上是一个函数式风格的查询api，比传统的SQLite 操作更快 。</li>
<li>易用<ul>
<li>Ream不是在SQLite基础上的ORM，它有自己的数据查询引擎。并且十分容易使用。</li>
</ul>
</li>
<li>快速<ul>
<li>由于它是完全重新开始开发的数据库实现，所以它比任何的ORM速度都快很多，甚至比SQLite速度都要快。</li>
</ul>
</li>
<li>跨平台<ul>
<li>Realm 支持 iOS &amp; OS X (Objective‑C &amp; Swift) &amp; Android。我们可以在这些平台上共享Realm数据库文件，并且上层逻辑可以不用任何改动的情况下实现移植。</li>
</ul>
</li>
<li>高级<ul>
<li>Ream支持加密，格式化查询，易于移植，支持JSON，流式api，数据变更通知等高级特性</li>
</ul>
</li>
<li>可视化<ul>
<li>Realm 还提供了一个轻量级的数据库查看工具，在Mac Appstore 可以下载“Realm Browser”这个工具，开发者可以查看数据库当中的内容，执行简单的插入和删除数据的操作。（windows上还不清楚）</li>
</ul>
</li>
</ul>
<h2 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h2><h3 id="资源及状态的操作保存，最好保存在生命周期的哪个函数里？"><a href="#资源及状态的操作保存，最好保存在生命周期的哪个函数里？" class="headerlink" title="资源及状态的操作保存，最好保存在生命周期的哪个函数里？"></a>资源及状态的操作保存，最好保存在生命周期的哪个函数里？</h3><p>　　保存在onPause()中</p>
<h3 id="哪些情况内存会被垃圾回收机制处理掉？"><a href="#哪些情况内存会被垃圾回收机制处理掉？" class="headerlink" title="哪些情况内存会被垃圾回收机制处理掉？"></a>哪些情况内存会被垃圾回收机制处理掉？</h3><ul>
<li>对象引用超过其作用范围。</li>
<li>将对象赋值为null。</li>
<li>实体不再被任何对象所引用。</li>
</ul>
<h3 id="数据库升级方法及注意事项"><a href="#数据库升级方法及注意事项" class="headerlink" title="数据库升级方法及注意事项"></a>数据库升级方法及注意事项</h3><p>　　应用版本更新前若数据库结构有改变，则需更改数据库版本号。新版本运行后需在onUpgrade()中根据数据库版本号判断是否要升级数据库，若版本号大于旧版本号则需要升级，一为了保证旧数据的不丢失，二是为了进行数据库结构的更新。  </p>
<ul>
<li>表结构有更改<ol>
<li>首先将旧数据库的表A重名为A_temp。</li>
<li>创建满足新版本数据库结构的新表A（增加与修改的字段）。</li>
<li>将表A_temp中数据插入到表A中。</li>
</ol>
</li>
<li>加入新表<ol>
<li>只需在新版本运行后插入新的表，并给相应字段附上默认值即可。</li>
</ol>
</li>
<li><strong>注意</strong>：跨版本升级需要先确定相邻版本的差别，从版本1开始依次迭代更新，先执行v1到v2，再v2到v3等等。或根据版本差别，编写对应的升级代码。</li>
</ul>
<h3 id="ScrollView嵌套ListView问题"><a href="#ScrollView嵌套ListView问题" class="headerlink" title="ScrollView嵌套ListView问题"></a>ScrollView嵌套ListView问题</h3><p>　　原因：ScrollView拦截了ListView的Move事件。 </p>
<ul>
<li>动态计算ListView高度。</li>
<li>自定义ScrollView重写onInterceptTouchEvent返回false，不拦截ListView的Move事件。</li>
<li>在listView的dispatchTouchEvent方法中调用requestDisallowInterceptTouchEvent(true)申请不被拦截触摸事件。</li>
</ul>
<h3 id="RecyclerView有几种Manager，如何实现瀑布流"><a href="#RecyclerView有几种Manager，如何实现瀑布流" class="headerlink" title="RecyclerView有几种Manager，如何实现瀑布流"></a>RecyclerView有几种Manager，如何实现瀑布流</h3><ul>
<li>LinearLayoutManager： 线性布局管理器，呈现线性布局的RecyclerView，实现ListView效果。</li>
<li>GridLayoutManager：网格布局管理器，呈现网格布局的RecyclerView，实现GridView效果。</li>
<li>StaggeredGridLayoutManager：交错网格布局管理器，呈现交错网格布局的RecyclerView，它是一种特殊的GridLayoutManager，区别在于，它允许每个Item的长度或高度不一致，实现瀑布流效果。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　目前Android面试技术点总结的还不太全，我会持续更新，也欢迎码友们指出文中写的不对的地方，或者有遗漏的知识点也可以联系我，咱们一起来维护，方便你我他。最后祝各位求职顺利，入职满意的公司。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;　　年末一周不忙了，总结了下在Android开发面试中易问的一些Android相关基础知识与面试题，不太全，大家查缺补漏吧。开始Review！&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="Android Review" scheme="http://LeiHolmes.github.io/tags/Android-Review/"/>
    
  </entry>
  
  <entry>
    <title>Java面试技术点总结</title>
    <link href="http://LeiHolmes.github.io/2017/12/25/Java%E9%9D%A2%E8%AF%95%E6%8A%80%E6%9C%AF%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://LeiHolmes.github.io/2017/12/25/Java面试技术点总结/</id>
    <published>2017-12-24T16:00:00.000Z</published>
    <updated>2018-06-04T06:46:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　前段时间换工作准备期间，总结了下在Android面试中易问的一些Java基础知识与面试题，不太全，大家查缺补漏吧。开始Review！<br>　　<a id="more"></a></p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="Java面向对象编程思想"><a href="#Java面向对象编程思想" class="headerlink" title="Java面向对象编程思想"></a>Java面向对象编程思想</h3><p>　　将属性与功能封装起来，通过归类与抽象将相同或相似的部分抽出，不同的部分分离，将复杂业务逻辑切分成相互独立的部分，降低开发的难度。<br>　　面向对象是解决了系统的可维护性，可扩展性和可重用性主要通过以下四大特性来实现：</p>
<ul>
<li><strong>抽象</strong>：<strong>核心思想</strong>！把相同的或相似的对象归为一类的这个过程就是抽象。抽象只关心对象中的主要问题，主要矛盾及相同的部分。它只在乎问题是什么，能够完成什么，而不在乎怎么去完成，交给他的实现类去解决。</li>
<li><strong>封装</strong>：将某些属性包装在一起，再以全新的形式呈现出来。其中隐藏属性，方法或实现的细节称之为封装。</li>
<li><strong>继承</strong>：重用现有的父类来生成新子类的一种特征，子类可通过继承父类来获取父类的属性与方法。</li>
<li><strong>多态</strong>：同一函数在不同的类中有不同的实现，使类变得更灵活，更便于扩充。父类引用指向子类对象。</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例模式5种："><a href="#单例模式5种：" class="headerlink" title="单例模式5种："></a>单例模式5种：</h3><ul>
<li>懒汉式</li>
<li>饿汉式</li>
<li>同步线程锁懒汉式</li>
<li>双重线程锁懒汉式</li>
<li>最优单例</li>
</ul>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>　　由一个工厂类，根据传入参数的不同，动态创建不同的产品，这些产品都继承自一个父类或接口的实例。得益于Java的多态特性。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="List集合：有序，可重复"><a href="#List集合：有序，可重复" class="headerlink" title="List集合：有序，可重复"></a>List集合：有序，可重复</h3><ul>
<li><strong>ArrayList</strong>：底层是动态数组顺序表数据结构，存储地址是连续的，所以查询速度快。但增删时需要移动其他元素的顺序，所以增删速度慢，线程不同步。</li>
<li><strong>LinkedList</strong>：底层是双向链表数据结构，同时也实现了Deque双端队列接口，链表节点存储地址不连续。每个存储地址之间通过指正关联，查询时需要指针遍历所有节点，所以查询速度慢。而增删只需断开某元素前后的链接进行增加与删除即可，所以增删速度快，线程不同步。</li>
<li><strong>Vector</strong>：类似ArrayList，线程同步，效率低。</li>
</ul>
<h3 id="Set集合：无序，不可重复"><a href="#Set集合：无序，不可重复" class="headerlink" title="Set集合：无序，不可重复"></a>Set集合：无序，不可重复</h3><ul>
<li><strong>HashSet</strong>：底层数组，哈希表数据结构，线程不同步。</li>
<li><strong>TreeSet</strong>：二叉树数据结构，可实现Comparable或Comparator接口来排序，线程不同步。</li>
</ul>
<h3 id="Map集合：键值对，键不可重复，值可以重复"><a href="#Map集合：键值对，键不可重复，值可以重复" class="headerlink" title="Map集合：键值对，键不可重复，值可以重复"></a>Map集合：键值对，键不可重复，值可以重复</h3><ul>
<li><strong>HashMap</strong>：哈希表数据结构，可存入null键，null值，线程不同步。</li>
<li><strong>HashTable</strong>：哈希表数据结构，不可存入null键，null值，线程同步。</li>
<li><strong>TreeMap</strong>：二叉树数据结构，可进行排序，线程不同步</li>
</ul>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="TCP-IP层级"><a href="#TCP-IP层级" class="headerlink" title="TCP/IP层级"></a>TCP/IP层级</h3><ul>
<li><strong>应用层</strong>：向用户提供一些常用应用程序，例如电子邮件，文件传输访问等。包含常用协议HTTP（超文本传输协议：实现互联网中WWW服务）、DNS（域名解析：域名到IP地址间的转换）</li>
<li><strong>传输层</strong>：提供应用程序之前的传输通道。主要传输协议为TCP（面向连接传输控制协议，三次握手，安全可靠性高，适用于传输大量数据，但速度慢）与UDP（面向无连接用户数据报协议，无需握手同步，安全可靠性低，适用于传输小量数据，但速度快，例如QQ）。</li>
<li><strong>网络层</strong>：核心层，根据IP协议将分组装入IP数据报并发往目标网络或主机。主要传输协议为IP协议（用于源地址与目的地址间的传送数据报）与ICMP协议（传送IP控制信息）</li>
<li><strong>网络接口层</strong>：最底层，接收IP数据报，并通过网络发送</li>
</ul>
<h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><h3 id="静态变量，静态代码块，本地变量执行顺序"><a href="#静态变量，静态代码块，本地变量执行顺序" class="headerlink" title="静态变量，静态代码块，本地变量执行顺序"></a>静态变量，静态代码块，本地变量执行顺序</h3><p>　　父类代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FatherTest</span> </span>&#123;</div><div class="line">        <span class="keyword">static</span> &#123;</div><div class="line">            System.out.println(<span class="string">"--父类的静态代码块--"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">        &#123;</div><div class="line">            System.out.println(<span class="string">"--父类的非静态代码块--"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FatherTest</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"--父类的无参构造函数--"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FatherTest</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            System.out.println(<span class="string">"--父类的有参构造函数--"</span> + <span class="keyword">this</span>.name);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"--父类的show()方法--"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"--父类的主程序--"</span>);</div><div class="line">            FatherTest fatherTest = <span class="keyword">new</span> FatherTest(<span class="string">"父亲的名字"</span>);</div><div class="line">            fatherTest.show();</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　父类输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">--父类的静态代码块--</div><div class="line">--父类的主程序--</div><div class="line">--父类的非静态代码块--</div><div class="line">--父类的有参构造函数--父亲的名字</div><div class="line">--父类的show()方法--</div></pre></td></tr></table></figure></p>
<h3 id="带继承关系的执行顺序"><a href="#带继承关系的执行顺序" class="headerlink" title="带继承关系的执行顺序**"></a>带继承关系的执行顺序**</h3><p>　　子类代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SonTest</span> <span class="keyword">extends</span> <span class="title">FatherTest</span> </span>&#123;</div><div class="line">        <span class="keyword">static</span> &#123;</div><div class="line">            System.out.println(<span class="string">"--子类的静态代码块--"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">        &#123;</div><div class="line">            System.out.println(<span class="string">"--子类的非静态代码块--"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SonTest</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">//默认super()调父类无参构造</span></div><div class="line">            System.out.println(<span class="string">"--子类的无参构造函数--"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SonTest</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">            <span class="comment">//默认super()调父类无参构造</span></div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            System.out.println(<span class="string">"--子类的有参构造函数--"</span> + <span class="keyword">this</span>.name);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">//此处若不调用super.show()则只走子类重写的show()方法</span></div><div class="line">            System.out.println(<span class="string">"--子类Override父类的show()方法--"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"--子类的主程序--"</span>);</div><div class="line">            SonTest sonTest = <span class="keyword">new</span> SonTest(<span class="string">"儿子的名字"</span>);</div><div class="line">            sonTest.show();</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　子类输出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">--父类的静态代码块--</div><div class="line">--子类的静态代码块--</div><div class="line">--子类的主程序--</div><div class="line">--父类的非静态代码块--</div><div class="line">--父类的无参构造函数--</div><div class="line">--子类的非静态代码块--</div><div class="line">--子类的有参构造函数--儿子的名字</div><div class="line">--子类Override父类的show()方法--</div></pre></td></tr></table></figure></p>
<h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><h3 id="Math的一些计算"><a href="#Math的一些计算" class="headerlink" title="Math的一些计算"></a>Math的一些计算</h3><ul>
<li><strong>Math.round()</strong>：四舍五入，+0.5后向下取整（Math.round(11.5)=12，Math.round(-11.5)=-11），float返回int，double返回long</li>
<li><strong>Math.rint()</strong>：四舍五入，遇0.5则取偶数（Math.rint(11.4)=11.0，Math.rint(11.5)=12，Math.rint(10.5)=10）</li>
<li><strong>Math.floor()</strong>：不大于它的最大整数（Math.floor(11.5)=11，Math.floor(-11.5)=-12）</li>
<li><strong>Math.ceil()</strong>：不小于他的最小整数（Math.ceil(11.5)=12，Math.ceil(-11.5)=-11）</li>
<li><strong>Math.abs()</strong>：绝对值（Math.abs(11.5)=11.5，Math.abs(-11.5)=11.5）</li>
<li><strong>Math.max()</strong>：最大值（Math.max(-11.5, -11.4)=-11.4）</li>
<li><strong>Math.min()</strong>：最小值（Math.min(-11.5, -11.4)=-11.5）</li>
<li><strong>Math.random()</strong>：0.0-1.0之间的随机数</li>
<li><strong>Math.pow(x, y)</strong>：x的y次幂</li>
<li><strong>Math.sqrt()</strong>：开方</li>
</ul>
<h3 id="常量池计算"><a href="#常量池计算" class="headerlink" title="常量池计算"></a>常量池计算</h3><p>　　Java的8种基本类型(Byte, Short, Integer, Long, Character, Boolean, Float, Double), 除Float和Double以外, 其它六种都实现了常量池, 但是它们只在大于等于-128并且小于等于127时才使用常量池.<br>　　来看代码演示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">    Integer a = <span class="number">127</span>;  </div><div class="line">    Integer b = <span class="number">127</span>;  </div><div class="line">    System.out.println(<span class="string">"等于127:"</span>);  </div><div class="line">    System.out.println(a == b);  </div><div class="line">    System.out.println(<span class="string">"*****************"</span>);  </div><div class="line">  </div><div class="line">    a = <span class="number">128</span>;  </div><div class="line">    b = <span class="number">128</span>;  </div><div class="line">    System.out.println(<span class="string">"等于128:"</span>);  </div><div class="line">    System.out.println(a == b);  </div><div class="line">    System.out.println(<span class="string">"*****************"</span>);  </div><div class="line">  </div><div class="line">    a = -<span class="number">128</span>;  </div><div class="line">    b = -<span class="number">128</span>;  </div><div class="line">    System.out.println(<span class="string">"等于-128:"</span>);  </div><div class="line">    System.out.println(a == b);  </div><div class="line">    System.out.println(<span class="string">"*****************"</span>);  </div><div class="line">  </div><div class="line">    a = -<span class="number">129</span>;  </div><div class="line">    b = -<span class="number">129</span>;  </div><div class="line">    System.out.println(<span class="string">"等于-129:"</span>);  </div><div class="line">    System.out.println(a == b);  </div><div class="line">    System.out.println(<span class="string">"*****************"</span>);  </div><div class="line">  </div><div class="line">    <span class="comment">// 测试Boolean  </span></div><div class="line">    System.out.println(<span class="string">"测试Boolean"</span>);  </div><div class="line">    Boolean c = <span class="keyword">true</span>;  </div><div class="line">    Boolean d = <span class="keyword">true</span>;  </div><div class="line">    System.out.println(c == d);  </div><div class="line">    d = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);  </div><div class="line">    System.out.println(c == d);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">等于<span class="number">127</span>:</div><div class="line"><span class="keyword">true</span></div><div class="line">*****************</div><div class="line">等于<span class="number">128</span>:</div><div class="line"><span class="keyword">false</span></div><div class="line">*****************</div><div class="line">等于-<span class="number">128</span>:</div><div class="line"><span class="keyword">true</span></div><div class="line">*****************</div><div class="line">等于-<span class="number">129</span>:</div><div class="line"><span class="keyword">false</span></div><div class="line">*****************</div><div class="line">测试Boolean</div><div class="line"><span class="keyword">true</span></div><div class="line"><span class="keyword">false</span></div></pre></td></tr></table></figure></p>
<p>　　结论：当我们给Integer赋值时，实际上调用了Integer.valueOf(int)方法，查看源码，其实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span>(i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= IntegerCache.high)  </div><div class="line">        <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">128</span>];  </div><div class="line">    <span class="keyword">else</span>  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　而IntegerCache实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;  </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;  </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];  </div><div class="line">  </div><div class="line">    <span class="keyword">static</span> &#123;  </div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;  </div><div class="line">  </div><div class="line">        <span class="comment">// high value may be configured by property  </span></div><div class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;  </div><div class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="comment">// Use Long.decode here to avoid invoking methods that  </span></div><div class="line">            <span class="comment">// require Integer's autoboxing cache to be initialized  </span></div><div class="line">            <span class="keyword">int</span> i = Long.decode(integerCacheHighPropValue).intValue();  </div><div class="line">            i = Math.max(i, <span class="number">127</span>);  </div><div class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE  </span></div><div class="line">            h = Math.min(i, Integer.MAX_VALUE - -low);  </div><div class="line">        &#125;  </div><div class="line">        high = h;  </div><div class="line">  </div><div class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];  </div><div class="line">        <span class="keyword">int</span> j = low;  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)  </div><div class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　<strong>注意：cache数组是静态的。</strong>
　　</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="LinkedList工作原理与实现"><a href="#LinkedList工作原理与实现" class="headerlink" title="LinkedList工作原理与实现"></a>LinkedList工作原理与实现</h3><p>　　LinkedList是以双向链表实现，链表无容量限制（但是双向链表本身需要消耗额外的链表指针空间来操作），其内部主要成员为 first 和 last 两个 Node 节点，在每次修改列表时用来指引当前双向链表的首尾部位，所以 LinkedList 不仅仅实现了 List 接口，还实现了 Deque 双端队列接口（该接口是 Queue 队列的子接口），故 LinkedList 自动具备双端队列的特性，当我们使用下标方式调用列表的 get(index)、set(index, e) 方法时需要遍历链表将指针移动到位进行访问（会判断 index 是否大于链表长度的一半决定是首部遍历还是尾部遍历，访问的复杂度为 O(N/2)），无法像 ArrayList 那样进行随机访问。(如果i&gt;数组大小的一半，会从末尾移起)，只有在链表两头的操作（譬如 add()、addFirst()、removeLast() 或用在 iterator() 上的 remove() 操作）才不需要进行遍历寻找定位。</p>
<h3 id="使用LinkedList模拟一个堆栈或队列的数据结构"><a href="#使用LinkedList模拟一个堆栈或队列的数据结构" class="headerlink" title="使用LinkedList模拟一个堆栈或队列的数据结构　"></a>使用LinkedList模拟一个堆栈或队列的数据结构　</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> LinkedList link;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">()</span> </span>&#123;</div><div class="line">        link = <span class="keyword">new</span> LinkedList();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        link.addLast(obj);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//堆栈先进后出，队列先进先出</span></div><div class="line">        <span class="keyword">return</span> link.removeFirst(); <span class="comment">//队列</span></div><div class="line">        <span class="comment">//return  link.removeLast(); //堆栈</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> link.isEmpty();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ConcurrentModificationException异常"><a href="#ConcurrentModificationException异常" class="headerlink" title="ConcurrentModificationException异常"></a>ConcurrentModificationException异常</h3><p>　　计算下面代码的输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    list.add(<span class="string">"di"</span>);</div><div class="line">    String str = <span class="keyword">new</span> String(<span class="string">"da"</span>);</div><div class="line">    list.add(str);</div><div class="line">    list.add(<span class="string">"paint"</span>);</div><div class="line">    <span class="keyword">for</span>(String temp : list)&#123;</div><div class="line">        <span class="keyword">if</span>(temp == <span class="string">"di"</span> || temp == <span class="string">"da"</span>)&#123;</div><div class="line">            list.remove(temp);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">System.out.print(list.toString());</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>解答</strong>：会抛出ConcurrentModificationException异常，List不可在进行遍历时添加或移除其中的元素。</li>
<li><strong>源码解析</strong>：ArrayList的父类AbstractList中有一个modCount成员变量来记录对List的修改次数，还有一个expectedModCount记录对ArrayList修改次数的期望值，modCount是它的初始值。遍历开始时modCount与expectedModCount都为0，而当我们在遍历中对List进行了add或remove操作后modCount会增加1，expectedModCount不变。而List在通过next()方法取下一次值时会先检查modCount与expectedModCount是否相等，不等则会抛出ConcurrentModificationException异常。</li>
<li><strong>单线程中解决方案</strong>：使用Iterator遍历集合，调用Iterator的remove方法移除元素，其内部有expectedModCount = modCount的操作。</li>
<li><strong>多线程中解决方案</strong>：多线程中使用上述方法也会抛出此异常，可在使用iterator迭代的时候使用synchronized或者Lock进行同步，或使用CopyOnWriteArrayList替换ArrayList。</li>
</ul>
<h3 id="通过代码输出365的二进制"><a href="#通过代码输出365的二进制" class="headerlink" title="通过代码输出365的二进制"></a>通过代码输出365的二进制</h3><ul>
<li>简单版</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">365</span>;<span class="comment">//定义一个变量并赋给他一个十进制的值</span></div><div class="line">    <span class="keyword">int</span> remainder;<span class="comment">//定义一个变量用于存储余数</span></div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//定义一个变量用于存放和</span></div><div class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;<span class="comment">//定义一个变量控制位数</span></div><div class="line">    <span class="keyword">while</span>(a != <span class="number">0</span>)&#123;</div><div class="line">        remainder = a % <span class="number">2</span>;<span class="comment">//对目标数字求余</span></div><div class="line">        a /= <span class="number">2</span>;<span class="comment">//对目标数字求商</span></div><div class="line">        sum = sum + remainder * k;<span class="comment">//求和</span></div><div class="line">        k *= <span class="number">10</span>;<span class="comment">//改变位数</span></div><div class="line">    &#125;</div><div class="line">    System.out.println(<span class="string">"10进制的365转换为2进制结果为："</span> + sum );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>负数版</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = -<span class="number">10</span>;</div><div class="line">    String result = <span class="string">""</span>;</div><div class="line">    <span class="keyword">boolean</span> minus = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">//如果该数字为负数，那么进行该负数+1之后的绝对值的二进制码的对应位取反，然后将它保存在result结果中</span></div><div class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</div><div class="line">        minus = <span class="keyword">true</span>;</div><div class="line">        n = Math.abs(n + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">        <span class="keyword">int</span> remainder = (!minus &amp;&amp; n % <span class="number">2</span> == <span class="number">0</span>) || (minus &amp;&amp; n % <span class="number">2</span> == <span class="number">1</span>) ? <span class="number">0</span> : <span class="number">1</span>;</div><div class="line">        <span class="comment">//将余数保存在结果中</span></div><div class="line">        result = remainder + result;</div><div class="line">        n /= <span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//判断是否为负数，如果是负数，那么前面所有位补1</span></div><div class="line">    <span class="keyword">if</span>(minus)&#123;</div><div class="line">        n = result.length();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">32</span> - n; i++)&#123;</div><div class="line">            result = <span class="number">1</span> + result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    System.out.println(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　目前Java面试技术点总结的还不太全，我会持续更新，也欢迎码友们指出文中写的不对的地方，或者有遗漏的知识点也可以联系我，咱们一起来维护，方便你我他。最后祝各位求职顺利，入职满意的公司。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;　　前段时间换工作准备期间，总结了下在Android面试中易问的一些Java基础知识与面试题，不太全，大家查缺补漏吧。开始Review！&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://LeiHolmes.github.io/categories/Java/"/>
    
    
      <category term="Java Review" scheme="http://LeiHolmes.github.io/tags/Java-Review/"/>
    
  </entry>
  
  <entry>
    <title>RxBinding系列之RxAdapterView(四)</title>
    <link href="http://LeiHolmes.github.io/2017/11/14/RxBinding%E7%B3%BB%E5%88%97%E4%B9%8BRxAdapterView(%E5%9B%9B)/"/>
    <id>http://LeiHolmes.github.io/2017/11/14/RxBinding系列之RxAdapterView(四)/</id>
    <published>2017-11-13T16:00:00.000Z</published>
    <updated>2017-11-20T01:53:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　本篇一起来学习RxBinding中的RxAdapterView，J大神将Android中AdapterView(ListView、GridView等)的一些事件及动作加以RxJava的观察者模式并封装了起来就形成了RxAdapterView，使用起来相当便捷。<br>　　<a id="more"></a><br>　　本篇以ListView为例子。</p>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>　　主布局中就需要一个ListView即可。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">tools:context</span>=<span class="string">"com.leiholmes.rxbindingdemo.ui.RxAdapterViewActivity"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">ListView</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/lv_list"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><h4 id="View注入"><a href="#View注入" class="headerlink" title="View注入"></a>View注入</h4><p>　　使用ButterKnife获取ListView实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@BindView</span>(R.id.lv_list)</div><div class="line">ListView lvList;</div></pre></td></tr></table></figure></p>
<h4 id="初始化假数据与适配器"><a href="#初始化假数据与适配器" class="headerlink" title="初始化假数据与适配器"></a>初始化假数据与适配器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//假数据</span></div><div class="line">list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">    list.add(<span class="string">"LeiHolmes:"</span> + i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//adapter适配器</span></div><div class="line">ArrayAdapter&lt;String&gt; adapter = <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(<span class="keyword">this</span>, android.R.layout.simple_list_item_1);</div><div class="line">adapter.addAll(list);</div><div class="line">lvList.setAdapter(adapter);</div></pre></td></tr></table></figure>
<h4 id="itemClicks条目点击事件"><a href="#itemClicks条目点击事件" class="headerlink" title="itemClicks条目点击事件"></a>itemClicks条目点击事件</h4><p>　　<code>RxAdapterView.itemClicks(AdapterView view)</code>，内部封装了OnItemClickListener条目点击监听。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">addDisposable(RxAdapterView.itemClicks(lvList)</div><div class="line">        .throttleFirst(<span class="number">2</span>, TimeUnit.SECONDS)</div><div class="line">        .subscribe(integer -&gt; Toast.makeText(RxAdapterViewActivity.<span class="keyword">this</span>,</div><div class="line">                <span class="string">"点击了第"</span> + integer + <span class="string">"条："</span> + list.get(integer), Toast.LENGTH_SHORT).show()));</div></pre></td></tr></table></figure></p>
<p>　　需要详细点击信息可使用<code>RxAdapterView.itemClickEvents(AdapterView view)</code>，它返回的类型是AdapterViewItemClickEvent，内部包含clickedView、position、id等信息。</p>
<h4 id="itemLongClicks条目长按事件"><a href="#itemLongClicks条目长按事件" class="headerlink" title="itemLongClicks条目长按事件"></a>itemLongClicks条目长按事件</h4><p>　　<code>RxAdapterView.itemLongClicks(AdapterView view)</code>，内部封装了OnItemLongClickListener条目长按监听。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">addDisposable(RxAdapterView.itemLongClicks(lvList)</div><div class="line">        .throttleFirst(<span class="number">2</span>, TimeUnit.SECONDS)</div><div class="line">        .subscribe(integer -&gt; Toast.makeText(RxAdapterViewActivity.<span class="keyword">this</span>,</div><div class="line">                <span class="string">"长按了第"</span> + integer + <span class="string">"条："</span> + list.get(integer), Toast.LENGTH_SHORT).show()));</div></pre></td></tr></table></figure></p>
<p>　　需要详细长按信息可使用<code>RxAdapterView.itemLongClickEvents(AdapterView view)</code>，它返回的类型是AdapterViewItemLongClickEvent，内部包含clickedView、position、id等信息。</p>
<h4 id="itemSelections条目选中事件"><a href="#itemSelections条目选中事件" class="headerlink" title="itemSelections条目选中事件"></a>itemSelections条目选中事件</h4><p>　　<code>RxAdapterView.itemSelections(AdapterView view)</code>，内部封装了OnItemSelectedListener条目选中监听。当ItemView中有选中效果View时起作用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">addDisposable(RxAdapterView.itemSelections(lvList)</div><div class="line">        .subscribe(integer -&gt; Log.e(<span class="string">"rx_binding_test"</span>, <span class="string">"itemSelections："</span> + integer)));</div></pre></td></tr></table></figure></p>
<p>　　需要详细选中信息可使用<code>RxAdapterView.selectionEvents(AdapterView view)</code>，它返回的类型是AdapterViewSelectionEvent。</p>
<h3 id="View操作"><a href="#View操作" class="headerlink" title="View操作"></a>View操作</h3><p>　　RxAdapterView中也封装了AdapterView中例如<code>setSelection()</code>等常用的操作，使用方式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">addDisposable(RxAdapterView.itemClicks(lvList)</div><div class="line">        .throttleFirst(<span class="number">2</span>, TimeUnit.SECONDS)</div><div class="line">        .subscribe(integer -&gt; RxAdapterView.selection(lvList).accept(<span class="number">0</span>)));</div></pre></td></tr></table></figure></p>
<h3 id="本文疑问"><a href="#本文疑问" class="headerlink" title="本文疑问"></a>本文疑问</h3><h4 id="addDisposable-方法什么鬼？"><a href="#addDisposable-方法什么鬼？" class="headerlink" title="addDisposable()方法什么鬼？"></a>addDisposable()方法什么鬼？</h4><p>飞机到本系列第一篇有讲解：<br><a href="http://xulei.tech/2017/11/09/RxBinding系列之RxView(一)" target="_blank" rel="external">RxBinding系列之RxView(一)</a></p>
<h4 id="Lambda表达式什么鬼？"><a href="#Lambda表达式什么鬼？" class="headerlink" title="Lambda表达式什么鬼？"></a>Lambda表达式什么鬼？</h4><p>飞机到我写的Lambda表达式教程：<br><a href="http://xulei.tech/2017/07/24/Lambda表达式基本语法与应用" target="_blank" rel="external">Lambda表达式基本语法与应用</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　到本篇为止，RxBingding中常用的View就介绍完毕了。RxBingding中还有很多内容未介绍，感兴趣的码友可去J大神的GitHub中系统的学习一下。<br>　　<a href="https://github.com/JakeWharton/RxBinding" target="_blank" rel="external">JakeWharton/RxBinding</a><br>　　进阶中的码猿一枚，写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxBindingDemo项目Issues中提出，我会及时回复。<br>　　附上Demo的地址：<br>　　<a href="https://github.com/LeiHolmes/RxBindingDemo" target="_blank" rel="external">RxBindingDemo</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;　　本篇一起来学习RxBinding中的RxAdapterView，J大神将Android中AdapterView(ListView、GridView等)的一些事件及动作加以RxJava的观察者模式并封装了起来就形成了RxAdapterView，使用起来相当便捷。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="RxBinding" scheme="http://LeiHolmes.github.io/tags/RxBinding/"/>
    
  </entry>
  
  <entry>
    <title>RxBinding系列之RxCompoundButton(三)</title>
    <link href="http://LeiHolmes.github.io/2017/11/13/RxBinding%E7%B3%BB%E5%88%97%E4%B9%8BRxCompoundButton(%E4%B8%89)/"/>
    <id>http://LeiHolmes.github.io/2017/11/13/RxBinding系列之RxCompoundButton(三)/</id>
    <published>2017-11-12T16:00:00.000Z</published>
    <updated>2017-11-26T11:25:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　本篇将通过一个实际场景来学习RxBinding中的RxCompoundButton，J大神将Android中CompoundButton的一些事件及动作加以RxJava的观察者模式并封装了起来就形成了RxCompoundButton，使用起来也很简单。<br>　　<a id="more"></a><br>　　场景：注册时需用户点击同意用户协议选中框才可点击注册按钮。</p>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>　　布局中更需要一个注册Button和一个用户协议选中框CheckBox。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></div><div class="line">    <span class="attr">android:padding</span>=<span class="string">"15dp"</span></div><div class="line">    <span class="attr">tools:context</span>=<span class="string">"com.leiholmes.rxbindingdemo.ui.RxCompoundButtonActivity"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/btn_login"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:background</span>=<span class="string">"@color/colorGray"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"注册"</span> /&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">CheckBox</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/cb_contract"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_marginTop</span>=<span class="string">"10dp"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"用户协议"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><h4 id="View注入"><a href="#View注入" class="headerlink" title="View注入"></a>View注入</h4><p>　　使用ButterKnife获取Button与CheckBox实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@BindView</span>(R.id.btn_login)</div><div class="line">Button btnLogin;</div><div class="line"><span class="meta">@BindView</span>(R.id.cb_contract)</div><div class="line">CheckBox cbContract;</div></pre></td></tr></table></figure></p>
<h4 id="checkedChanges选中状态改变事件"><a href="#checkedChanges选中状态改变事件" class="headerlink" title="checkedChanges选中状态改变事件"></a>checkedChanges选中状态改变事件</h4><p>　　<code>RxCompoundButton.checkedChanges(CompoundButton view)</code>，内部封装了OnCheckedChangeListener选中状态改变监听。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//默认注册按钮不可点击</span></div><div class="line">btnLogin.setEnabled(<span class="keyword">false</span>);</div><div class="line">addDisposable(RxCompoundButton.checkedChanges(cbContract)</div><div class="line">        .subscribe(aBoolean -&gt; &#123;</div><div class="line">            RxView.enabled(btnLogin).accept(aBoolean);</div><div class="line">            btnLogin.setBackgroundResource(aBoolean ? R.color.colorPrimary : R.color.colorGray);</div><div class="line">            RxTextView.color(btnLogin).accept(aBoolean ? Color.parseColor(<span class="string">"#ffffff"</span>) :</div><div class="line">                    Color.parseColor(<span class="string">"#000000"</span>));</div><div class="line">        &#125;));</div><div class="line">addDisposable(RxView.clicks(btnLogin)</div><div class="line">        <span class="comment">//防抖2s</span></div><div class="line">        .throttleFirst(<span class="number">2</span>, TimeUnit.SECONDS)</div><div class="line">        .subscribe(o -&gt; Toast.makeText(RxCompoundButtonActivity.<span class="keyword">this</span>, <span class="string">"注册成功"</span>,</div><div class="line">                Toast.LENGTH_SHORT).show()));</div></pre></td></tr></table></figure></p>
<p>　　默认注册按钮不可点击，当CheckBox被选中后则可点击注册，并修改注册按钮的样式。</p>
<h3 id="View操作"><a href="#View操作" class="headerlink" title="View操作"></a>View操作</h3><p>　　RxCompoundButton中也封装了CompoundButton中例如<code>setchecked()</code>、<code>toggle()</code>等常用的操作，使用方式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">addDisposable(RxView.clicks(btnLogin)</div><div class="line">        .subscribe(o -&gt; &#123;</div><div class="line">            RxCompoundButton.checked(cbContract).accept(<span class="keyword">true</span>);</div><div class="line">            RxCompoundButton.toggle(cbContract).accept(<span class="keyword">null</span>);</div><div class="line">        &#125;));</div></pre></td></tr></table></figure></p>
<h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p>　　最后看一下运行效果Gif。</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/18671102.jpg" alt="运行效果"><br></div></p>
<h3 id="本文疑问"><a href="#本文疑问" class="headerlink" title="本文疑问"></a>本文疑问</h3><h4 id="addDisposable-方法什么鬼？"><a href="#addDisposable-方法什么鬼？" class="headerlink" title="addDisposable()方法什么鬼？"></a>addDisposable()方法什么鬼？</h4><p>飞机到本系列第一篇有讲解：<br><a href="http://xulei.tech/2017/11/09/RxBinding系列之RxView(一)" target="_blank" rel="external">RxBinding系列之RxView(一)</a></p>
<h4 id="Lambda表达式什么鬼？"><a href="#Lambda表达式什么鬼？" class="headerlink" title="Lambda表达式什么鬼？"></a>Lambda表达式什么鬼？</h4><p>飞机到我写的Lambda表达式教程：<br><a href="http://xulei.tech/2017/07/24/Lambda表达式基本语法与应用" target="_blank" rel="external">Lambda表达式基本语法与应用</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　通过实际场景来学习新知识掌握起来肯定比死啃理论快，建议码友们都上手试试。<br>　　进阶中的码猿一枚，写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxBindingDemo项目Issues中提出，我会及时回复。<br>　　附上Demo的地址：<br>　　<a href="https://github.com/LeiHolmes/RxBindingDemo" target="_blank" rel="external">RxBindingDemo</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;　　本篇将通过一个实际场景来学习RxBinding中的RxCompoundButton，J大神将Android中CompoundButton的一些事件及动作加以RxJava的观察者模式并封装了起来就形成了RxCompoundButton，使用起来也很简单。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="RxBinding" scheme="http://LeiHolmes.github.io/tags/RxBinding/"/>
    
  </entry>
  
  <entry>
    <title>RxBinding系列之RxTextView(二)</title>
    <link href="http://LeiHolmes.github.io/2017/11/12/RxBinding%E7%B3%BB%E5%88%97%E4%B9%8BRxTextView(%E4%BA%8C)/"/>
    <id>http://LeiHolmes.github.io/2017/11/12/RxBinding系列之RxTextView(二)/</id>
    <published>2017-11-11T16:00:00.000Z</published>
    <updated>2018-06-05T03:16:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　本篇一起来学习RxBinding中的RxTextView，J大神将Android中TextView的一些事件及动作加以RxJava的观察者模式并封装了起来就形成了RxTextView，使用起来也很简单。<br>　　<a id="more"></a></p>
<h3 id="textChange文本改变事件"><a href="#textChange文本改变事件" class="headerlink" title="textChange文本改变事件"></a>textChange文本改变事件</h3><h4 id="textChanges"><a href="#textChanges" class="headerlink" title="textChanges"></a>textChanges</h4><p>　　<code>RxTextView.textChanges(TextView view)</code>，内部封装了TextWatcher文本改变监听。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">addDisposable(RxTextView.textChanges(etRxTextView)</div><div class="line">.subscribe(<span class="keyword">new</span> Consumer&lt;CharSequence&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(CharSequence charSequence)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Log.e(<span class="string">"rx_binding_test"</span>, <span class="string">"textChanges:文本改变了:"</span> + charSequence.toString());</div><div class="line">    &#125;</div><div class="line">&#125;));</div></pre></td></tr></table></figure></p>
<h4 id="textChangeEvents"><a href="#textChangeEvents" class="headerlink" title="textChangeEvents"></a>textChangeEvents</h4><p>　　<code>RxTextView.textChangeEvents(TextView view)</code>，内部同样封装了TextWatcher文本改变监听。不同的是其返回数据的类型为TextViewTextChangeEvent，内部包含详细的文本改变数据。为了简化代码，以下实例将使用Lambda表达式的形式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">addDisposable(RxTextView.textChangeEvents(etRxTextView)</div><div class="line">        .subscribe(textViewTextChangeEvent -&gt; &#123;</div><div class="line">            Log.e(<span class="string">"rx_binding_test"</span>, <span class="string">"textChanges:文本改变了:"</span> + <span class="string">"before:"</span> + textViewTextChangeEvent.before() + </div><div class="line">                <span class="string">",start:"</span> + textViewTextChangeEvent.start() + <span class="string">",text:"</span> + textViewTextChangeEvent.text() + </div><div class="line">                <span class="string">",count:"</span> + textViewTextChangeEvent.count());</div><div class="line">        &#125;));</div></pre></td></tr></table></figure></p>
<h4 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h4><p>　　在实际项目开发中经常会遇到搜索文本框需根据用户实时输入的文本进行检索，或去数据库查询，或去服务器请求检索。如果文本每改变一次都去检索的话会导致重复大量查数据库或请求服务器，很影响内存。来看下使用RxBinding如何解决这个问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">addDisposable(RxTextView.textChanges(etRxTextView)</div><div class="line">        <span class="comment">//限流时间500ms</span></div><div class="line">        .debounce(<span class="number">500</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        <span class="comment">//CharSequence转换为String</span></div><div class="line">        .map(CharSequence::toString)</div><div class="line">        .subscribe(s -&gt; &#123;</div><div class="line">            <span class="comment">//这里可以查询数据库或请求服务器查询</span></div><div class="line">            Log.e(<span class="string">"rx_binding_test"</span>, <span class="string">"textChanges:文本改变了:"</span> + s);</div><div class="line">        &#125;));</div></pre></td></tr></table></figure></p>
<p>　　正是由于RxBinding使用的是RxJava形式，所以RxJava中的操作符我们都可以使用。利用debounce操作符进行限流，就能避免因为用户输入速度过快导致多次请求服务器了。还可以利用map操作符将CharSequence转换为String再返回。Look，解决这个问题是不是So easy！</p>
<h3 id="editorAction回车点击事件"><a href="#editorAction回车点击事件" class="headerlink" title="editorAction回车点击事件"></a>editorAction回车点击事件</h3><h4 id="editorActions"><a href="#editorActions" class="headerlink" title="editorActions"></a>editorActions</h4><p>　　<code>RxTextView.editorActions(TextView view)</code>，内部封装了OnEditorActionListener软键盘回车点击监听。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">addDisposable(RxTextView.editorActions(etRxTextView)</div><div class="line">        .subscribe(integer -&gt; &#123;</div><div class="line">            Log.e(<span class="string">"rx_binding_test"</span>, <span class="string">"editorActions:输入完毕，点击回车:"</span>);</div><div class="line">        &#125;));</div></pre></td></tr></table></figure></p>
<h4 id="editorActionEvents"><a href="#editorActionEvents" class="headerlink" title="editorActionEvents"></a>editorActionEvents</h4><p>　　<code>RxTextView.editorActionEvents(TextView view)</code>，内部同样封装了OnEditorActionListener软键盘回车点击监听。不同的是它的返回类型为TextViewEditorActionEvent，包含actionId，keyEvent等信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">addDisposable(RxTextView.editorActionEvents(etRxTextView)</div><div class="line">        .subscribe(textViewEditorActionEvent -&gt; &#123;</div><div class="line">            KeyEvent keyEvent = textViewEditorActionEvent.keyEvent();</div><div class="line">            <span class="comment">//判断up状态</span></div><div class="line">            <span class="keyword">if</span> (keyEvent.getKeyCode() == KeyEvent.KEYCODE_ENTER &amp;&amp; keyEvent.getAction() == KeyEvent.ACTION_UP) &#123;</div><div class="line">                Log.e(<span class="string">"rx_binding_test"</span>, <span class="string">"editorActionEvents:输入完毕，点击回车:"</span> + textViewEditorActionEvent.keyEvent());</div><div class="line">            &#125;</div><div class="line">        &#125;));</div></pre></td></tr></table></figure></p>
<p>　　<strong>注意：KeyEvent包含down和up事件，所以会出现回调两次的问题。根据KeyEvent加入一种判断即可避免此问题。</strong><br>　　此外，RxTextView中还有beforeTextChangeEvents与afterTextChangeEvents，使用起来都差不多就不一一介绍了。</p>
<h3 id="View操作"><a href="#View操作" class="headerlink" title="View操作"></a>View操作</h3><p>　　RxTextView中还封装了一些常用的例如<code>setText()</code>、<code>setHint()</code>、<code>setTextColor()</code>等TextView的操作。使用起来也很简单，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">addDisposable(RxTextView.editorActions(etRxTextView)</div><div class="line">        .subscribe(integer -&gt; &#123;</div><div class="line">            RxTextView.text(etRxTextView).accept(<span class="string">"LeiHolmes"</span>);</div><div class="line">            RxTextView.hint(etRxTextView).accept(<span class="string">"请输入姓名"</span>);</div><div class="line">            RxTextView.color(etRxTextView).accept(Color.parseColor(<span class="string">"#00ff00"</span>));</div><div class="line">        &#125;));</div></pre></td></tr></table></figure></p>
<h3 id="本文疑问"><a href="#本文疑问" class="headerlink" title="本文疑问"></a>本文疑问</h3><h4 id="addDisposable-方法什么鬼？"><a href="#addDisposable-方法什么鬼？" class="headerlink" title="addDisposable()方法什么鬼？"></a>addDisposable()方法什么鬼？</h4><p>飞机到本系列第一篇有讲解：<br><a href="http://xulei.tech/2017/11/09/RxBinding系列之RxView(一)" target="_blank" rel="external">RxBinding系列之RxView(一)</a></p>
<h4 id="Lambda表达式什么鬼？"><a href="#Lambda表达式什么鬼？" class="headerlink" title="Lambda表达式什么鬼？"></a>Lambda表达式什么鬼？</h4><p>飞机到我写的Lambda表达式教程：<br><a href="http://xulei.tech/2017/07/24/Lambda表达式基本语法与应用" target="_blank" rel="external">Lambda表达式基本语法与应用</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　RxTextView中的内容不多，所以本篇篇幅较短，不要说我水啊，哈哈哈，我是觉得一种一种讲起来比较细致，建议码友们都上手敲一敲试一试啊。<br>　　进阶中的码猿一枚，写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxBindingDemo项目Issues中提出，我会及时回复。<br>　　附上Demo的地址：<br>　　<a href="https://github.com/LeiHolmes/RxBindingDemo" target="_blank" rel="external">RxBindingDemo</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;　　本篇一起来学习RxBinding中的RxTextView，J大神将Android中TextView的一些事件及动作加以RxJava的观察者模式并封装了起来就形成了RxTextView，使用起来也很简单。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="RxBinding" scheme="http://LeiHolmes.github.io/tags/RxBinding/"/>
    
  </entry>
  
  <entry>
    <title>RxBinding系列之RxView(一)</title>
    <link href="http://LeiHolmes.github.io/2017/11/09/RxBinding%E7%B3%BB%E5%88%97%E4%B9%8BRxView(%E4%B8%80)/"/>
    <id>http://LeiHolmes.github.io/2017/11/09/RxBinding系列之RxView(一)/</id>
    <published>2017-11-08T16:00:00.000Z</published>
    <updated>2017-11-12T12:33:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　自从用上RxJava后彻底迷上Rx系列响应式编程，从本篇开始一起来学习一下Rx套餐之一的RxBinding。RxBinding是什么？它是一组开源库，来自大神Jake Wharton之手，可将Android中各类UI控件的动作事件转换为RxJava中的数据流。也就是说使用RxBinding，我们就可以以RxJava的形式来处理UI事件。本篇主要讲解其中RxView的相关View事件如何绑定。<br>　　<a id="more"></a><br>　　RxBinding中主要包含RxView、RxTextView、RxAdapterView、RxCompoundButton等等。由于全写一起篇幅太长，我就一篇讲解一种了。本系列主要讲解以上常用的4种，详细内容可飞机到：<br>　　<a href="https://github.com/JakeWharton/RxBinding" target="_blank" rel="external">Jake Wharton的RxBinding</a></p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>　　本系列围绕我自己编写的RxBindingDemo来进行讲解，项目中主要使用ButterKnife做View注入，RxBinding做事件绑定。RxBindingDemo代码在文末有给地址。<br>　　<strong>注意：RxBinding包中包含RxJava的内容，所以就无需再添加RxJava的依赖了。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    ......</div><div class="line">    compile <span class="string">'com.jakewharton.rxbinding2:rxbinding:2.0.0'</span></div><div class="line">    compile <span class="string">'com.jakewharton:butterknife:8.8.1'</span></div><div class="line">    annotationProcessor <span class="string">'com.jakewharton:butterknife-compiler:8.8.1'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="BaseActivity"><a href="#BaseActivity" class="headerlink" title="BaseActivity"></a>BaseActivity</h3><p>　　相信学习过RxJava的码友一定记得，使用RxJava实例化的Disposable需在不用时及时销毁。<br>　　由于每个Activity中都写一套add与clear的方法会造成代码冗余，所以我将它们封装到BaseActivity中方便统一对Disposable进行管理，以及ButterKnife的统一绑定与解绑。<br>　　献上代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> CompositeDisposable mCompositeDisposable;</div><div class="line">    <span class="keyword">private</span> Unbinder mUnbinder;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(getLayoutId());</div><div class="line">        mUnbinder = ButterKnife.bind(<span class="keyword">this</span>);</div><div class="line">        mCompositeDisposable = <span class="keyword">new</span> CompositeDisposable();</div><div class="line">        onViewCreated(savedInstanceState);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 添加订阅</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDisposable</span><span class="params">(Disposable mDisposable)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mCompositeDisposable == <span class="keyword">null</span>) &#123;</div><div class="line">            mCompositeDisposable = <span class="keyword">new</span> CompositeDisposable();</div><div class="line">        &#125;</div><div class="line">        mCompositeDisposable.add(mDisposable);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 取消所有订阅</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearDisposable</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mCompositeDisposable != <span class="keyword">null</span>) &#123;</div><div class="line">            mCompositeDisposable.clear();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        clearDisposable();</div><div class="line">        mUnbinder.unbind();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getLayoutId</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(Bundle savedInstanceState)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="click点击事件"><a href="#click点击事件" class="headerlink" title="click点击事件"></a>click点击事件</h3><h4 id="clicks"><a href="#clicks" class="headerlink" title="clicks"></a>clicks</h4><p>　　<code>RxView.clicks(View view)</code>，通过源码可发现其内部封装了View.OnClickListener点击监听，调用clicks方法返回一个Observable对象，每当点击这个View的时候，该Observable对象就会发射一个事件，随即调用onNext()方法，Observable对应的观察者就可以通过onNext()回调响应此次点击事件。使用RxBinding还可做到点击防抖的效果。来看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">addDisposable(RxView.clicks(btnClick)</div><div class="line">        .throttleFirst(<span class="number">2</span>, TimeUnit.SECONDS)</div><div class="line">        .subscribe(o -&gt; &#123;</div><div class="line">            Log.e(<span class="string">"rx_binding_test"</span>, <span class="string">"clicks:点击了按钮：两秒内防抖"</span>);</div><div class="line">        &#125;));</div></pre></td></tr></table></figure></p>
<p>　　<code>throttleFirst(long windowDuration, TimeUnit unit)</code>，设置一定时间内只响应首次(throttleFirst)或者末次(throttleLast)的点击事件。windowDuration为防抖时间，unit为时间单位。调用这个方法便可防止短时间内对View的重复点击，本例中设置的防抖时间为2s。从代码看来是不是方便又简洁呢，以往实现防抖还得添加各种标记，忒麻烦。</p>
<h4 id="longClicks"><a href="#longClicks" class="headerlink" title="longClicks"></a>longClicks</h4><p>　　<code>RxView.longClicks(View view)</code>，内部封装了View.OnLongClickListener长按监听，原理同上。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">addDisposable(RxView.longClicks(btnClick)</div><div class="line">        .subscribe(o -&gt; &#123;</div><div class="line">            Log.e(<span class="string">"rx_binding_test"</span>, <span class="string">"longClicks:长点击了按钮"</span>);</div><div class="line">        &#125;));</div></pre></td></tr></table></figure></p>
<h3 id="draw绘制事件"><a href="#draw绘制事件" class="headerlink" title="draw绘制事件"></a>draw绘制事件</h3><p>　　<code>RxView.draws(View view)</code>，内部封装了OnDrawListener绘制监听。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//点击btnDraw调用viewCanvas的绘制</span></div><div class="line">addDisposable(RxView.clicks(btnDraw)</div><div class="line">        .throttleFirst(<span class="number">2</span>, TimeUnit.SECONDS)</div><div class="line">        .subscribe(o -&gt; &#123;</div><div class="line">            <span class="comment">//此处可模拟让viewCanvas绘制</span></div><div class="line">            <span class="comment">//viewCanvas.getViewTreeObserver().dispatchOnDraw();</span></div><div class="line">        &#125;));</div><div class="line">        </div><div class="line"><span class="comment">//当viewCanvas绘制时触发</span></div><div class="line">addDisposable(RxView.draws(viewCanvas)</div><div class="line">        .subscribe(o -&gt; &#123;</div><div class="line">            Log.e(<span class="string">"rx_binding_test"</span>, <span class="string">"draws:viewCanvas绘制了"</span>);</div><div class="line">        &#125;));</div></pre></td></tr></table></figure></p>
<h3 id="drag拖拽事件"><a href="#drag拖拽事件" class="headerlink" title="drag拖拽事件"></a>drag拖拽事件</h3><p>　　<code>RxView.drags(View view)</code>，内部封装了OnDragListener拖拽监听。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//当btnDraw被拖拽时触发</span></div><div class="line">addDisposable(RxView.drags(btnDraw)</div><div class="line">        .subscribe(o -&gt; &#123;</div><div class="line">            Log.e(<span class="string">"rx_binding_test"</span>, <span class="string">"drags:btnDraw被拖拽了"</span>);</div><div class="line">        &#125;));</div></pre></td></tr></table></figure></p>
<h3 id="layoutChange布局改变事件"><a href="#layoutChange布局改变事件" class="headerlink" title="layoutChange布局改变事件"></a>layoutChange布局改变事件</h3><p>　　<code>RxView.layoutChanges(View view)</code>，内部封装了OnLayoutChangeListener布局改变监听。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//点击btnChange改变btn_layout的布局,防抖2s</span></div><div class="line">addDisposable(RxView.clicks(btnChange)</div><div class="line">        .throttleFirst(<span class="number">2</span>, TimeUnit.SECONDS)</div><div class="line">        .subscribe(o -&gt; btnLayout.layout(btnLayout.getLeft() - <span class="number">20</span>, </div><div class="line">                btnLayout.getTop(), btnLayout.getRight() - <span class="number">20</span>, btnLayout.getBottom())</div><div class="line">        ));</div><div class="line">        </div><div class="line"><span class="comment">//btn_layout布局改变时触发</span></div><div class="line">addDisposable(RxView.layoutChanges(btnLayout)</div><div class="line">        .subscribe(o -&gt; &#123;</div><div class="line">            Log.e(<span class="string">"rx_binding_test"</span>, <span class="string">"layoutChanges:btnLayout布局改变了"</span>);</div><div class="line">        &#125;));</div></pre></td></tr></table></figure></p>
<h3 id="scrollChange滑动事件"><a href="#scrollChange滑动事件" class="headerlink" title="scrollChange滑动事件"></a>scrollChange滑动事件</h3><p>　　<code>RxView.scrollChangeEvents(View view)</code>，内部封装了OnScrollChangeListener滑动监听。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//点击btnScroll模拟让btnScrollLayout滑动</span></div><div class="line">addDisposable(RxView.clicks(btnScroll)</div><div class="line">        .throttleFirst(<span class="number">2</span>, TimeUnit.SECONDS)</div><div class="line">        .subscribe(o -&gt; &#123;</div><div class="line">            x += <span class="number">10</span>;</div><div class="line">            <span class="keyword">if</span> (x == <span class="number">100</span>) &#123;</div><div class="line">                x = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            btnScrollLayout.scrollTo(x, <span class="number">0</span>);</div><div class="line">        &#125;));</div><div class="line">        </div><div class="line"><span class="comment">//btnScrollLayout滑动时触发</span></div><div class="line">addDisposable(RxView.scrollChangeEvents(btnScrollLayout)</div><div class="line">        .subscribe(event -&gt; &#123;</div><div class="line">            Log.e(<span class="string">"rx_binding_test"</span>, <span class="string">"scrollChangeEvents:btnScrollLayout滑动了:"</span> + event.toString());</div><div class="line">        &#125;));</div></pre></td></tr></table></figure></p>
<h3 id="View操作"><a href="#View操作" class="headerlink" title="View操作"></a>View操作</h3><p>　　RxView中还封装了一些常用的例如<code>setVisibility()</code>、<code>setClickable()</code>等View操作。使用起来也很简单，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">addDisposable(RxView.clicks(btnClick)</div><div class="line">        .throttleFirst(<span class="number">2</span>, TimeUnit.SECONDS)</div><div class="line">        .subscribe(o -&gt; &#123;</div><div class="line">            RxView.visibility(btnClick).accept(<span class="keyword">true</span>);</div><div class="line">            RxView.clickable(btnClick).accept(<span class="keyword">true</span>);</div><div class="line">            RxView.enabled(btnClick).accept(<span class="keyword">true</span>);</div><div class="line">        &#125;));</div></pre></td></tr></table></figure></p>
<p>　　这种操作方法单独使用是需要进行try-catch的，但还记得RxJava2系列中我们学习到，RxJava2的Action与Function的回调方法中都默认throws Exception，RxBinding也是如此。所以在观察者中调用就无需try-catch了。<br>　　更多的操作可在RxView的源码中查到，基本上View中有的，J大神都编写了，膜拜大神。</p>
<h3 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h3><p>　　最后别忘了在Activity销毁时对创建的Disposable取消订阅。Demo中的Act都以BaseActivity为基类，所以就无需再调用取消订阅了，BaseActivity已经将这些工作做好了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　RxBinding使用起来非常简单，RxView中还有attaches、detaches，focusChanges，globalLayouts，hovers，touches等等就不一一演示了，码友们可自行尝试。<br>　　进阶中的码猿一枚，写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxBindingDemo项目Issues中提出，我会及时回复。<br>　　附上Demo的地址：<br>　　<a href="https://github.com/LeiHolmes/RxBindingDemo" target="_blank" rel="external">RxBindingDemo</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;　　自从用上RxJava后彻底迷上Rx系列响应式编程，从本篇开始一起来学习一下Rx套餐之一的RxBinding。RxBinding是什么？它是一组开源库，来自大神Jake Wharton之手，可将Android中各类UI控件的动作事件转换为RxJava中的数据流。也就是说使用RxBinding，我们就可以以RxJava的形式来处理UI事件。本篇主要讲解其中RxView的相关View事件如何绑定。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="RxBinding" scheme="http://LeiHolmes.github.io/tags/RxBinding/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2系列实践之倒计时功能(三)</title>
    <link href="http://LeiHolmes.github.io/2017/11/07/RxJava2%E7%B3%BB%E5%88%97%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%80%92%E8%AE%A1%E6%97%B6%E5%8A%9F%E8%83%BD(%E4%B8%89)/"/>
    <id>http://LeiHolmes.github.io/2017/11/07/RxJava2系列实践之倒计时功能(三)/</id>
    <published>2017-11-06T16:00:00.000Z</published>
    <updated>2017-11-26T11:20:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　通过本系列前两篇的学习，相信各位码友已经基本掌握RxJava2怎么使用了，本篇我们一起来通过一个小例子实践一下，也可以加深印象。来看看如何使用RxJava2的intervalRange操作符实现倒计时功能。<br>　　<a id="more"></a></p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>　　首先添加依赖，Demo中使用了ButterKnife注入，各版本以当前最新的为准。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    ......</div><div class="line">    compile <span class="string">'io.reactivex.rxjava2:rxjava:2.1.3'</span></div><div class="line">    compile <span class="string">'io.reactivex.rxjava2:rxandroid:2.0.1'</span></div><div class="line">    compile <span class="string">'com.jakewharton:butterknife:8.7.0'</span></div><div class="line">    annotationProcessor <span class="string">'com.jakewharton:butterknife-compiler:8.7.0'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="intervalRange操作符"><a href="#intervalRange操作符" class="headerlink" title="intervalRange操作符"></a>intervalRange操作符</h3><p>　　别着急上代码，开始前我们先来了解下intervalRange操作符（了解过的可以忽略哈）。<br>　　<strong>intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit)</strong>  </p>
<ul>
<li>start：起始数值</li>
<li>count：发射数量</li>
<li>initialDelay：延迟执行时间</li>
<li>period：发射周期时间</li>
<li>unit：时间单位</li>
</ul>
<p>　　一句话简介就是延迟initialDelay个unit单位后，以period为周期，依次发射count个以start为初始值并递增的数字。</p>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>　　布局中放一个Button用来演示点击获取验证码，并开启倒计时重新获取的功能。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:padding</span>=<span class="string">"15dp"</span></div><div class="line">    <span class="attr">tools:context</span>=<span class="string">"com.holmeslei.rxjava2demo.ui.CountDownActivity"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/btn_get_code"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"获取验证码"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><p>　　由于业务逻辑简单，所以就不整什么复杂的框架了，功能都在Activity中实现。</p>
<ol>
<li>第一步，使用ButterKnife依赖注入获取Button的实例及设置其点击监听方法。</li>
<li>第二步，点击Button后首先将其设置为不可点击，然后初始化全局变量Disposable。</li>
<li>第三步，使用Flowable的intervalRange操作符，从0开始每隔1s发射一个自增的数字，持续11次，延迟0s执行。这样就设定好了10秒的倒计时，可根据实际需要修改时长。</li>
<li>由于需要刷新UI，所以设定观察者执行在Android的UI线程。</li>
<li>在doOnNext的回调中更新Button的显示UI，达到读秒的效果。</li>
<li>在doOnComplete的完成回调中重新将Button设置为可点击，然后设置显示UI。</li>
<li>最后调用后subscribe()订阅，这样一个完整的异步事件流就完成了。</li>
<li>别忘了在Activity销毁时将全局Disposable取消订阅销毁掉。使用RxJava将无用的Disposable及时销毁是一个很好的习惯，否则后期就得忙着处理各种OOM异常啦。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">    <span class="meta">@BindView</span>(R.id.btn_get_code)</div><div class="line">    Button btnGetCode;</div><div class="line">    <span class="keyword">private</span> Disposable mdDisposable;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_count_down);</div><div class="line">        ButterKnife.bind(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@OnClick</span>(R.id.btn_get_code)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewClicked</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//点击后置为不可点击状态</span></div><div class="line">        btnGetCode.setEnabled(<span class="keyword">false</span>);</div><div class="line">        <span class="comment">//从0开始发射11个数字为：0-10依次输出，延时0s执行，每1s发射一次。</span></div><div class="line">        mdDisposable = Flowable.intervalRange(<span class="number">0</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS)</div><div class="line">                .observeOn(AndroidSchedulers.mainThread())</div><div class="line">                .doOnNext(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                        btnGetCode.setText(<span class="string">"重新获取("</span> + (<span class="number">10</span> - aLong) + <span class="string">")"</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">                .doOnComplete(<span class="keyword">new</span> Action() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                        <span class="comment">//倒计时完毕置为可点击状态</span></div><div class="line">                        btnGetCode.setEnabled(<span class="keyword">true</span>);</div><div class="line">                        btnGetCode.setText(<span class="string">"获取验证码"</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">                .subscribe();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        <span class="keyword">if</span> (mdDisposable != <span class="keyword">null</span>) &#123;</div><div class="line">            mdDisposable.dispose();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p>　　最后看一下运行效果Gif。</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/7025359.jpg" alt="运行效果"><br></div></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　本篇文章利用RxJava2演示了一个倒计时的小栗子，更多的用法还待各位码友去探索与发现哈。<br>　　进阶中的码猿一枚，写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJava2Demo项目Issues中提出，我会及时回复。<br>　　附上RxJava2Demo的地址：<br>　　<a href="https://github.com/LeiHolmes/RxJava2Demo" target="_blank" rel="external">RxJava2Demo</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;　　通过本系列前两篇的学习，相信各位码友已经基本掌握RxJava2怎么使用了，本篇我们一起来通过一个小例子实践一下，也可以加深印象。来看看如何使用RxJava2的intervalRange操作符实现倒计时功能。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="RxJava2" scheme="http://LeiHolmes.github.io/tags/RxJava2/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2系列之相较RxJava1的更新之处(二)</title>
    <link href="http://LeiHolmes.github.io/2017/11/05/RxJava2%E7%B3%BB%E5%88%97%E4%B9%8B%E7%9B%B8%E8%BE%83RxJava1%E7%9A%84%E6%9B%B4%E6%96%B0%E4%B9%8B%E5%A4%84(%E4%BA%8C)/"/>
    <id>http://LeiHolmes.github.io/2017/11/05/RxJava2系列之相较RxJava1的更新之处(二)/</id>
    <published>2017-11-04T16:00:00.000Z</published>
    <updated>2017-11-26T11:19:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　通过本系列上一篇文章，我们了解了RxJava1中由于被观察者发送事件的速度远快于观察者处理事件的速度导致的背压问题，由此而生出背压策略。虽然RxJava1中有一些操作符支持背压策略，也有一些其他方法，但效果并不太理想。这个问题到了RxJava2中得到了更好地解决。本篇一起来看相较于RxJava1，RxJava2从观察者模式到语法以及线程调度都做了哪些更新。<br>　　<a id="more"></a></p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>　　首先当然是添加RxJava2与RxAndroid2的依赖啦，以当前最新版本为准。虽然RxAndroid中包含RxJava的内容，但尝试了一下，只引入RxAndroid还是会报错，所以两依赖都加上了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    ......</div><div class="line">    compile <span class="string">'io.reactivex.rxjava2:rxjava:2.1.3'</span></div><div class="line">    compile <span class="string">'io.reactivex.rxjava2:rxandroid:2.0.1'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　<strong>注意：RxJava2与RxJava1的依赖不可共存</strong></p>
<h3 id="观察者模式更新"><a href="#观察者模式更新" class="headerlink" title="观察者模式更新"></a>观察者模式更新</h3><p>　　RxJava2中除了保留了RxJava1中Observable–&gt;Observer观察者模式以外，还新增了一种观察者模式Flowable–&gt;Subscriber。目的为何相信大家已经知道了，新观察者模式可完美支持背压策略。<br>　　不了解背压策略的码友欢迎阅读上一篇文章：<br>　　<a href="http://xulei.tech/2017/10/29/RxJava2系列之背压策略(一" target="_blank" rel="external">RxJava2系列之背压策略(一)</a>)  </p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/81871298.jpg" alt="自绘结构图"><br></div><br>　　由结构图可见，RxJava2将RxJava1中支持背压与不支持背压的操作符分开了，支持背压的归入Flowable观察者模式中，不支持背压的归入Observable观察者模式中。  </p>
<p>　　来看一个使用range操作符的Flowable示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Flowable.range(<span class="number">1</span>, <span class="number">4</span>).subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</div><div class="line">    Subscription subscription;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"rx2_test"</span>, <span class="string">"onSubscribe"</span>);</div><div class="line">        subscription = s;</div><div class="line">        <span class="comment">//这里可进行一些初始化操作</span></div><div class="line">        subscription.request(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"rx2_test"</span>, <span class="string">"onNext："</span> + integer);</div><div class="line">        subscription.request(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"rx2_test"</span>, <span class="string">"onError："</span> + t.getMessage());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"rx2_test"</span>, <span class="string">"onComplete"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">rx2_test: onSubscribe</div><div class="line">rx2_test: onNext：<span class="number">1</span></div><div class="line">rx2_test: onNext：<span class="number">2</span></div><div class="line">rx2_test: onNext：<span class="number">3</span></div><div class="line">rx2_test: onNext：<span class="number">4</span></div><div class="line">rx2_test: onComplete</div></pre></td></tr></table></figure></p>
<p>　　由示例可以看出Flowable是支持背压策略的，整个数据流是由Subscriber动态去请求，然后Flowable再响应发射事件。订阅之后首先回调onSubscribe()方法，相当于onStart()方法，建议在其中<strong>先进行一些初始化的操作然后再调用request(n)请求数据</strong>。示例中的Subscription可用于请求数据或在发射过程中满足某些条件时进行取消订阅的操作。  </p>
<p>　　再来看一个使用create操作符的Flowable示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Flowable.create((FlowableOnSubscribe&lt;Integer&gt;) e -&gt; &#123;</div><div class="line">            e.onNext(<span class="number">1</span>);</div><div class="line">            e.onNext(<span class="number">2</span>);</div><div class="line">            e.onNext(<span class="number">3</span>);</div><div class="line">            e.onNext(<span class="number">4</span>);</div><div class="line">            e.onComplete();</div><div class="line">        &#125;,</div><div class="line">        BackpressureStrategy.BUFFER)</div><div class="line">        .subscribe(<span class="keyword">new</span> MySubscription());</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">rx2_test: onSubscribe</div><div class="line">rx2_test: onNext：<span class="number">1</span></div><div class="line">rx2_test: onNext：<span class="number">2</span></div><div class="line">rx2_test: onNext：<span class="number">3</span></div><div class="line">rx2_test: onNext：<span class="number">4</span></div><div class="line">rx2_test: onComplete</div></pre></td></tr></table></figure></p>
<p>　　Flowable也可使用create操作符来创建，但需指定背压策略<code>BackpressureStrategy.BUFFER</code>。<br>　　<br>　　除此之外还有几种观察者模式：</p>
<ul>
<li>Single/SingleObserver：订阅后只能接收到一次</li>
<li>Completable/CompletableObserver：只能接收到完成(onComplete)和错误(onError)回调。</li>
<li>Maybe/MaybeObserver：只能接收到一次true或false的数据</li>
</ul>
<p>　　这几种观察者模式主要用来判断单一状态，不用来发送大量数据。实际使用频率不高就不一一赘述了。
　　</p>
<h3 id="语法更新"><a href="#语法更新" class="headerlink" title="语法更新"></a>语法更新</h3><p>　　语法更新方面，大部分操作符的用法都未改动，有改动的是RxJava1中ActionN，FuncN等等的包名类名。</p>
<h4 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h4><p>　　经落木语码友的提醒，首先需要注意一个细节变动：RxJava2中不再支持传入null，否则会抛出NullPointerException。<br>　　RxJava1中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//可直接传入null</span></div><div class="line">Observable.just(<span class="keyword">null</span>);</div></pre></td></tr></table></figure></p>
<p>　　RxJava2中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//直接传入null会抛出NullPointerException</span></div><div class="line">Observable.just(<span class="keyword">null</span>);</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//操作符返回null会走onError()回调</span></div><div class="line">Observable.just(<span class="number">1</span>)</div><div class="line">        .map(integer -&gt; <span class="keyword">null</span>)</div><div class="line">        .subscribe(o -&gt; Log.e(<span class="string">"test_rxjava"</span>, <span class="string">"onNext:"</span> + o.toString()),</div><div class="line">            throwable -&gt; Log.e(<span class="string">"test_rxjava"</span>, <span class="string">"onError:"</span> + throwable.getMessage()));</div></pre></td></tr></table></figure>
<h4 id="Action更新"><a href="#Action更新" class="headerlink" title="Action更新"></a>Action更新</h4><p>　　更新内容见图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/81453873.jpg" alt=""><br></div><br>　　用法示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx2_test"</span>, <span class="string">"actionChange："</span> + integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<h4 id="Func更新"><a href="#Func更新" class="headerlink" title="Func更新"></a>Func更新</h4><p>　　更新内容见图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/38633623.jpg" alt=""><br></div><br>　　用法示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">        .map(<span class="keyword">new</span> Function&lt;Integer, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(@NonNull Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"xulei"</span> + integer;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx2_test"</span>, <span class="string">"funcChange："</span> + s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　<strong>注意：在Rxjava2中，Action与Function的回调方法中都默认throws Exception，可以不进行try-catch的操作。</strong>  </p>
<h4 id="Subscription更新"><a href="#Subscription更新" class="headerlink" title="Subscription更新"></a>Subscription更新</h4><p>　　Subscription改名为Disposable。由于RxJava2中已经存在了<code>org.reactivestreams.subscription</code>这个类，为了避免名字冲突将原先的<code>rx.Subscription</code>改名为<code>io.reactivex.disposables.Disposable</code>。<br>　　CompositeSubscription也改名为CompositeDisposable。<br>　　<strong>注意：Disposable必须单次使用，用完就要销毁。</strong><br>　　<br>　　需要强调的是，当一个Activity中有多个RxJava异步事件流也就是Disposable时，需要根据事务周期及时进行销毁，否则会导致内存慢慢的，慢慢的……Bang！！！你懂得。那怎么进行集体销毁呢？一起来看下RxJava2中如何实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> CompositeDisposable mCompositeDisposable;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 添加RxJava订阅</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addDisposable</span><span class="params">(Disposable disposable)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mCompositeDisposable == <span class="keyword">null</span>) &#123;</div><div class="line">        mCompositeDisposable = <span class="keyword">new</span> CompositeDisposable();</div><div class="line">    &#125;</div><div class="line">    mCompositeDisposable.add(subscription);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 取消RxJava订阅</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">clearDisposable</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mCompositeDisposable != <span class="keyword">null</span>) &#123;</div><div class="line">        mCompositeDisposable.clear();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　创建一个CompositeDisposable对象(替代RxJava1中CompositeSubscription)，在实例化RxJava2中的Disposable时可调用其<code>add(Disposable d)</code>将Disposable加入其中。等到Activity销毁或者不需要时便可调用其<code>clear()</code>方法对其中的Disposable进行统一取消订阅并销毁的操作。  </p>
<p>　　使用示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(......);</div><div class="line">    addDisposable(Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">        .subscribe((integer -&gt; Log.e(<span class="string">"rx2_test"</span>, <span class="string">""</span> + integer))));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDestroy();</div><div class="line">    clearDisposable()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　<strong>建议：<code>addSubscribe(Disposable disposable)</code>与<code>clearDisposable()</code>可放入BaseActivity或者MVP架构中的BasePresenter中，便于统一管理，使代码更加简洁。</strong>
　　</p>
<h4 id="新增doOnCancel等"><a href="#新增doOnCancel等" class="headerlink" title="新增doOnCancel等"></a>新增doOnCancel等</h4><p>　　RxJava2中除了保留了RxJava1中<code>doOnComplete()</code>，<code>doOnError()</code>，<code>doOnNext()</code>等状态回调之外，还增加了<code>doOnCancel</code>，<code>doOnDispose</code>，<code>unsubscribeOn</code>这几个状态回调，以<code>doOnCancel</code>为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Flowable.range(<span class="number">1</span>, <span class="number">4</span>)</div><div class="line">        .doOnCancel(<span class="keyword">new</span> Action() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx2_test"</span>, <span class="string">"回调doOnCancel"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .take(<span class="number">2</span>)</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx2_test"</span>, <span class="string">"doOnCancel："</span> + integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rx2_test: doOnCancel：<span class="number">1</span></div><div class="line">rx2_test: doOnCancel：<span class="number">2</span></div><div class="line">rx2_test: 回调doOnCancel</div></pre></td></tr></table></figure></p>
<p>　　由于<code>.take(2)</code>操作符只截取了前两个事件，之后的事件未被发送，就会回调doOnCancel中的run()方法。</p>
<h4 id="线程调度更新"><a href="#线程调度更新" class="headerlink" title="线程调度更新"></a>线程调度更新</h4><p>　　线程调度这里改动也不大，主要有以下三点：  </p>
<ul>
<li>移除Schedulers.immediate。</li>
<li>移除Schedulers.test。</li>
<li>io.reactivex.Scheduler抽象类支持直接调度自定义线程任务。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　本文主要讲解了RxJava2中常用点的更新，更多细节的调整各位码友可以参考官网文档。了解了理论还需勤加练习才能真正掌握RxJava2，下一篇我们将通过一个实际例子来实践一下RxJava2，敬请期待。<br>　　进阶中的码猿一枚，写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJava2Demo项目Issues中提出，我会及时回复。<br>　　附上RxJava2Demo的地址：<br>　　<a href="https://github.com/LeiHolmes/RxJava2Demo" target="_blank" rel="external">RxJava2Demo</a><br>　　<strong>注意：本文中插入的图片均为本人原创绘制，引用请标注来源，谢谢。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;　　通过本系列上一篇文章，我们了解了RxJava1中由于被观察者发送事件的速度远快于观察者处理事件的速度导致的背压问题，由此而生出背压策略。虽然RxJava1中有一些操作符支持背压策略，也有一些其他方法，但效果并不太理想。这个问题到了RxJava2中得到了更好地解决。本篇一起来看相较于RxJava1，RxJava2从观察者模式到语法以及线程调度都做了哪些更新。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="RxJava2" scheme="http://LeiHolmes.github.io/tags/RxJava2/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2系列之背压策略(一)</title>
    <link href="http://LeiHolmes.github.io/2017/10/29/RxJava2%E7%B3%BB%E5%88%97%E4%B9%8B%E8%83%8C%E5%8E%8B%E7%AD%96%E7%95%A5(%E4%B8%80)/"/>
    <id>http://LeiHolmes.github.io/2017/10/29/RxJava2系列之背压策略(一)/</id>
    <published>2017-10-28T16:00:00.000Z</published>
    <updated>2017-11-26T11:17:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　通过前7篇RxJava的文章，我们对RxJava1.x版本的内容进行了学习与实践。目前RxJava已经更新到2.x了，有小伙伴问我为什么不直接上RxJava2的教程？RxJava2是在1的基础上进行了更新与优化，有很多相通之处，初学者的话建议还是先从RxJava1的基础理论一步步学习。<br>　　本系列主要通过与RxJava1比较来学习RxJava2都有哪些改变。而RxJava2中最大的优化之处就在于它解决了RxJava1中未能有效解决的背压(Backpressure)问题。本篇我们就来看看什么是背压，以及RxJava1中是如何解决这个问题。<br>　　<a id="more"></a></p>
<h3 id="背压问题"><a href="#背压问题" class="headerlink" title="背压问题"></a>背压问题</h3><p>　　先来个定义：<strong>背压问题是指在RxJava观察者模式的异步场景中，由于被观察者生产事件的速度远远快于观察者消费事件的速度，从而导致生产的事件堆积，最后致使内存溢出，程序崩溃</strong>。<br>　　再上个场景：工厂生产面包，消费者吃面包。工厂生产面包速度慢了，消费者处于等待状态，来一个吃一个，这没什么影响。而如果工厂生产面包的速度过快，导致消费者来不及吃，面包就会累积的越来越多，最后就会过期浪费。<br>　　来看代码演示这个问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//被观察者每过1ms发射一个事件</span></div><div class="line">Observable.interval(<span class="number">1</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .observeOn(Schedulers.newThread())</div><div class="line">        .subscribe((aLong) -&gt; &#123;</div><div class="line">            <span class="comment">//观察者每过800ms处理一个事件</span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">800</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            Log.e(<span class="string">"rx_test"</span>, <span class="string">"back_pressure："</span> + aLong);</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　以上代码中被观察者发射事件的速度是观察者处理速度的800倍，执行后就会抛出<code>Caused by: rx.exceptions.MissingBackpressureException</code>的异常。背压问题的出现需要两个条件：</p>
<ul>
<li>观察者与被观察者需处于不同线程。</li>
<li>被观察者产生事件的速度需远快与观察者消费事件的速度。</li>
</ul>
<p>　　由于观察者与被观察者处于不同线程，所以RxJava内部使用队列来存储事件，Android中默认队列缓存buffersize为16，所以当事件累计超过16个时就会抛出MissingBackpressureException的异常。解决这种问题就需要对被观察者进行流速控制了，而<strong>背压正是应对这种问题的一种策略</strong>。</p>
<h3 id="背压策略"><a href="#背压策略" class="headerlink" title="背压策略"></a>背压策略</h3><p>　　背压策略的解决思路便是响应式拉取。与RxJava观察者模型相反，<strong>响应式拉取是观察者主动去被观察者那里拉取事件，而被观察者则是被动等待通知再发射事件。</strong><br>　　观察者需要多少事件就从被观察者那里拉取，而不是被动接收。这样实际上就实现了控制被观察者的流速，达到了背压策略的目的。<br>　　自绘结构图：  </p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/93451869.jpg" alt=""><br></div><br>　　再来看一下代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//range操作符支持背压策略，发送事件的速度可被控制</span></div><div class="line">Observable.range(<span class="number">1</span>, <span class="number">10000</span>)</div><div class="line">        .observeOn(Schedulers.newThread())</div><div class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">//一定要在onStart中通知被观察者先发送一个事件</span></div><div class="line">                request(<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"reactivePull：onCompleted"</span>);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"reactivePull：onError："</span> + e.getMessage());</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer n)</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">1000</span>);</div><div class="line">                    Log.e(<span class="string">"rx_test"</span>, <span class="string">"reactivePull：onNext："</span> + n);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//处理完毕之后，再通知被观察者发送下一个事件</span></div><div class="line">                request(<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　上述代码示例中，被观察者使用了range操作符发射10000次从1开始自增的数字，在观察者中首先于onStart()中使用request(1)向被观察者请求了第一个事件，之后在onNext()中每延时1000ms后输出日志，处理完事件后再调用request(1)请求一个新的事件。<br>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">reactivePull：onNext：<span class="number">1</span></div><div class="line">...<span class="number">1</span>s后...</div><div class="line">reactivePull：onNext：<span class="number">2</span></div><div class="line">...<span class="number">1</span>s后...</div><div class="line">reactivePull：onNext：<span class="number">3</span></div><div class="line">...<span class="number">1</span>s后...</div><div class="line">reactivePull：onNext：<span class="number">4</span></div><div class="line">...<span class="number">1</span>s后...</div><div class="line">reactivePull：onNext：<span class="number">5</span></div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>　　由输出结果可看出，每过1秒输出了一个数字，是不是实现了背压限流策略呢？需要多少事件就在观察者中使用request(n)主动拉取。不过RxJava1.x版本中并不是所有操作符都支持request(n)的响应式拉取，例如第一个例子中的interval操作符就不支持背压策略。而这个问题到了RxJava2.x中就得到了完美解决，且看下一篇。</p>
<h3 id="其他解决方法"><a href="#其他解决方法" class="headerlink" title="其他解决方法"></a>其他解决方法</h3><p>　　RxJava1中不支持背压策略的操作符如何解决背压问题呢？</p>
<h4 id="过滤限流"><a href="#过滤限流" class="headerlink" title="过滤限流"></a>过滤限流</h4><p>　　通过使用限流操作符将被观察者产生的大部分事件过滤抛弃掉来达到限流的目的，间接降低事件发射的速度。  </p>
<ul>
<li><strong>sample</strong>：在一段时间内,只处理最后一个数据</li>
<li><strong>throttleFirst</strong>：在一段时间内,只处理第一个数据</li>
<li><strong>debounce</strong>：发送一个数据,开始计时,到了规定时间内,若没有再发送数据,则开始处理数据,反之重新开始计时。</li>
</ul>
<p>　　这里以sample操作符为例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用sample过滤操作符，每隔300ms取里时间点最近的事件发送</span></div><div class="line">Observable.interval(<span class="number">1</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .observeOn(Schedulers.newThread())</div><div class="line">        .sample(<span class="number">300</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .subscribe((aLong) -&gt; Log.e(<span class="string">"rx_test"</span>, <span class="string">"controlByFilter：sample："</span> + aLong));</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">controlByFilter：sample：<span class="number">280</span></div><div class="line">controlByFilter：sample：<span class="number">577</span></div><div class="line">controlByFilter：sample：<span class="number">878</span></div><div class="line">controlByFilter：sample：<span class="number">1178</span></div><div class="line">controlByFilter：sample：<span class="number">1478</span></div><div class="line">controlByFilter：sample：<span class="number">1779</span></div><div class="line">controlByFilter：sample：<span class="number">2078</span></div><div class="line">controlByFilter：sample：<span class="number">2378</span></div><div class="line">controlByFilter：sample：<span class="number">2673</span></div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>　　这种方式虽然实现了限流，但却是以抛弃大部分事件为代价的，在实际场景中并不可取，大家了解就好。</p>
<h4 id="打包缓存"><a href="#打包缓存" class="headerlink" title="打包缓存"></a>打包缓存</h4><p>　　在被观察者发射事件过快，观察者来不及处理的情况下，可以使用缓存类的操作符将其中一部分打包缓存起来，再一点一点的处理其中的事件。</p>
<ul>
<li><strong>buffer</strong>：将多个事件打包放入一个List中，再一起发射。</li>
<li><strong>window</strong>：将多个事件打包放入一个Observable中，再一起发射。</li>
</ul>
<p>　　这里以buffer操作符为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用buffer过滤操作符，将100ms内的事件打包为list发送</span></div><div class="line">Observable.interval(<span class="number">1</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .observeOn(Schedulers.newThread())</div><div class="line">        .buffer(<span class="number">100</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .subscribe((longs) -&gt; &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">1000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            Log.e(<span class="string">"rx_test"</span>, <span class="string">"controlByCache：buffer："</span> + longs.size());</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">controlByCache：buffer：<span class="number">79</span></div><div class="line">controlByCache：buffer：<span class="number">1001</span></div><div class="line">controlByCache：buffer：<span class="number">1002</span></div><div class="line">controlByCache：buffer：<span class="number">1000</span></div><div class="line">controlByCache：buffer：<span class="number">1001</span></div><div class="line">controlByCache：buffer：<span class="number">1001</span></div><div class="line">controlByCache：buffer：<span class="number">1001</span></div><div class="line">controlByCache：buffer：<span class="number">1001</span></div><div class="line">controlByCache：buffer：<span class="number">1001</span></div><div class="line">controlByCache：buffer：<span class="number">1000</span></div><div class="line">controlByCache：buffer：<span class="number">1002</span></div><div class="line">controlByCache：buffer：<span class="number">1001</span></div></pre></td></tr></table></figure></p>
<h4 id="背压操作符"><a href="#背压操作符" class="headerlink" title="背压操作符"></a>背压操作符</h4><p>　　RxJava1.x中，还有两种效果优于以上两种的操作符，可使不支持背压策略的操作符支持背压策略。</p>
<ul>
<li><strong>onBackpressureDrop</strong>：将observable发送的事件抛弃掉，直到subscriber再次调用request(n)方法的时候，就发送给它这之后的n个事件。</li>
<li><strong>onBackpressurebuffer</strong>：把observable发送出来的事件做缓存，当request(n)方法被调用的时候，给下层流发送一个item(如果给这个缓存区设置了大小，那么超过了这个大小就会抛出异常)。</li>
</ul>
<p>　　以onBackpressureDrop为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">Observable.interval(<span class="number">1</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .onBackpressureDrop()</div><div class="line">        .observeOn(Schedulers.newThread())</div><div class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Long&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">super</span>.onStart();</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"controlBySpecialOperator："</span> + <span class="string">"onStart"</span>);</div><div class="line">                request(<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"controlBySpecialOperator："</span> + <span class="string">"onCompleted"</span>);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"controlBySpecialOperator："</span> + <span class="string">"onError"</span>);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long aLong)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"controlBySpecialOperator：onNext："</span> + aLong);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">500</span>);</div><div class="line">                    request(<span class="number">1</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">controlBySpecialOperator：onStart</div><div class="line">controlBySpecialOperator：onNext：<span class="number">0</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">1</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">2</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">3</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">4</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">5</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">6</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">7</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">8</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">9</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">10</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">11</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">12</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">13</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">14</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">15</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">8014</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">8015</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">8016</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">8017</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">8018</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">8019</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">8020</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">8021</span></div><div class="line">controlBySpecialOperator：onNext：<span class="number">8022</span></div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>　　首先输出了0-15的数据，是因为observeOn操作符内部有一个长度为16的缓存区，它会首先请求16个事件缓存起来再输出。使用onBackpressureDrop可使不支持背压的操作符也可响应观察者的request(n)。<br>　　<strong>注意：需调用<code>.onBackpressureDrop()</code>方法。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　以上就是本篇关于RxJava1中存在的背压问题，背压策略的使用方法以及其他解决方法的讲解。背压在实际开发中遇到的不多，除非是大量数据，所以各位码友了解一下就好。本篇旨在为引入正式的Rxjava2做一个铺垫，敬请期待下一篇。<br>　　进阶中的码猿一枚，写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。<br>　　附上RxJavaDemo的地址：<br>　　<a href="https://github.com/LeiHolmes/RxJavaDemo" target="_blank" rel="external">RxJavaDemo</a>
　　</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;　　通过前7篇RxJava的文章，我们对RxJava1.x版本的内容进行了学习与实践。目前RxJava已经更新到2.x了，有小伙伴问我为什么不直接上RxJava2的教程？RxJava2是在1的基础上进行了更新与优化，有很多相通之处，初学者的话建议还是先从RxJava1的基础理论一步步学习。&lt;br&gt;　　本系列主要通过与RxJava1比较来学习RxJava2都有哪些改变。而RxJava2中最大的优化之处就在于它解决了RxJava1中未能有效解决的背压(Backpressure)问题。本篇我们就来看看什么是背压，以及RxJava1中是如何解决这个问题。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="RxJava2" scheme="http://LeiHolmes.github.io/tags/RxJava2/"/>
    
  </entry>
  
  <entry>
    <title>RxJava终章之实践出真知(七)</title>
    <link href="http://LeiHolmes.github.io/2017/10/20/RxJava%E7%BB%88%E7%AB%A0%E4%B9%8B%E5%AE%9E%E8%B7%B5%E5%87%BA%E7%9C%9F%E7%9F%A5(%E4%B8%83)/"/>
    <id>http://LeiHolmes.github.io/2017/10/20/RxJava终章之实践出真知(七)/</id>
    <published>2017-10-19T16:00:00.000Z</published>
    <updated>2017-11-26T11:03:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　到本阶段，相信各位码友对RxJava的原理及操作符的使用方法已经基本掌握了。只是了解理论知识对于咱们程序猴来说当然远远不够，理论运用到实践才能出真知。一起来律动指尖到实际场景中看看怎么运用RxJava。本篇我们演示一下如何运用RxJava从手机中获取已安装的第三方应用并通过RecyclerView展示出来。<br>　　<a id="more"></a></p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="项目下build-gradle"><a href="#项目下build-gradle" class="headerlink" title="项目下build.gradle"></a>项目下build.gradle</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    ......</div><div class="line">    dependencies &#123;</div><div class="line">        classpath 'com.android.tools.build:gradle:2.3.2'</div><div class="line">        //ButterKnife支持</div><div class="line">        classpath 'com.jakewharton:butterknife-gradle-plugin:8.7.0'</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">......</div></pre></td></tr></table></figure>
<h4 id="app下build-gradle"><a href="#app下build-gradle" class="headerlink" title="app下build.gradle"></a>app下build.gradle</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">apply plugin: 'com.android.application'</div><div class="line">apply plugin: 'com.jakewharton.butterknife'</div><div class="line"></div><div class="line">android &#123;</div><div class="line">    ......</div><div class="line">    defaultConfig &#123;</div><div class="line">        ......</div><div class="line">        //Lambda支持</div><div class="line">        jackOptions &#123;</div><div class="line">            enabled true</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //Lambda支持</div><div class="line">    compileOptions &#123;</div><div class="line">        sourceCompatibility JavaVersion.VERSION_1_8</div><div class="line">        targetCompatibility JavaVersion.VERSION_1_8</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    ......</div><div class="line">    //RxJava支持</div><div class="line">    compile 'io.reactivex:rxjava:1.0.14'</div><div class="line">    compile 'io.reactivex:rxandroid:1.0.1'</div><div class="line">    //RecyclerView支持</div><div class="line">    compile 'com.android.support:recyclerview-v7:25.3.1'</div><div class="line">    //ButterKnife支持</div><div class="line">    compile 'com.jakewharton:butterknife:8.7.0'</div><div class="line">    annotationProcessor 'com.jakewharton:butterknife-compiler:8.7.0'</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><h4 id="主布局"><a href="#主布局" class="headerlink" title="主布局"></a>主布局</h4><p>　　主布局没啥好说的，就是一个RecyclerView。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">tools:context</span>=<span class="string">"com.holmeslei.rxjavademo.ui.PracticeActivity&gt;</span></div><div class="line">    </div><div class="line">    &lt;android.support.v7.widget.RecyclerView</div><div class="line">        android:id="@+<span class="attr">id</span>/<span class="attr">rv_app_list</span>"</div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="RecyclerView的Item布局"><a href="#RecyclerView的Item布局" class="headerlink" title="RecyclerView的Item布局"></a>RecyclerView的Item布局</h4><p>　　RecyclerView单个条目布局，我们需要一个ImageView及一个TextView用来展示每个应用的图标及名称。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">RelativeLayout</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"80dp"</span></div><div class="line">        <span class="attr">android:paddingLeft</span>=<span class="string">"20dp"</span>&gt;</div><div class="line">        </div><div class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/item_iv_head"</span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"50dp"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"50dp"</span></div><div class="line">            <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></div><div class="line">            <span class="attr">android:scaleType</span>=<span class="string">"fitXY"</span></div><div class="line">            <span class="attr">android:src</span>=<span class="string">"@mipmap/ic_launcher"</span> /&gt;</div><div class="line">        </div><div class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/item_iv_app_name"</span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">            <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></div><div class="line">            <span class="attr">android:layout_marginLeft</span>=<span class="string">"30dp"</span></div><div class="line">            <span class="attr">android:layout_toRightOf</span>=<span class="string">"@+id/item_iv_head"</span></div><div class="line">            <span class="attr">android:text</span>=<span class="string">"微信"</span></div><div class="line">            <span class="attr">android:textColor</span>=<span class="string">"#555555"</span></div><div class="line">            <span class="attr">android:textSize</span>=<span class="string">"18sp"</span> /&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInfo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String appName; <span class="comment">//应用名称</span></div><div class="line">    <span class="keyword">private</span> Drawable appIcon; <span class="comment">//应用图标</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAppName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> appName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppName</span><span class="params">(String appName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.appName = appName;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> Drawable <span class="title">getAppIcon</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> appIcon;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppIcon</span><span class="params">(Drawable appIcon)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.appIcon = appIcon;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"AppInfo&#123;"</span> +</div><div class="line">                <span class="string">"appName='"</span> + appName + <span class="string">'\''</span> +</div><div class="line">                <span class="string">", appIcon="</span> + appIcon +</div><div class="line">                <span class="string">'&#125;'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="RecyclerView适配器"><a href="#RecyclerView适配器" class="headerlink" title="RecyclerView适配器"></a>RecyclerView适配器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInfoListAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">AppInfoListAdapter</span>.<span class="title">MyViewHolder</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> Context context;</div><div class="line">    <span class="keyword">private</span> List&lt;AppInfo&gt; appInfoList;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppInfoListAdapter</span><span class="params">(Context context, List&lt;AppInfo&gt; appInfoList)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.context = context;</div><div class="line">        <span class="keyword">this</span>.appInfoList = appInfoList;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> MyViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</div><div class="line">        View view = LayoutInflater.from(context).inflate(R.layout.item_app_list, parent, <span class="keyword">false</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyViewHolder(view);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(MyViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        <span class="comment">//设置应用图标</span></div><div class="line">        holder.ivHead.setImageDrawable(appInfoList.get(position).getAppIcon());</div><div class="line">        <span class="comment">//设置应用名称</span></div><div class="line">        holder.tvAppName.setText(appInfoList.get(position).getAppName());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> appInfoList.size();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</div><div class="line">        <span class="meta">@BindView</span>(R.id.item_iv_head)</div><div class="line">        ImageView ivHead;</div><div class="line">        <span class="meta">@BindView</span>(R.id.item_iv_app_name)</div><div class="line">        TextView tvAppName;</div><div class="line">        </div><div class="line">        MyViewHolder(View itemView) &#123;</div><div class="line">            <span class="keyword">super</span>(itemView);</div><div class="line">            ButterKnife.bind(<span class="keyword">this</span>, itemView);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h4><p>　　核心来了，我们重点看initData()方法。分析一下需求，要获取手机中已安装的第三方应用并展示出来，主要分以下几步：</p>
<p>　　1. 从系统中获取所有应用列表数据的集合<code>List&lt;ApplicationInfo&gt;</code>。<br>　　2. 这个集合是已安装的所有应用集合，我们只需要其中的第三方应用，所以要使用到RxJava的filter操作符进行过滤。<br>　　3. 由于ApplicationInfo不满足我们的需求，需要将其转换为我们自定义的实体类AppInfo，所以要使用到RxJava的map操作符进行转换。<br>　　4. 由于获取应用集合，过滤，转换的过程可能是耗时的，我们需要指定Observable运行在io线程。<br>　　5. 由于获取到满足条件的数据后我们还需刷新UI进行展示，所以还需要指定Observer运行在Android的UI线程。<br>　　6. 最后还需要输出错误日志，及完成之后的刷新UI，所以需要重写RxJava错误状态及完成状态的回调方法。<br>　　了解的整个实现流程，接下来上代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PracticeActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">    <span class="meta">@BindView</span>(R.id.rv_app_list)</div><div class="line">    RecyclerView rvAppList;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> AppInfoListAdapter adapter;</div><div class="line">    <span class="keyword">private</span> List&lt;AppInfo&gt; appInfoList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_practice);</div><div class="line">        ButterKnife.bind(<span class="keyword">this</span>);</div><div class="line">        initRecyclerView();</div><div class="line">        initData();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 初始化RecyclerView</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initRecyclerView</span><span class="params">()</span> </span>&#123;</div><div class="line">        LinearLayoutManager manager = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);</div><div class="line">        rvAppList.setLayoutManager(manager);</div><div class="line">        adapter = <span class="keyword">new</span> AppInfoListAdapter(<span class="keyword">this</span>, appInfoList);</div><div class="line">        rvAppList.setAdapter(adapter);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 初始化数据</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> PackageManager pm = getPackageManager();</div><div class="line">        <span class="comment">//获取所有应用信息集合</span></div><div class="line">        List&lt;ApplicationInfo&gt; infoList = pm.getInstalledApplications(PackageManager.GET_UNINSTALLED_PACKAGES);</div><div class="line">        Observable.from(infoList)</div><div class="line">        <span class="comment">//过滤出已安装的第三方应用</span></div><div class="line">        .filter(<span class="keyword">new</span> Func1&lt;ApplicationInfo, Boolean&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(ApplicationInfo applicationInfo)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> (applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) &lt;= <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        <span class="comment">//转换为自定义的AppInfo类</span></div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;ApplicationInfo, AppInfo&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> AppInfo <span class="title">call</span><span class="params">(ApplicationInfo applicationInfo)</span> </span>&#123;</div><div class="line">                AppInfo appInfo = <span class="keyword">new</span> AppInfo();</div><div class="line">                appInfo.setAppIcon(applicationInfo.loadIcon(pm));</div><div class="line">                appInfo.setAppName(applicationInfo.loadLabel(pm).toString());</div><div class="line">                <span class="keyword">return</span> appInfo;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        <span class="comment">//Observable被观察者执行在io线程</span></div><div class="line">        .subscribeOn(Schedulers.io())</div><div class="line">        <span class="comment">//Observer观察者执行在AndroidUI线程</span></div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;AppInfo&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">//更新列表UI</span></div><div class="line">                adapter.notifyDataSetChanged();</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                <span class="comment">//显示错误信息</span></div><div class="line">                Toast.makeText(PracticeActivity.<span class="keyword">this</span>, e.getMessage(), </div><div class="line">                        Toast.LENGTH_LONG).show();</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(AppInfo appInfo)</span> </span>&#123;</div><div class="line">                <span class="comment">//添加第三方应用数据到集合</span></div><div class="line">                appInfoList.add(appInfo);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Lambda简化"><a href="#Lambda简化" class="headerlink" title="Lambda简化"></a>Lambda简化</h4><p>　　还记得我在RxJava系列第一篇中提到过吗？RxJava可结合Lambda表达式达到简化代码的作用，来看一下简化之后的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 初始化数据</div><div class="line"> */</div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> PackageManager pm = getPackageManager();</div><div class="line">    List&lt;ApplicationInfo&gt; infoList = pm.getInstalledApplications(PackageManager.GET_UNINSTALLED_PACKAGES);</div><div class="line">    Observable.from(infoList)</div><div class="line">            .filter(applicationInfo -&gt; (applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) &lt;= <span class="number">0</span>)</div><div class="line">            .map(applicationInfo -&gt; &#123;</div><div class="line">                AppInfo appInfo = <span class="keyword">new</span> AppInfo();</div><div class="line">                appInfo.setAppIcon(applicationInfo.loadIcon(pm));</div><div class="line">                appInfo.setAppName(applicationInfo.loadLabel(pm).toString());</div><div class="line">                <span class="keyword">return</span> appInfo;</div><div class="line">            &#125;)</div><div class="line">            .subscribeOn(Schedulers.io())</div><div class="line">            .observeOn(AndroidSchedulers.mainThread())</div><div class="line">            .subscribe(</div><div class="line">                    appInfo -&gt; appInfoList.add(appInfo),</div><div class="line">                    throwable -&gt; Toast.makeText(PracticeActivity.<span class="keyword">this</span>, throwable.getMessage(), Toast.LENGTH_LONG).show(),</div><div class="line">                    () -&gt; adapter.notifyDataSetChanged()</div><div class="line">            );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　是不是看起来清爽简洁呢？不太了解Lambda表达式的码友可跳转到我的另一篇讲解Lambda表达式的文章：<br>　　<a href="http://xulei.tech/2017/07/24/Lambda表达式基本语法与应用/" target="_blank" rel="external">Lambda表达式基本语法与应用</a></p>
<h4 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h4><p><div align="center"><br><img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/92492226.jpg" alt=""></div></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　到此，RxJava系列从理论到运用再到实践，整个过程我们通过了7篇文章来学习。然而RxJava的知识远远不止这些，这就需要各位码友去探索发掘了。本系列只是达到入门RxJava的程度，且是基于RxJava1.0版本进行讲解的。目前RxJava已经更新到了2.0+，与1.0版本也有不小的改动与优化的地方。后期我会专门对RxJava2.x有何改动开一篇文章进行讲解，敬请期待。<br>　　技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。<br>　　附上RxJavaDemo的地址：<br>　　<a href="https://github.com/LeiHolmes/RxJavaDemo" target="_blank" rel="external">RxJavaDemo</a>
　　</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;　　到本阶段，相信各位码友对RxJava的原理及操作符的使用方法已经基本掌握了。只是了解理论知识对于咱们程序猴来说当然远远不够，理论运用到实践才能出真知。一起来律动指尖到实际场景中看看怎么运用RxJava。本篇我们演示一下如何运用RxJava从手机中获取已安装的第三方应用并通过RecyclerView展示出来。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="RxJava" scheme="http://LeiHolmes.github.io/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava操作符之组合操作符(六)</title>
    <link href="http://LeiHolmes.github.io/2017/10/18/RxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B%E7%BB%84%E5%90%88%E6%93%8D%E4%BD%9C%E7%AC%A6(%E5%85%AD)/"/>
    <id>http://LeiHolmes.github.io/2017/10/18/RxJava操作符之组合操作符(六)/</id>
    <published>2017-10-17T16:00:00.000Z</published>
    <updated>2017-11-26T11:00:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　上一篇文章我们学习了过滤类操作符，本篇我们将一起来学习RxJava组合类操作符。组合操作符主要是用来同时处理多个Observable，将他们进行组合创建出新的满足我们需求的Observable，一起来看下都有哪些。<br>　　<a id="more"></a></p>
<h3 id="组合操作符"><a href="#组合操作符" class="headerlink" title="组合操作符"></a>组合操作符</h3><h4 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h4><p>　　merge操作符，将两个Observable要发射的观测序列合并为一个序列进行发射。按照两个序列每个元素的发射时间先后进行排序，同一时间点发射的元素则是无序的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将一个发送字母的Observable与发送数字的Observable合并发射</span></div><div class="line"><span class="keyword">final</span> String[] words = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>&#125;;</div><div class="line"><span class="comment">//字母Observable，每200ms发射一次</span></div><div class="line">Observable&lt;String&gt; wordSequence = Observable.interval(<span class="number">200</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Long position)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> words[position.intValue()];</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .take(words.length);</div><div class="line"><span class="comment">//数字Observable，每500ms发射一次</span></div><div class="line">Observable&lt;Long&gt; numberSequence = Observable.interval(<span class="number">500</span>, TimeUnit.MILLISECONDS).take(<span class="number">4</span>);</div><div class="line">Observable.merge(wordSequence, numberSequence)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Serializable&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Serializable serializable)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"merge："</span> + serializable.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">merge：A</div><div class="line">merge：B</div><div class="line">merge：<span class="number">0</span></div><div class="line">merge：C</div><div class="line">merge：D</div><div class="line">merge：E</div><div class="line">merge：<span class="number">1</span></div><div class="line">merge：F</div><div class="line">merge：G</div><div class="line">merge：<span class="number">2</span></div><div class="line">merge：H</div><div class="line">merge：I</div><div class="line">merge：<span class="number">3</span></div></pre></td></tr></table></figure></p>
<p>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/34981159.jpg" alt=""><br></div><br>　　merge操作符还有一种入参merge(Observable[]),可传入含有多个Observable的集合，merge操作符也可将这多个Observable的序列合并后发射。</p>
<h4 id="MergeDelayError"><a href="#MergeDelayError" class="headerlink" title="MergeDelayError"></a>MergeDelayError</h4><p>　　mergeDelayError操作符，与merge功能类似，都是用来合并Observable的。不同之处在于mergeDelayError操作符在合并过程中发生异常的话不会立即停止合并，而会在所有元素合并发射完毕之后再发射异常。但发生异常的那个Observable就不会发射数据了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//字母Observable，每200ms发射一次，模拟过程中产生一个异常</span></div><div class="line">Observable&lt;String&gt; wordSequence = Observable.interval(<span class="number">200</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Long position)</span> </span>&#123;</div><div class="line">                Long cache = position;</div><div class="line">                <span class="keyword">if</span> (cache == <span class="number">3</span>) &#123;</div><div class="line">                    cache = cache / <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> words[position.intValue()];</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .take(words.length);</div><div class="line"><span class="comment">//数字Observable，每500ms发射一次</span></div><div class="line">Observable&lt;Long&gt; numberSequence = Observable.interval(<span class="number">500</span>, TimeUnit.MILLISECONDS).take(<span class="number">4</span>);</div><div class="line">Observable.mergeDelayError(wordSequence, numberSequence)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Serializable&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Serializable serializable)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"mergeDelayError："</span> + serializable.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable throwable)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"mergeDelayError："</span> + throwable.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="keyword">new</span> Action0() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"mergeDelayError：onComplete"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mergeDelayError：A</div><div class="line">mergeDelayError：B</div><div class="line">mergeDelayError：<span class="number">0</span></div><div class="line">mergeDelayError：C</div><div class="line">mergeDelayError：<span class="number">1</span></div><div class="line">mergeDelayError：<span class="number">2</span></div><div class="line">mergeDelayError：<span class="number">3</span></div><div class="line">mergeDelayError：divide by zero</div></pre></td></tr></table></figure></p>
<p>　　由输出结果可看出，wordSequence在发射到C时抛出了一个异常，停止发射其剩下的数据，但合并没有停止。合并完成之后这个异常才被发射了出来。<br>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/22362064.jpg" alt=""><br></div></p>
<h4 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h4><p>　　concat操作符，将多个Obserbavle发射的数据进行合并后发射，类似于merge操作符。但concat操作符是将Observable依次发射，是有序的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; wordSequence = Observable.just(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>);</div><div class="line">Observable&lt;Integer&gt; numberSequence = Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</div><div class="line">Observable&lt;String&gt; nameSequence = Observable.just(<span class="string">"Sherlock"</span>, <span class="string">"Holmes"</span>, <span class="string">"Xu"</span>, <span class="string">"Lei"</span>);</div><div class="line">Observable.concat(wordSequence, numberSequence, nameSequence)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Serializable&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Serializable serializable)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"concat："</span> + serializable.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">concat：A</div><div class="line">concat：B</div><div class="line">concat：C</div><div class="line">concat：D</div><div class="line">concat：E</div><div class="line">concat：<span class="number">1</span></div><div class="line">concat：<span class="number">2</span></div><div class="line">concat：<span class="number">3</span></div><div class="line">concat：<span class="number">4</span></div><div class="line">concat：<span class="number">5</span></div><div class="line">concat：Sherlo</div><div class="line">concat：Holmes</div><div class="line">concat：Xu</div><div class="line">concat：Lei</div></pre></td></tr></table></figure></p>
<p>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/78535296.jpg" alt=""><br></div></p>
<h4 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a>Zip</h4><p>　　zip(Observable, Observable, Func2)操作符，根据Func2中的call()方法规则合并两个Observable的数据项并发射。<br>　　<strong>注意：若其中一个Observable数据发送结束或出现异常后，另一个Observable也会停止发射数据。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; wordSequence = Observable.just(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>);</div><div class="line">Observable&lt;Integer&gt; numberSequence = Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</div><div class="line">Observable.zip(wordSequence, numberSequence, <span class="keyword">new</span> Func2&lt;String, Integer, String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String s, Integer integer)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> s + integer;</div><div class="line">    &#125;</div><div class="line">&#125;).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"rx_test"</span>, <span class="string">"zip："</span> + s);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">zip：A1</div><div class="line">zip：B2</div><div class="line">zip：C3</div><div class="line">zip：D4</div><div class="line">zip：E5</div></pre></td></tr></table></figure></p>
<p>　　由输出结果可看出numberSequence观测序列最后的6并没有发射出来，由于wordSequence观测序列已发射完所有数据，所以组合序列也停止发射数据了。<br>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/53904231.jpg" alt=""><br></div></p>
<h4 id="StartWith"><a href="#StartWith" class="headerlink" title="StartWith"></a>StartWith</h4><p>　　startWith操作符，用于在源Observable发射的数据前，插入指定的数据并发射。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</div><div class="line">        .startWith(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"startWith："</span> + integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">startWith：<span class="number">1</span></div><div class="line">startWith：<span class="number">2</span></div><div class="line">startWith：<span class="number">3</span></div><div class="line">startWith：<span class="number">4</span></div><div class="line">startWith：<span class="number">5</span></div><div class="line">startWith：<span class="number">6</span></div><div class="line">startWith：<span class="number">7</span></div></pre></td></tr></table></figure></p>
<p>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/87982565.jpg" alt=""><br></div><br>　　startWith还有两种入参：  </p>
<ul>
<li>startWith(Iterable<t>)：可在源Observable发射的数据前插入Iterable数据并发射。</t></li>
<li>startWith(Observable<t>)：可在源Observable发射的数据前插入另一Observable发射的数据并发射。</t></li>
</ul>
<h4 id="SwitchOnNext"><a href="#SwitchOnNext" class="headerlink" title="SwitchOnNext"></a>SwitchOnNext</h4><p>　　switchOnNext操作符，用来将一个发射多个小Observable的源Observable转化为一个Observable，然后发射多个小Observable所发射的数据。若小Observable正在发射数据时，源Observable又发射了新的小Observable，则前一个小Observable还未发射的数据会被抛弃，直接发射新的小Observable所发射的数据，上例子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//每隔500ms产生一个Observable</span></div><div class="line">Observable&lt;Observable&lt;Long&gt;&gt; observable = Observable.interval(<span class="number">500</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Long, Observable&lt;Long&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;Long&gt; <span class="title">call</span><span class="params">(Long aLong)</span> </span>&#123;</div><div class="line">                <span class="comment">//每隔200毫秒产生一组数据（0,10,20,30,40)</span></div><div class="line">                <span class="keyword">return</span> Observable.interval(<span class="number">200</span>, TimeUnit.MILLISECONDS)</div><div class="line">                        .map(<span class="keyword">new</span> Func1&lt;Long, Long&gt;() &#123;</div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">(Long aLong)</span> </span>&#123;</div><div class="line">                                <span class="keyword">return</span> aLong * <span class="number">10</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;).take(<span class="number">5</span>);</div><div class="line">                &#125;</div><div class="line">        &#125;).take(<span class="number">2</span>);</div><div class="line">        </div><div class="line">Observable.switchOnNext(observable)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Long&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Long aLong)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"switchOnNext："</span> + aLong);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">switchOnNext：<span class="number">0</span></div><div class="line">switchOnNext：<span class="number">10</span></div><div class="line">switchOnNext：<span class="number">0</span></div><div class="line">switchOnNext：<span class="number">10</span></div><div class="line">switchOnNext：<span class="number">20</span></div><div class="line">switchOnNext：<span class="number">30</span></div><div class="line">switchOnNext：<span class="number">40</span></div></pre></td></tr></table></figure></p>
<p>　　由输出结果发现第一个小Observable打印到10则停止了发射数据，说明其发射到10时，新的小Observable被创建了出来，第一个小Observable则被中断发射，开始发射新的小Observable的数据。<br>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/696529.jpg" alt=""><br></div></p>
<h4 id="CombineLatest"><a href="#CombineLatest" class="headerlink" title="CombineLatest"></a>CombineLatest</h4><p>　　combineLatest操作符，用于将两个Observale最近发射的数据以Func2函数的规则进行组合并发射。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//引用merge的例子</span></div><div class="line"><span class="keyword">final</span> String[] words = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>&#125;;</div><div class="line">Observable&lt;String&gt; wordSequence = Observable.interval(<span class="number">300</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Long position)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> words[position.intValue()];</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .take(words.length);</div><div class="line">Observable&lt;Long&gt; numberSequence = Observable.interval(<span class="number">500</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .take(<span class="number">5</span>);</div><div class="line">Observable.combineLatest(wordSequence, numberSequence,</div><div class="line">        <span class="keyword">new</span> Func2&lt;String, Long, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String s, Long aLong)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> s + aLong;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Serializable&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Serializable serializable)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"combineLatest："</span> + serializable.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">combineLatest：A0</div><div class="line">combineLatest：B0</div><div class="line">combineLatest：C0</div><div class="line">combineLatest：C1</div><div class="line">combineLatest：D1</div><div class="line">combineLatest：E1</div><div class="line">combineLatest：E2</div><div class="line">combineLatest：F2</div><div class="line">combineLatest：F3</div><div class="line">combineLatest：G3</div><div class="line">combineLatest：H3</div><div class="line">combineLatest：H4</div><div class="line">combineLatest：I4</div></pre></td></tr></table></figure></p>
<p>　　如果将wordSequence与numberSequence的入参顺序互换，输出结果也会不同：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">combineLatest：<span class="number">0</span>A</div><div class="line">combineLatest：<span class="number">0</span>B</div><div class="line">combineLatest：<span class="number">0</span>C</div><div class="line">combineLatest：<span class="number">1</span>C</div><div class="line">combineLatest：<span class="number">1</span>D</div><div class="line">combineLatest：<span class="number">2</span>D</div><div class="line">combineLatest：<span class="number">2</span>E</div><div class="line">combineLatest：<span class="number">2F</span></div><div class="line">combineLatest：<span class="number">3F</span></div><div class="line">combineLatest：<span class="number">3</span>G</div><div class="line">combineLatest：<span class="number">3</span>H</div><div class="line">combineLatest：<span class="number">4</span>H</div><div class="line">combineLatest：<span class="number">4</span>I</div></pre></td></tr></table></figure></p>
<p>　　wordSequence每300ms发射一个字符，numberSequence每500ms发射一个数字。可能有些码友不知道这个输出结果怎么来的，这个操作符确实不太好理解。我们来看一下这个原理图就很清楚了。<br>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/11771389.jpg" alt=""><br></div></p>
<h4 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h4><p>　　join(Observable, Func1, Func1, Func2)操作符，类似于combineLatest操作符，用于将ObservableA与ObservableB发射的数据进行排列组合。但join操作符可以控制Observable发射的每个数据的生命周期，在每个发射数据的生命周期内，可与另一个Observable发射的数据按照一定规则进行合并，来看下join的几个入参。  </p>
<ul>
<li>Observable：需要与源Observable进行组合的目标Observable。</li>
<li>Func1：接收从源Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了源Obsrvable发射出来的数据的有效期；</li>
<li>Func1：接收目标Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了目标Obsrvable发射出来的数据的有效期；</li>
<li>Func2：接收从源Observable和目标Observable发射出来的数据，并将这两个数据按自定的规则组合后返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//产生字母的序列,周期为1000ms</span></div><div class="line">String[] words = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>&#125;;</div><div class="line">Observable&lt;String&gt; observableA = Observable.interval(<span class="number">1000</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Long aLong)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> words[aLong.intValue()];</div><div class="line">            &#125;</div><div class="line">        &#125;).take(<span class="number">8</span>);</div><div class="line"><span class="comment">//产0,1,2,3,4,5,6,7的序列,延时500ms发射,周期为1000ms</span></div><div class="line">Observable&lt;Long&gt; observableB = Observable.interval(<span class="number">500</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Long, Long&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">(Long aLong)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> aLong;</div><div class="line">            &#125;</div><div class="line">        &#125;).take(words.length);</div><div class="line"><span class="comment">//join</span></div><div class="line">observableA.join(observableB,</div><div class="line">        <span class="keyword">new</span> Func1&lt;String, Observable&lt;Long&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;Long&gt; <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">                <span class="comment">//ObservableA发射的数据有效期为600ms</span></div><div class="line">                <span class="keyword">return</span> Observable.timer(<span class="number">600</span>, TimeUnit.MILLISECONDS);</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="keyword">new</span> Func1&lt;Long, Observable&lt;Long&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;Long&gt; <span class="title">call</span><span class="params">(Long aLong)</span> </span>&#123;</div><div class="line">                <span class="comment">//ObservableB发射的数据有效期为600ms</span></div><div class="line">                <span class="keyword">return</span> Observable.timer(<span class="number">600</span>, TimeUnit.MILLISECONDS);</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="keyword">new</span> Func2&lt;String, Long, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String s, Long aLong)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> s + aLong;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"rx_test"</span>, <span class="string">"join："</span> + s);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>　　join操作符的组合方式类似于数学上的排列组合规则，以ObservableA为基准源Observable，按照其自身周期发射数据，且每个发射出来的数据都有其有效期。而ObservableB每发射出来一个数据，都与A发射出来的并且还在有效期内的数据按Func2函数中的规则进行组合，B发射出来的数据也有其有效期。最后再将结果发射给观察者进行处理。<br>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">join：A0</div><div class="line">join：A1</div><div class="line">join：B1</div><div class="line">join：B2</div><div class="line">join：C2</div><div class="line">join：C3</div><div class="line">join：D3</div><div class="line">join：D4</div><div class="line">join：E4</div><div class="line">join：E5</div><div class="line">join：F5</div><div class="line">join：F6</div><div class="line">join：G6</div><div class="line">join：G7</div><div class="line">join：H7</div></pre></td></tr></table></figure></p>
<p>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/21421274.jpg" alt=""><br></div></p>
<h4 id="GroupJoin"><a href="#GroupJoin" class="headerlink" title="GroupJoin"></a>GroupJoin</h4><p>　　groupJoin操作符，类似于join操作符，区别在于第四个参数Func2的传入函数不同，对join之后的结果包装了一层小的Observable，便于用户再次进行一些过滤转换等操作再发射给Observable。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">observableA.groupJoin(observableB,</div><div class="line">        <span class="keyword">new</span> Func1&lt;String, Observable&lt;Long&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;Long&gt; <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Observable.timer(<span class="number">600</span>, TimeUnit.MILLISECONDS);</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="keyword">new</span> Func1&lt;Long, Observable&lt;Long&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;Long&gt; <span class="title">call</span><span class="params">(Long aLong)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Observable.timer(<span class="number">600</span>, TimeUnit.MILLISECONDS);</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="keyword">new</span> Func2&lt;String, Observable&lt;Long&gt;, Observable&lt;String&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(<span class="keyword">final</span> String s, Observable&lt;Long&gt; longObservable)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> longObservable.map(<span class="keyword">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Long aLong)</span> </span>&#123;</div><div class="line">                        <span class="keyword">return</span> s + aLong;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Observable&lt;String&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Observable&lt;String&gt; stringObservable)</span> </span>&#123;</div><div class="line">                stringObservable.subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">                        Log.e(<span class="string">"rx_test"</span>, <span class="string">"groupJoin："</span> + s);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">groupJoin：A0</div><div class="line">groupJoin：A1</div><div class="line">groupJoin：B1</div><div class="line">groupJoin：B2</div><div class="line">groupJoin：C2</div><div class="line">groupJoin：C3</div><div class="line">groupJoin：D3</div><div class="line">groupJoin：D4</div><div class="line">groupJoin：E4</div><div class="line">groupJoin：E5</div><div class="line">groupJoin：F5</div><div class="line">groupJoin：F6</div><div class="line">groupJoin：G6</div><div class="line">groupJoin：G7</div><div class="line">groupJoin：H7</div></pre></td></tr></table></figure></p>
<p>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/19968711.jpg" alt=""><br></div></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　到此，本篇关于RxJava的常用组合类操作符就讲解完毕了。通过以上四篇文章对RxJava四类操作符的学习，相信大家已经基本掌握RxJava如何使用了。实践是检验真理的唯一标准，下一篇我们来一起上项目看看实践中如何使用RxJava。<br>　　技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。<br>　　附上RxJavaDemo的地址：<br>　　<a href="https://github.com/LeiHolmes/RxJavaDemo" target="_blank" rel="external">RxJavaDemo</a>
　　</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;　　上一篇文章我们学习了过滤类操作符，本篇我们将一起来学习RxJava组合类操作符。组合操作符主要是用来同时处理多个Observable，将他们进行组合创建出新的满足我们需求的Observable，一起来看下都有哪些。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="RxJava" scheme="http://LeiHolmes.github.io/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava操作符之过滤操作符(五)</title>
    <link href="http://LeiHolmes.github.io/2017/10/16/RxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E7%AC%A6(%E4%BA%94)/"/>
    <id>http://LeiHolmes.github.io/2017/10/16/RxJava操作符之过滤操作符(五)/</id>
    <published>2017-10-15T16:00:00.000Z</published>
    <updated>2017-11-26T10:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　上一篇文章我们学习了转换类操作符，本篇我们将一起来学习RxJava过滤类操作符。过滤操作符主要是用来对事件数据进行过滤与筛选，只返回满足条件的数据，一起来看下都有哪些。<br>　　<a id="more"></a></p>
<h3 id="过滤操作符"><a href="#过滤操作符" class="headerlink" title="过滤操作符"></a>过滤操作符</h3><h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>　　filter操作符，按照一定的约束条件过滤序列中我们不想要的数据，只返回满足条件的数据给观察者。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//结合flatmap，过滤出各小区中房源大小大于120平的房子</span></div><div class="line">Observable.from(communities)</div><div class="line">        .flatMap(<span class="keyword">new</span> Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;House&gt; <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Observable.from(community.getHouses());</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .filter(<span class="keyword">new</span> Func1&lt;House, Boolean&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> house.getSize() &gt; <span class="number">120f</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"filter：大于120平的房子："</span> + house.getCommunityName() + <span class="string">"小区，大小："</span> + house.getSize());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　由代码可见，我们需要new一个Func1对象给filter()，<code>Func1&lt;House, Boolean&gt;()</code>中第一个是由观测序列传入数据的类型，第二个是返回是否过滤的Boolean对象。满足filter()的条件则返回true，否则返回false。并将返回为true的数据发射给观察者。<br>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">filter：大于<span class="number">120</span>平的房子：东方花园小区，大小：<span class="number">144.8</span></div><div class="line">filter：大于<span class="number">120</span>平的房子：东方花园小区，大小：<span class="number">144.8</span></div><div class="line">filter：大于<span class="number">120</span>平的房子：马德里春天小区，大小：<span class="number">123.4</span></div><div class="line">filter：大于<span class="number">120</span>平的房子：马德里春天小区，大小：<span class="number">123.4</span></div><div class="line">filter：大于<span class="number">120</span>平的房子：帝豪家园小区，大小：<span class="number">188.7</span></div><div class="line">filter：大于<span class="number">120</span>平的房子：帝豪家园小区，大小：<span class="number">188.7</span></div><div class="line">filter：大于<span class="number">120</span>平的房子：帝豪家园小区，大小：<span class="number">188.7</span></div></pre></td></tr></table></figure></p>
<p>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/2358036.jpg" alt=""><br></div><br>　　实际项目开发中，filter操作符可用来过滤数据集合中的null值，方便实用。</p>
<h4 id="Take"><a href="#Take" class="headerlink" title="Take"></a>Take</h4><p>　　take(int count)操作符，可用来截取观测序列中前count个元素并发射。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//take：获取前两个小区名</span></div><div class="line">Observable.from(communities)</div><div class="line">        .take(<span class="number">2</span>)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Community&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"take：前两个小区："</span> + community.getCommunityName());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">take：前两个小区：东方花园</div><div class="line">take：前两个小区：马德里春天</div></pre></td></tr></table></figure></p>
<p>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/26419923.jpg" alt=""><br></div></p>
<h4 id="TakeLast"><a href="#TakeLast" class="headerlink" title="TakeLast"></a>TakeLast</h4><p>　　takeLast(int count)操作符，顾名思义，截取观测序列中后count个元素并发射。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//takeLast：获取后两个小区名</span></div><div class="line">Observable.from(communities)</div><div class="line">        .takeLast(<span class="number">2</span>)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Community&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"takeLast：后两个小区："</span> + community.getCommunityName());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">takeLast：后两个小区：马德里春天</div><div class="line">takeLast：后两个小区：帝豪家园</div></pre></td></tr></table></figure></p>
<p>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/22844457.jpg" alt=""><br></div></p>
<h4 id="TakeUntil"><a href="#TakeUntil" class="headerlink" title="TakeUntil"></a>TakeUntil</h4><p>　　takeUntil操作符有两种类型的入参。<br>　　<strong>1.takeUntil(Observable)</strong><br>　　订阅并开始发射原始Observable，同时监视我们提供的第二个Observable。如果第二个Observable发射了一项数据或者发射了一个终止通知，takeUntil()返回的Observable会停止发射原始Observable并终止。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//observableA每300ms发射一个Long型自增数据</span></div><div class="line"><span class="comment">//observableB每800ms发射一个Long型自增数据</span></div><div class="line">Observable&lt;Long&gt; observableA = Observable.interval(<span class="number">300</span>, TimeUnit.MILLISECONDS);</div><div class="line">Observable&lt;Long&gt; observableB = Observable.interval(<span class="number">800</span>, TimeUnit.MILLISECONDS);</div><div class="line">observableA.takeUntil(observableB)</div><div class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Long&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"takeUntil(Observable)："</span> + <span class="string">"onCompleted"</span>);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"takeUntil(Observable)：onError："</span> + e.getMessage());</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long aLong)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"takeUntil(Observable)：onNext："</span> + aLong);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">takeUntil(Observable)：onNext：<span class="number">0</span></div><div class="line">takeUntil(Observable)：onNext：<span class="number">1</span></div><div class="line">takeUntil(Observable)：onCompleted</div></pre></td></tr></table></figure></p>
<p>　　由输出结果可看出，订阅之后，observableA依次发射0，1之后就发射onCompleted标记停止了。这是由于observableA每300ms发射一次，当发射完1后，时间已过去600ms，到800ms时observableB开始发射数据，takeUntil起作用则中断了observableA的发射。<br>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/60486369.jpg" alt=""><br></div><br>　　<strong>2.takeUntil(Func1)</strong><br>　　通过传入的Func1中的call()方法判断是否中止发射数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//takeUntil：与flatmap结合过滤直到房价大于500时中断当前小Observable发射House</span></div><div class="line">Observable.from(communities)</div><div class="line">        .flatMap(<span class="keyword">new</span> Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;House&gt; <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Observable.from(community.getHouses());</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .takeUntil(<span class="keyword">new</span> Func1&lt;House, Boolean&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> house.getPrice() &gt; <span class="number">500</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"takeUntil：大于500时中断发射："</span> + house.getCommunityName() + <span class="string">"小区，房价："</span> + house.getPrice());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">takeUntil(Func1)：大于<span class="number">500</span>时中断发射：东方花园小区，房价：<span class="number">200</span></div><div class="line">takeUntil(Func1)：大于<span class="number">500</span>时中断发射：东方花园小区，房价：<span class="number">520</span></div></pre></td></tr></table></figure></p>
<p>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/8323248.jpg" alt=""><br></div></p>
<h4 id="TakeWhile"><a href="#TakeWhile" class="headerlink" title="TakeWhile"></a>TakeWhile</h4><p>　　takeWhile操作符，类似于takeUntil(Func1)，不过takeWhile()是当Observable发射的数据不满足条件时中止Observable的发射。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//takeWhile：当发射的数据等于3时中止发射</span></div><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">        .takeWhile(<span class="keyword">new</span> Func1&lt;Integer, Boolean&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> integer != <span class="number">3</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"takeWhile："</span> + integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">takeWhile：<span class="number">1</span></div><div class="line">takeWhile：<span class="number">2</span></div></pre></td></tr></table></figure></p>
<p>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/2831128.jpg" alt=""><br></div></p>
<h4 id="Skip"><a href="#Skip" class="headerlink" title="Skip"></a>Skip</h4><p>　　skip(int count)操作符，忽略发射观测序列的前count项数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//忽略前两个小区数据</span></div><div class="line">Observable.from(communities)</div><div class="line">        .skip(<span class="number">2</span>)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Community&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"skip：忽略前两个小区："</span> + community.getCommunityName());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">skip：忽略前两个小区：帝豪家园</div></pre></td></tr></table></figure></p>
<p>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/40616374.jpg" alt=""><br></div></p>
<h4 id="SkipLast"><a href="#SkipLast" class="headerlink" title="SkipLast"></a>SkipLast</h4><p>　　skipLast(int count)操作符，忽略发射观测序列的后count项数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//忽略后两个小区数据</span></div><div class="line">Observable.from(communities)</div><div class="line">        .skipLast(<span class="number">2</span>)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Community&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"skip：忽略后两个小区："</span> + community.getCommunityName());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">忽略后两个小区：东方花园</div></pre></td></tr></table></figure></p>
<p>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/15249504.jpg" alt=""><br></div></p>
<h4 id="SkipUntil"><a href="#SkipUntil" class="headerlink" title="SkipUntil"></a>SkipUntil</h4><p>　　skipUntil操作符，与takeUntil()相反。订阅并开始发射原始Observable，同时监视我们提供的第二个Observable。如果第二个Observable发射了一项数据或者发射了一个终止通知，skipUntil()返回的Observable才会开始发射数据，忽略之前的数据项。<br>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/34513260.jpg" alt=""><br></div></p>
<h4 id="SkipWhile"><a href="#SkipWhile" class="headerlink" title="SkipWhile"></a>SkipWhile</h4><p>　　skipWhile操作符，与takeWhile相反，当Observable发射的数据不满足条件时才开始发射数据，忽略之前的数据项。<br>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/82044029.jpg" alt=""><br></div></p>
<h4 id="Debounce"><a href="#Debounce" class="headerlink" title="Debounce"></a>Debounce</h4><p>　　debounce操作符有两种类型的入参。<br>　　<strong>1.debounce(long, TimeUnit)</strong><br>　　过滤由Observable发射的速率过快的数据，起到限流的作用。第一个参数为限流时间，第二个参数为时间单位。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Integer&gt; subscriber)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                subscriber.onNext(i);</div><div class="line">                Thread.sleep(i * <span class="number">100</span>); <span class="comment">//分别延时100，200，300，400，500......900ms发射数据</span></div><div class="line">            &#125;</div><div class="line">            subscriber.onCompleted();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;).subscribeOn(Schedulers.newThread())</div><div class="line">        .debounce(<span class="number">400</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"debounce："</span> + <span class="string">"onCompleted"</span>);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"debounce："</span> + integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">debounce：<span class="number">5</span></div><div class="line">debounce：<span class="number">6</span></div><div class="line">debounce：<span class="number">7</span></div><div class="line">debounce：<span class="number">8</span></div><div class="line">debounce：<span class="number">9</span></div><div class="line">debounce：onCompleted</div></pre></td></tr></table></figure></p>
<p>　　由输出结果可以看出由于设定限流时间为500ms，所以1-4并没有被发射而是被过滤了。<br>　　<strong>注意：如果源Observable产生的最后一个结果在限流时间内内调用了onCompleted，那么通过debounce操作符也会把这个结果提交给订阅者。</strong><br>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/78593551.jpg" alt=""><br></div><br>　　<strong>2.debounce(Func1)</strong><br>　　根据Func1的call方法中的函数来过滤。Func1中的中的call方法返回了一个临时的Observable，如果原始的Observable在发射一个新的数据时，上一个数据根据Func1的call方法生成的临时Observable还没结束，那么上一个数据就会被过滤掉。<br>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/50390060.jpg" alt=""><br></div></p>
<h4 id="Distinct"><a href="#Distinct" class="headerlink" title="Distinct"></a>Distinct</h4><p>　　<strong>1.distinct()</strong><br>　　只允许还没有发射过的数据通过，达到去除序列中重复项的作用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//去除重复数字</span></div><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>)</div><div class="line">        .distinct()</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"distinct：去重："</span> + integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">distinct：去重：<span class="number">1</span></div><div class="line">distinct：去重：<span class="number">2</span></div><div class="line">distinct：去重：<span class="number">3</span></div><div class="line">distinct：去重：<span class="number">4</span></div><div class="line">distinct：去重：<span class="number">5</span></div><div class="line">distinct：去重：<span class="number">6</span></div><div class="line">distinct：去重：<span class="number">7</span></div></pre></td></tr></table></figure></p>
<p>　　由输出结果可见有重复的2和6都被过滤了。<br>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/25236826.jpg" alt=""><br></div><br>　　<strong>2.distinct(Func1)</strong><br>　　根据Func1中的call方法进行去重，call方法会根据Observable发射的值生成一个Key，然后比较这个key来判断两个数据是否相同，如果判定为重复则会和distinct()一样过滤掉重复的数据项。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//根据某属性去重，去除各小区大小相同的房源</span></div><div class="line">Observable.from(communities)</div><div class="line">        .flatMap(<span class="keyword">new</span> Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;House&gt; <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Observable.from(community.getHouses());</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .distinct(<span class="keyword">new</span> Func1&lt;House, Float&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Float <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> house.getSize();</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"distinct(Func1)：去重："</span> + house.getCommunityName() + <span class="string">"小区，大小："</span> + house.getSize());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">distinct(Func1)：去重：东方花园小区，大小：<span class="number">105.6</span></div><div class="line">distinct(Func1)：去重：东方花园小区，大小：<span class="number">144.8</span></div><div class="line">distinct(Func1)：去重：马德里春天小区，大小：<span class="number">88.6</span></div><div class="line">distinct(Func1)：去重：马德里春天小区，大小：<span class="number">123.4</span></div><div class="line">distinct(Func1)：去重：帝豪家园小区，大小：<span class="number">188.7</span></div><div class="line">distinct(Func1)：去重：帝豪家园小区，大小：<span class="number">56.4</span></div></pre></td></tr></table></figure></p>
<h4 id="DistinctUntilChanged"><a href="#DistinctUntilChanged" class="headerlink" title="DistinctUntilChanged"></a>DistinctUntilChanged</h4><p>　　<strong>1.distinctUntilChanged()</strong><br>　　通过当前数据项与前一项是否相同来进行去重。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//向前去重复数据</span></div><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>)</div><div class="line">        .distinctUntilChanged()</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"distinctUntilChanged：向前去重："</span> + integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">distinctUntilChanged：向前去重：<span class="number">1</span></div><div class="line">distinctUntilChanged：向前去重：<span class="number">2</span></div><div class="line">distinctUntilChanged：向前去重：<span class="number">3</span></div><div class="line">distinctUntilChanged：向前去重：<span class="number">4</span></div><div class="line">distinctUntilChanged：向前去重：<span class="number">2</span></div><div class="line">distinctUntilChanged：向前去重：<span class="number">3</span></div><div class="line">distinctUntilChanged：向前去重：<span class="number">5</span></div></pre></td></tr></table></figure></p>
<p>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/30022923.jpg" alt=""><br></div><br>　　<strong>2.distinctUntilChanged(Func1)</strong><br>　　与distinct(Func1)类似，根据Func1中call方法产生一个key来判断相邻两个数据项是否相同。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//根据某属性向前去重，去除各小区名相同的房源</span></div><div class="line">Observable.from(communities)</div><div class="line">        .flatMap(<span class="keyword">new</span> Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;House&gt; <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Observable.from(community.getHouses())</div><div class="line">                .distinctUntilChanged(<span class="keyword">new</span> Func1&lt;House, String&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                        <span class="keyword">return</span> house.getCommunityName();</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"distinctUntilChanged(Func1)：向前去重："</span> + house.getCommunityName() + <span class="string">"小区，大小："</span> + house.getSize());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">distinctUntilChanged(Func1)：向前去重：东方花园小区，大小：<span class="number">105.6</span></div><div class="line">distinctUntilChanged(Func1)：向前去重：马德里春天小区，大小：<span class="number">88.6</span></div><div class="line">distinctUntilChanged(Func1)：向前去重：帝豪家园小区，大小：<span class="number">188.7</span></div></pre></td></tr></table></figure></p>
<h4 id="ElementAt"><a href="#ElementAt" class="headerlink" title="ElementAt"></a>ElementAt</h4><p>　　elementAt(int index)操作符，获取观测序列中第index项索引，并作为唯一数据发射给观察者，index索引从0开始。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.from(communities)</div><div class="line">        .elementAt(<span class="number">1</span>)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Community&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"elementAt：第二个小区："</span> + community.getCommunityName());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">elementAt：第二个小区：马德里春天</div></pre></td></tr></table></figure></p>
<p>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/22933000.jpg" alt=""><br></div></p>
<h4 id="First"><a href="#First" class="headerlink" title="First"></a>First</h4><p>　　<strong>1.first()</strong><br>　　只发射观测序列中的第一个数据项。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.from(communities)</div><div class="line">        .first()</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Community&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"first："</span> + community.getCommunityName());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">first：东方花园</div></pre></td></tr></table></figure></p>
<p>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/942504.jpg" alt=""><br></div><br>　　<strong>2.first(Func1)</strong><br>　　根据Func1中call方法的条件，发射符合条件的第一个数据项。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//过滤出第一个小区名为马德里春天的小区</span></div><div class="line">Observable.from(communities)</div><div class="line">        .first(<span class="keyword">new</span> Func1&lt;Community, Boolean&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"马德里春天"</span>.equals(community.getCommunityName());</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Community&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"first(Func1)："</span> + community.getCommunityName());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">first(Func1)：马德里春天</div></pre></td></tr></table></figure></p>
<h4 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h4><p>　　<strong>1.last()</strong><br>　　只发射观测序列中的最后一个数据项。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//发送最后一个数据项</span></div><div class="line">Observable.from(communities)</div><div class="line">        .last()</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Community&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"last："</span> + community.getCommunityName());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">last：帝豪家园</div></pre></td></tr></table></figure></p>
<p>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/42723733.jpg" alt=""><br></div><br>　　<strong>2.last(Func1)</strong><br>　　根据Func1中call方法的条件，发射符合条件的最后一个数据项。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//发送符合条件的最后一个数据项：过滤最后一个小区名为马德里春天的房源</span></div><div class="line">Observable.from(communities)</div><div class="line">        .flatMap(<span class="keyword">new</span> Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;House&gt; <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Observable.from(community.getHouses());</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .last(<span class="keyword">new</span> Func1&lt;House, Boolean&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"马德里春天"</span>.equals(house.getCommunityName());</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"last："</span> + house.getCommunityName() + <span class="string">"小区，大小："</span> + house.getSize());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">last：马德里春天小区，大小：<span class="number">88.6</span></div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　到此，本篇关于RxJava的常用过滤类操作符就讲解完毕了，下一篇我们将一起研究RxJava的四类操作符中的组合操作符都有哪些以及如何使用。<br>　　技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。<br>　　附上RxJavaDemo的地址：<br>　　<a href="https://github.com/LeiHolmes/RxJavaDemo" target="_blank" rel="external">RxJavaDemo</a>
　　</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;　　上一篇文章我们学习了转换类操作符，本篇我们将一起来学习RxJava过滤类操作符。过滤操作符主要是用来对事件数据进行过滤与筛选，只返回满足条件的数据，一起来看下都有哪些。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="RxJava" scheme="http://LeiHolmes.github.io/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava操作符之转换操作符(四)</title>
    <link href="http://LeiHolmes.github.io/2017/10/12/RxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6(%E5%9B%9B)/"/>
    <id>http://LeiHolmes.github.io/2017/10/12/RxJava操作符之转换操作符(四)/</id>
    <published>2017-10-11T16:00:00.000Z</published>
    <updated>2019-12-09T09:26:17.416Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　上一篇文章我们学习了创建类操作符，本篇我们将一起来学习RxJava转换类操作符。所谓转换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。下面来看下转换类操作符都有哪些及其使用场景。<br>　　<a id="more"></a></p>
<h3 id="初始化数据"><a href="#初始化数据" class="headerlink" title="初始化数据"></a>初始化数据</h3><p>　　还是使用系列第一篇的小区与房源的例子。先初始化假数据以便实践操作符时使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//小区实体</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Community</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String communityName; <span class="comment">//小区名称</span></div><div class="line">    <span class="keyword">private</span> List&lt;House&gt; houses; <span class="comment">//房源集合</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//房源实体</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> size; <span class="comment">//大小</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> floor; <span class="comment">//楼层</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price; <span class="comment">//总价</span></div><div class="line">    <span class="keyword">private</span> String decoration; <span class="comment">//装修程度</span></div><div class="line">    <span class="keyword">private</span> String communityName; <span class="comment">//小区名称</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> List&lt;Community&gt; communities;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</div><div class="line">    communities = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    List&lt;House&gt; houses1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">            houses1.add(<span class="keyword">new</span> House(<span class="number">105.6f</span>, i, <span class="number">200</span>, <span class="string">"简单装修"</span>, <span class="string">"东方花园"</span>));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            houses1.add(<span class="keyword">new</span> House(<span class="number">144.8f</span>, i, <span class="number">520</span>, <span class="string">"豪华装修"</span>, <span class="string">"东方花园"</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    communities.add(<span class="keyword">new</span> Community(<span class="string">"东方花园"</span>, houses1));</div><div class="line">    </div><div class="line">    List&lt;House&gt; houses2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">            houses2.add(<span class="keyword">new</span> House(<span class="number">88.6f</span>, i, <span class="number">166</span>, <span class="string">"中等装修"</span>, <span class="string">"马德里春天"</span>));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            houses2.add(<span class="keyword">new</span> House(<span class="number">123.4f</span>, i, <span class="number">321</span>, <span class="string">"精致装修"</span>, <span class="string">"马德里春天"</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    communities.add(<span class="keyword">new</span> Community(<span class="string">"马德里春天"</span>, houses2));</div><div class="line">    </div><div class="line">    List&lt;House&gt; houses3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">            houses3.add(<span class="keyword">new</span> House(<span class="number">188.7f</span>, i, <span class="number">724</span>, <span class="string">"豪华装修"</span>, <span class="string">"帝豪家园"</span>));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            houses3.add(<span class="keyword">new</span> House(<span class="number">56.4f</span>, i, <span class="number">101</span>, <span class="string">"普通装修"</span>, <span class="string">"帝豪家园"</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    communities.add(<span class="keyword">new</span> Community(<span class="string">"帝豪家园"</span>, houses3));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="转换操作符"><a href="#转换操作符" class="headerlink" title="转换操作符"></a>转换操作符</h3><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>　　map操作符，接收一个指定的Func1类型对象，然后将其应用到每一个由Observable发射的值上，进而将发射的值转换为我们期望的值。来看一下原理图与实例：</p>
<p><div align="center"><br>　　<img src="https://s2.ax1x.com/2019/12/09/Qw2c1P.png" alt=""><br></div><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将一组Integer转换成String</span></div><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Integer, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"This is "</span> + integer;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line"><span class="comment">//将Community集合转换为每一个Community并获取其name</span></div><div class="line">Observable.from(communities)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Community, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> community.getCommunityName();</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String communityName)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"小区名称为："</span> + communityName);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">This is <span class="number">1</span></div><div class="line">This is <span class="number">2</span></div><div class="line">This is <span class="number">3</span></div><div class="line">This is <span class="number">4</span></div><div class="line">This is <span class="number">5</span></div><div class="line">小区名称为：东方花园</div><div class="line">小区名称为：马德里春天</div><div class="line">小区名称为：帝豪家园</div></pre></td></tr></table></figure></p>
<p>　　由输出结果可看出，map操作符可用来进行数据的类型转换，拼接或者对集合进行遍历等1对1的转换。第一个例子中，<code>Func1&lt;Integer, String&gt;()</code>第一个参数是发射数据当前的类型，第二个参数是转换之后的数据类型。<code>Action1&lt;String&gt;</code>中参数也为发射数据转换之后的数据类型。<br>　　<strong>注意数据类型需对应准确，不要弄错了。</strong></p>
<h4 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h4><p>　　flatMap操作符，也是用来转换的，但与map操作符不同之处是，flatMap()返回的是Observable对象，且这个Observable对象并不是被直接发送到了 Subscriber的回调方法中。<br>　　这么说可能不易理解，我们来看小区与房的例子，现在有3个小区，如果我们想打印出这3个小区中所有房源的信息，通过RxJava要如何做到？按照之前学习的我们或许会这么实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Observable.from(communities)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Community&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                <span class="keyword">for</span> (House house : community.getHouses()) &#123;</div><div class="line">                    Log.e(<span class="string">"rx_test"</span>, <span class="string">"flatMap：小区名称："</span> + house.getCommunityName() </div><div class="line">                        + <span class="string">"，价格："</span> + house.getPrice() + <span class="string">"，楼层："</span> + house.getFloor());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　按照这种实现方法我们只可获取到每个小区这一层，想要获取小区中的房源还需进行一层for循环遍历，这就违背了RxJava的原则了。那么来看下flatMap()如何实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Observable.from(communities)</div><div class="line">        .flatMap(<span class="keyword">new</span> Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;House&gt; <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Observable.from(community.getHouses());</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"flatMap：小区名称："</span> + house.getCommunityName()</div><div class="line">                    + <span class="string">"，价格："</span> + house.getPrice() + <span class="string">"，楼层："</span> + house.getFloor());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　这样的代码是不是看起来舒心多了，再来看下flatMap()是如何实现的。<br>　　首先from()接收到小区集合communities后为其创建了一个Observable，依次将每个小区传递给flatMap()，flatMap()在每次接收到小区后会将其中包含的房源集合拿出来又创建了一个房源Observable，并激活这个房源Observable让其开始发射事件，之后返回给小区集合的Observable，最后小区集合的Observable再将这些事件统一交给Subscriber的回调方法去处理。<br>　　整个过程有两级Observable在运作，相当于将小区集合Observable这个初始对象<strong>铺平</strong>之后再通过统一路径分发下去，<strong>铺平</strong>这个工作就是flatMap所做的。<br>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">flatMap：小区名称：东方花园，价格：<span class="number">200</span>，楼层：<span class="number">0</span></div><div class="line">flatMap：小区名称：东方花园，价格：<span class="number">520</span>，楼层：<span class="number">1</span></div><div class="line">flatMap：小区名称：东方花园，价格：<span class="number">200</span>，楼层：<span class="number">2</span></div><div class="line">flatMap：小区名称：东方花园，价格：<span class="number">520</span>，楼层：<span class="number">3</span></div><div class="line">flatMap：小区名称：东方花园，价格：<span class="number">200</span>，楼层：<span class="number">4</span></div><div class="line">flatMap：小区名称：马德里春天，价格：<span class="number">166</span>，楼层：<span class="number">0</span></div><div class="line">flatMap：小区名称：马德里春天，价格：<span class="number">321</span>，楼层：<span class="number">1</span></div><div class="line">flatMap：小区名称：马德里春天，价格：<span class="number">166</span>，楼层：<span class="number">2</span></div><div class="line">flatMap：小区名称：马德里春天，价格：<span class="number">321</span>，楼层：<span class="number">3</span></div><div class="line">flatMap：小区名称：马德里春天，价格：<span class="number">166</span>，楼层：<span class="number">4</span></div><div class="line">flatMap：小区名称：帝豪家园，价格：<span class="number">724</span>，楼层：<span class="number">0</span></div><div class="line">flatMap：小区名称：帝豪家园，价格：<span class="number">101</span>，楼层：<span class="number">1</span></div><div class="line">flatMap：小区名称：帝豪家园，价格：<span class="number">724</span>，楼层：<span class="number">2</span></div><div class="line">flatMap：小区名称：帝豪家园，价格：<span class="number">101</span>，楼层：<span class="number">3</span></div><div class="line">flatMap：小区名称：帝豪家园，价格：<span class="number">724</span>，楼层：<span class="number">4</span></div></pre></td></tr></table></figure></p>
<p>　　由输出结果可看出这3个小区的所有房源信息都被依次打印了出来，但flatMap()有一个问题就是当数据量过大时可能会出现输出数据顺序交错的问题。<br>　　官方原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/40767949.jpg" alt=""><br></div></p>
<h4 id="ConcatMap"><a href="#ConcatMap" class="headerlink" title="ConcatMap"></a>ConcatMap</h4><p>　　concatMap操作符，与flatMap()功能类似。不同之处是concatMap()采用连接方式而不是合并方式，所以其发射的数据是严格按照顺序的，这就解决了flatMap()有可能发生数据交错的问题。<br>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/14751925.jpg" alt=""><br></div></p>
<h4 id="FlatMapIterable"><a href="#FlatMapIterable" class="headerlink" title="FlatMapIterable"></a>FlatMapIterable</h4><p>　　flatMapIterable操作符，也与flatMap()相似，不同之处在于flatMapIterable转化多个Observable是使用Iterable作为源数据的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Observable.from(communities)</div><div class="line">        .flatMapIterable(<span class="keyword">new</span> Func1&lt;Community, Iterable&lt;House&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Iterable&lt;House&gt; <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> community.getHouses();</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"rx_test"</span>, <span class="string">"flatMap：小区名称："</span> + house.getCommunityName()</div><div class="line">                    + <span class="string">"，价格："</span> + house.getPrice() + <span class="string">"，楼层："</span> + house.getFloor());</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h4 id="SwitchMap"><a href="#SwitchMap" class="headerlink" title="SwitchMap"></a>SwitchMap</h4><p>　　switchMap转换操作符，也与flatMap()相似，每当源Observable发射新数据项(Observable)时，它将取消订阅并停止监视之前那个数据项产生Observable，并开始监视当前发射的这一个。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Observable.from(communities)</div><div class="line">        .switchMap(<span class="keyword">new</span> Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;House&gt; <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Observable.from(community.getHouses());</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"flatMap：小区名称："</span> + house.getCommunityName()</div><div class="line">                    + <span class="string">"，价格："</span> + house.getPrice() + <span class="string">"，楼层："</span> + house.getFloor());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　如之前的例子，当数据量很大时，某一时刻，第一个小区所生成的小房源Observable正在发射数据，这时第二个小区所生成的小房源Observable被激活，则第一个小区的小Observable就会被取消订阅，其还未发射的数据也不在发射了。第二个小区小Observable开始发射数据，之后都同理。<br>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/88145166.jpg" alt=""><br></div></p>
<h4 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h4><p>　　scan操作符，对一个序列的数据应用一个函数，并将这个函数的结果发射出去作为下个数据应用函数时的第一个参数使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//例如：先输出1，再将1+2=3作为下个数据发出，3+3=6再作为下个数据发出，以此类推。</span></div><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">        .scan(<span class="keyword">new</span> Func2&lt;Integer, Integer, Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(Integer integer, Integer integer2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> integer + integer2;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"scan："</span> + integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">scan：<span class="number">1</span></div><div class="line">scan：<span class="number">3</span></div><div class="line">scan：<span class="number">6</span></div><div class="line">scan：<span class="number">10</span></div><div class="line">scan：<span class="number">15</span></div></pre></td></tr></table></figure></p>
<p>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/20732556.jpg" alt=""><br></div></p>
<h4 id="GroupBy"><a href="#GroupBy" class="headerlink" title="GroupBy"></a>GroupBy</h4><p>　　groupBy操作符，将原始Observable发射的数据按照key来拆分成一些小的Observable，然后这些小的Observable分别发射其所包含的的数据。通俗的说就是按照某个字段将数据进行分类再发射。<br>　　来看一个例子：有几个小区的多套房源数据，现在需要将其按照小区名称进行分类并输出。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">List&lt;House&gt; houseList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">houseList.add(<span class="keyword">new</span> House(<span class="number">105.6f</span>, <span class="number">1</span>, <span class="number">200</span>, <span class="string">"简单装修"</span>, <span class="string">"东方花园"</span>));</div><div class="line">houseList.add(<span class="keyword">new</span> House(<span class="number">144.8f</span>, <span class="number">3</span>, <span class="number">300</span>, <span class="string">"豪华装修"</span>, <span class="string">"马德里春天"</span>));</div><div class="line">houseList.add(<span class="keyword">new</span> House(<span class="number">88.6f</span>, <span class="number">2</span>, <span class="number">170</span>, <span class="string">"简单装修"</span>, <span class="string">"东方花园"</span>));</div><div class="line">houseList.add(<span class="keyword">new</span> House(<span class="number">123.4f</span>, <span class="number">1</span>, <span class="number">250</span>, <span class="string">"简单装修"</span>, <span class="string">"帝豪家园"</span>));</div><div class="line">houseList.add(<span class="keyword">new</span> House(<span class="number">144.8f</span>, <span class="number">6</span>, <span class="number">350</span>, <span class="string">"豪华装修"</span>, <span class="string">"马德里春天"</span>));</div><div class="line">houseList.add(<span class="keyword">new</span> House(<span class="number">105.6f</span>, <span class="number">4</span>, <span class="number">210</span>, <span class="string">"普通装修"</span>, <span class="string">"东方花园"</span>));</div><div class="line">houseList.add(<span class="keyword">new</span> House(<span class="number">188.7f</span>, <span class="number">3</span>, <span class="number">400</span>, <span class="string">"精致装修"</span>, <span class="string">"帝豪家园"</span>));</div><div class="line">houseList.add(<span class="keyword">new</span> House(<span class="number">88.6f</span>, <span class="number">2</span>, <span class="number">180</span>, <span class="string">"普通装修"</span>, <span class="string">"东方花园"</span>));</div><div class="line"><span class="comment">//根据小区名称进行分类</span></div><div class="line">Observable&lt;GroupedObservable&lt;String, House&gt;&gt; groupByCommunityNameObservable = Observable</div><div class="line">        .from(houseList)</div><div class="line">        .groupBy(<span class="keyword">new</span> Func1&lt;House, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="comment">//提供分类规则的key</span></div><div class="line">                <span class="keyword">return</span> house.getCommunityName();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">Observable.concat(groupByCommunityNameObservable) <span class="comment">//concat组合操作符，将多个Observable有序组合并发送，后期会详细讲解</span></div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"groupBy："</span> + <span class="string">"小区："</span> + house.getCommunityName() + <span class="string">"，价格："</span> + house.getPrice());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　创建一个新的Observable：groupByCommunityNameObservable，它将会发送一个带有GroupedObservable的序列（也就是指发送的数据项的类型为GroupedObservable）。GroupedObservable是一个特殊的Observable，它基于一个分组的key，在这个例子中的key就是小区名。<br>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">groupBy：小区：东方花园，价格：<span class="number">200</span></div><div class="line">groupBy：小区：东方花园，价格：<span class="number">170</span></div><div class="line">groupBy：小区：东方花园，价格：<span class="number">210</span></div><div class="line">groupBy：小区：东方花园，价格：<span class="number">180</span></div><div class="line">groupBy：小区：马德里春天，价格：<span class="number">300</span></div><div class="line">groupBy：小区：马德里春天，价格：<span class="number">350</span></div><div class="line">groupBy：小区：帝豪家园，价格：<span class="number">250</span></div><div class="line">groupBy：小区：帝豪家园，价格：<span class="number">400</span></div></pre></td></tr></table></figure></p>
<p>　　原理图：</p>
<p><div align="center"><br>　　<img src="http://ozpdwks0y.bkt.clouddn.com/17-11-26/36200858.jpg" alt=""><br></div></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　到此，本篇关于RxJava的常用转换类操作符就讲解完毕了，下一篇我们将一起研究RxJava的四类操作符中的过滤操作符都有哪些以及如何使用。<br>　　技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。<br>　　附上RxJavaDemo的地址：<br>　　<a href="https://github.com/LeiHolmes/RxJavaDemo" target="_blank" rel="external">RxJavaDemo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;　　上一篇文章我们学习了创建类操作符，本篇我们将一起来学习RxJava转换类操作符。所谓转换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。下面来看下转换类操作符都有哪些及其使用场景。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="RxJava" scheme="http://LeiHolmes.github.io/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava操作符之创建操作符(三)</title>
    <link href="http://LeiHolmes.github.io/2017/10/11/RxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%AC%A6(%E4%B8%89)/"/>
    <id>http://LeiHolmes.github.io/2017/10/11/RxJava操作符之创建操作符(三)/</id>
    <published>2017-10-10T16:00:00.000Z</published>
    <updated>2019-12-09T09:22:56.023Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　通过前两篇文章对于RxJava概念，原理及使用的学习，想必各位码友已经基本掌握RxJava的逻辑与功能了，那么从这篇文章开始我们来研究RxJava的各类操作符。<br>　　<a id="more"></a><br>　　什么是操作符？通过之前的学习，我们发现Observable负责发送事件，Observer负责接收事件，而这个过程中想要对事件数据做出修改就需要交给操作符来负责啦。主流RxJava中操作符主要分为三类：转换操作符，过滤操作符，组合操作符。而我个人将用来创建Observable的操作符归为了一个新类型。本篇我们就来看看常用的创建操作符都有哪些以及如何使用。</p>
<h3 id="创建操作符"><a href="#创建操作符" class="headerlink" title="创建操作符"></a>创建操作符</h3><h4 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h4><p>　　上一篇文章的例子中我们已经实践了create操作符如何使用了，这里我们介绍一种便捷的创建Observer的方式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            subscriber.onNext(<span class="string">"xulei"</span> + i);</div><div class="line">        &#125;</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"rx_test"</span>, <span class="string">"create:"</span> + s);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>　　subscribe()的入参使用Action1代替原来的Observer，只需重写一个call()方法，等同于原Observer中onNext()方法。如果需要onComplete与onError状态，还可以如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">.subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"rx_test"</span>, <span class="string">"create:"</span> + s);</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable throwable)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"rx_test"</span>, <span class="string">"onError:"</span> + throwable.getMessage());</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="keyword">new</span> Action0() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"rx_test"</span>, <span class="string">"onCompleted"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>　　使用new ActionX代替new Observer，代码是不是看起来更加灵活与简洁呢。</p>
<h4 id="Just"><a href="#Just" class="headerlink" title="Just"></a>Just</h4><p>　　just操作符可将某个或某些对象转化为Observable对象，并将其发射出去。参数可为一个或多个数字，字符串。也可为集合，数组，Iterate对象等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>).subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"rx_test"</span>, <span class="string">"just:数字："</span> + integer);</div><div class="line">        <span class="comment">//数字或者字符串都是单个发射多次</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">stringList.add(<span class="string">"Hello"</span>);</div><div class="line">stringList.add(<span class="string">"Ha"</span>);</div><div class="line">stringList.add(<span class="string">"RxJava"</span>);</div><div class="line">Observable.just(stringList).subscribe(<span class="keyword">new</span> Action1&lt;List&lt;String&gt;&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(List&lt;String&gt; strings)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"rx_test"</span>, <span class="string">"just:集合："</span> + strings.toString());</div><div class="line">        <span class="comment">//集合或数组是直接发射集合整体，不会拆分</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">just:数字：<span class="number">1</span></div><div class="line">just:数字：<span class="number">2</span></div><div class="line">just:数字：<span class="number">3</span></div><div class="line">just:数字：<span class="number">4</span></div><div class="line">just:数字：<span class="number">5</span></div><div class="line">just:数字：<span class="number">6</span></div><div class="line">just:集合：[Hello, Ha, RxJava]</div></pre></td></tr></table></figure></p>
<h4 id="From"><a href="#From" class="headerlink" title="From"></a>From</h4><p>　　from操作符可将某个对象转化为Observable对象，并且将其发射出去。不同于just，他接收集合或数组，并可将集合数组遍历之后拆分发送。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">stringList.add(<span class="string">"Hello"</span>);</div><div class="line">stringList.add(<span class="string">"Ha"</span>);</div><div class="line">stringList.add(<span class="string">"RxJava"</span>);</div><div class="line">Observable.from(stringList).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"rx_test"</span>, <span class="string">"from："</span> + s);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from：Hello</div><div class="line">from：Ha</div><div class="line">from：RxJava</div></pre></td></tr></table></figure></p>
<h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p>　　range(int start, int count)操作符，根据初始值start，与数量count，发射count次以start为基数依次增加的值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.range(<span class="number">4</span>, <span class="number">5</span>).subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"rx_test"</span>, <span class="string">"range："</span> + integer);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">range：<span class="number">4</span></div><div class="line">range：<span class="number">5</span></div><div class="line">range：<span class="number">6</span></div><div class="line">range：<span class="number">7</span></div><div class="line">range：<span class="number">8</span></div></pre></td></tr></table></figure></p>
<h4 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h4><p>　　defer操作符功能类似于just操作符，不同之处在于defer只有在调用subscribe()方法进行订阅时才创建Observable，而just操作符在初始化Observable就已经创建了，且只创建一个Observable实例。这里我们通过与just对比进行实践。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Action1&lt;String&gt; action1 = <span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"rx_test"</span>, s);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//defer</span></div><div class="line">Observable&lt;String&gt; deferObservable = Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;String&gt;&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">        Object o = <span class="keyword">new</span> Object();</div><div class="line">        <span class="keyword">return</span> Observable.just(<span class="string">"defer：hashCode："</span> + o.hashCode());</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">deferObservable.subscribe(action1);</div><div class="line">deferObservable.subscribe(action1);</div><div class="line">deferObservable.subscribe(action1);</div><div class="line"></div><div class="line"><span class="comment">//just</span></div><div class="line">Observable&lt;String&gt; justObservable = Observable.just(<span class="string">"just：hashCode："</span> + <span class="keyword">new</span> Object().hashCode());</div><div class="line">justObservable.subscribe(action1);</div><div class="line">justObservable.subscribe(action1);</div><div class="line">justObservable.subscribe(action1);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">defer：hashCode：<span class="number">112449879</span></div><div class="line">defer：hashCode：<span class="number">118897732</span></div><div class="line">defer：hashCode：<span class="number">191664429</span></div><div class="line">just：hashCode：<span class="number">121878114</span></div><div class="line">just：hashCode：<span class="number">121878114</span></div><div class="line">just：hashCode：<span class="number">121878114</span></div></pre></td></tr></table></figure></p>
<p>　　由输出结果我们可以看出defer每次输出的Observable哈西值是不同的，说明其每subscribe订阅一次都会创建一个新的Observable，从而可保证Observable中的数据都是最新的。而just只有初始化的时候创建一次Observable。</p>
<h4 id="Interval"><a href="#Interval" class="headerlink" title="Interval"></a>Interval</h4><p>　　interval创建操作符，创建一个Observabel并每隔一段时间周期发射一个由0开始增加的数字。<br>　　<strong>注意：此Observabel是运行在新的线程，所以更新UI需要在主线程中订阅</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//每隔100ms发射一个数字,从0自增</span></div><div class="line">Observable.interval(<span class="number">100</span>, TimeUnit.MILLISECONDS) <span class="comment">//单位为毫秒</span></div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        .take(<span class="number">5</span>) <span class="comment">//取前5次事件发射，take为过滤操作符，后期会详细讲</span></div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Long&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Long aLong)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"interval："</span> + aLong);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">100</span>ms后...</div><div class="line">interval：<span class="number">0</span></div><div class="line"><span class="number">100</span>ms后...</div><div class="line">interval：<span class="number">1</span></div><div class="line"><span class="number">100</span>ms后...</div><div class="line">interval：<span class="number">2</span></div><div class="line"><span class="number">100</span>ms后...</div><div class="line">interval：<span class="number">3</span></div><div class="line"><span class="number">100</span>ms后...</div><div class="line">interval：<span class="number">4</span></div></pre></td></tr></table></figure></p>
<h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>　　timer操作符，创建一个Observable并隔一段时间后发射一个特殊的值，仅发射一次。<br>　　<strong>注意：此Observabel是运行在新的线程，所以更新UI需要在主线程中订阅</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//隔1s后发射一个数字</span></div><div class="line">Observable.timer(<span class="number">1</span>, TimeUnit.SECONDS) <span class="comment">//单位为秒</span></div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Long&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Long aLong)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"timer："</span> + aLong);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>秒后...</div><div class="line">timer：<span class="number">0</span></div></pre></td></tr></table></figure></p>
<h4 id="Delay"><a href="#Delay" class="headerlink" title="Delay"></a>Delay</h4><p>　　delay操作符，可用于延迟一定时长再发送事件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//延迟2秒后发射事件</span></div><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">        .delay(<span class="number">2</span>, TimeUnit.SECONDS)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"delay："</span> + integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>秒后...</div><div class="line">delay：<span class="number">1</span></div><div class="line">delay：<span class="number">2</span></div><div class="line">delay：<span class="number">3</span></div></pre></td></tr></table></figure></p>
<h4 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h4><p>　　repeat(long count)操作符，将Observable重复发射count次。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//重复发射5次“Sherlock”</span></div><div class="line">Observable.just(<span class="string">"Sherlock"</span>).repeat(<span class="number">5</span>)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"rx_test"</span>, <span class="string">"repeat："</span> + s);</div><div class="line">            &#125;</div><div class="line">     &#125;);</div></pre></td></tr></table></figure></p>
<p>　　输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">repeat：Sherlock</div><div class="line">repeat：Sherlock</div><div class="line">repeat：Sherlock</div><div class="line">repeat：Sherlock</div><div class="line">repeat：Sherlock</div></pre></td></tr></table></figure></p>
<p>　　以上就是常用的一些创建操作符，类似但不常用的还有empty、never、error等等就不一一介绍了，有兴趣的码友可以自行百度。</p>
<h3 id="线程调度Scheduler"><a href="#线程调度Scheduler" class="headerlink" title="线程调度Scheduler"></a>线程调度Scheduler</h3><p>　　RxJava就是用来处理异步任务的，所以就牵扯到生产事件所在线程，处理事件所在线程的问题，下面来看一下RxJava提供的线程调度Scheduler都有哪些。</p>
<p><div align="center"><br>　　<img src="https://s2.ax1x.com/2019/12/09/Qw2eS0.png" alt=""><br></div><br>　　有了Scheduler，RxJava当然也提供了方法来使用它们。<br>　　<strong>.subscribeOn()</strong>指定被观察者Observable的执行线程。<br>　　<strong>.observeOn()</strong>指定观察者Observer的执行线程。<br>　　如第一篇文章中的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取要查询的小区集合</span></div><div class="line">Observable.from(getCommunitiesFromServer())</div><div class="line">        .flatMap(<span class="keyword">new</span> Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;House&gt; <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Observable.from(community.getHouses());</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .filter(<span class="keyword">new</span> Func1&lt;House, Boolean&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> house.getPrice() &lt; <span class="number">200</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="comment">//显示查询出来的房源信息</span></div><div class="line">                ShowSearchedHousesMessage();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　其中<code>.subscribeOn(Schedulers.io())</code>指定了Observable在io线程运行，通常用来执行从服务器获取数据，数据库加载等耗时操作。<code>.observeOn(AndroidSchedulers.mainThread())</code>指定了Observer在Android环境下的UI线程运行，通常用来获取到数据后进行UI刷新的操作。可根据实际需求选择不同线程类型。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　到此，本篇关于RxJava的创建类操作符以及线程调度就讲解完毕了，下一篇我们将一起研究RxJava的四类操作符中的转换操作符都有哪些以及如何使用。<br>　　技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。<br>　　附上RxJavaDemo的地址：<br>　　<a href="https://github.com/LeiHolmes/RxJavaDemo" target="_blank" rel="external">RxJavaDemo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;　　通过前两篇文章对于RxJava概念，原理及使用的学习，想必各位码友已经基本掌握RxJava的逻辑与功能了，那么从这篇文章开始我们来研究RxJava的各类操作符。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="RxJava" scheme="http://LeiHolmes.github.io/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava基本原理与使用(二)</title>
    <link href="http://LeiHolmes.github.io/2017/09/28/RxJava%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8(%E4%BA%8C)/"/>
    <id>http://LeiHolmes.github.io/2017/09/28/RxJava基本原理与使用(二)/</id>
    <published>2017-09-27T16:00:00.000Z</published>
    <updated>2019-12-09T09:18:52.162Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　上一篇我们了解了RxJava的介绍以及通过一个例子学习了RxJava的展现形式，相信大家现在已经对RxJava有一个初步的印象与概念了。本篇我们将更深入的学习RxJava的基本原理以及如何使用RxJava。<br>　　<a id="more"></a></p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>　　上一篇有提到RxJava的核心便是扩展的观察者模式，我们先来学习一下观察者模式。  </p>
<p><div align="center"><br>　　<img src="https://s2.ax1x.com/2019/12/09/Qw2VWq.jpg" alt=""><br></div><br>　　事件：小明按下遥控器开关，空调启动并开始吹风了。按下制冷按键，空调吹出的风变为凉风。再按下3档风速按键，空调吹的风变大了。<br>　　在这个事件中，<strong>空调作为观察者，遥控器作为被观察者，空调通过红外线检测遥控器传来的信号并作出响应。</strong>  </p>
<p><div align="center"><br>　　<img src="https://s2.ax1x.com/2019/12/09/Qw2MmF.png" alt=""><br></div><br>　　通过上图我们可以很清晰的看出遥控器作为事件的生产方<strong>主动</strong>发起事件，是事件的起点，而空调作为事件的处理方<strong>被动</strong>接收事件做出响应，是事件的终点。而在事件传递的过程中可对事件进行过滤，转换，合并等操作，就像例子中制冷与加大风速的效果。<br>　　这个概念是RxJava中的核心，它是基于观察者模式来组建自己的程序逻辑，遥控器就相当于RxJava的<strong>被观察者Observable</strong>，空调相当于<strong>观察者Observer</strong>，而对事件处理的一些操作相当于各类<strong>操作符</strong>。不同的是RxJava中观察者需要对被观察者进行订阅，这样当被观察者发出事件时，观察者才会接收到事件进行处理。若未进行订阅，被观察者是不会发出任何事件的。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>　　了解了观察者模式，接下来动起指尖尝试下怎么使用RxJava。</p>
<h4 id="创建被观察者Observable"><a href="#创建被观察者Observable" class="headerlink" title="创建被观察者Observable"></a>创建被观察者Observable</h4><p>　　第一步：创建被观察者Observable：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Object&gt; observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Object&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Object&gt; subscriber)</span> </span>&#123;</div><div class="line">        <span class="comment">//被观察者的数据操作更新</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</div><div class="line">            subscriber.onNext(<span class="string">"xulei"</span> + i);</div><div class="line">        &#125;</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>　　通过<code>Observable.create()</code>方法创建并返回一个Observable对象，create()方法需要一个OnSubsribe对象作为参数传入并执行call()方法。此OnSubsribe对象继承自Action1。<br>　　而在call()方法中可通过<code>subscriber.onNext()</code>进行事件的发送，<code>subscriber.onCompleted()</code>标记为事件发送完毕。<code>subscriber.onError()</code>标记为事件发送过程出现异常。<br>　　除create()方法创建Observable方式外，还可以使用just()与from()等方式，这个在之后的创建操作符文章中会有讲解。</p>
<h4 id="创建观察者Observer"><a href="#创建观察者Observer" class="headerlink" title="创建观察者Observer"></a>创建观察者Observer</h4><p>　　第二步：创建观察者Observer：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Observer observer = <span class="keyword">new</span> Observer() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123; <span class="comment">//标记事件发送完毕的回调</span></div><div class="line">        Log.e(<span class="string">"rx_test"</span>, <span class="string">"onCompleted"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123; <span class="comment">//事件发送过程出现异常的回调</span></div><div class="line">        Log.e(<span class="string">"rx_test"</span>, <span class="string">"onError"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Object o)</span> </span>&#123; <span class="comment">//接收到发送事件的回调</span></div><div class="line">        Log.e(<span class="string">"rx_test"</span>, <span class="string">"onNext:"</span> + o.toString());</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　在以往普通的观察者模式中，观察者通常只提供一个update()的方法，而RxJava扩展的观察者模式中的观察者提供<code>onNext(Object o)</code>，<code>onCompleted()</code>，<code>onError(Throwable e)</code>三个方法，分别对应被观察者call()方法中重写的<code>subscriber.onNext()</code>，<code>subscriber.onCompleted()</code>，<code>subscriber.onError()</code>方法。而onNext()方法就对应普通观察者模式中的update()方法。<br>　　RxJava扩展的观察模式弥补了普通观察者模式的不足：<br>　　1. 当事件发送完毕可以调用onCompleted()方法进行标示。<br>　　2. 当事件发送过程中出现异常会自动触发onError()方法，也可进行手动调用。<br>　　3. Observable支持链式编程，从而避免了回调嵌套的问题，也简化了代码。</p>
<h4 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h4><p>　　最后一步：被观察者Observable订阅观察者Observer。<br>　　这里不同于普通观察者模式，上一篇我们讲了在RxJava扩展观察者模式中，如果没有观察者，被观察者是不会发出任何事件的。所以这里是被观察者订阅观察者。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(observer);</div></pre></td></tr></table></figure></p>
<p>　　上图：</p>
<p><div align="center"><br>　　<img src="https://s2.ax1x.com/2019/12/09/Qw5n61.png" alt=""><br></div><br>　　订阅很简单，一行代码搞定。调用Observable的subscribe()方法，传入观察者对象作为参数，这样被观察者与观察者就进行了绑定。</p>
<h4 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h4><p>　　RxJava可以使用链式编程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Object&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Object&gt; subscriber)</span> </span>&#123;</div><div class="line">        <span class="comment">//被观察者的数据操作更新</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            subscriber.onNext(<span class="string">"xulei"</span> + i);</div><div class="line">        &#125;</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;Object&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"rx_test"</span>, <span class="string">"onCompleted"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"rx_test"</span>, <span class="string">"onError"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"rx_test"</span>, <span class="string">"onNext:"</span> + o.toString());</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h4 id="逻辑梳理"><a href="#逻辑梳理" class="headerlink" title="逻辑梳理"></a>逻辑梳理</h4><p>　　到此一个RxJava的简单调用就实现了，相信不少码友看完之后还是很懵13，那我们再来梳理一下整个流程。首先使用<code>Observable.create()</code>创建了一个Observable<integer>，并在create()方法中传入了一个OnSubscribe对象作为参数，重写OnSubscribe中的call()方法，当Observable进行订阅后就会自动触发call()方法发送事件。<br>　　<strong>注意</strong>：call()方法中的subscriber参数其实就是我们在调用subscribe()进行订阅时时传入的观察者Observer。所以当在call()方法中调用的5次onNext()方法与1次onCompleted()方法后，观察者Observer中输出的日志为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">onNext:xulei0</div><div class="line">onNext:xulei1</div><div class="line">onNext:xulei2</div><div class="line">onNext:xulei3</div><div class="line">onNext:xulei4</div><div class="line">onCompleted</div></pre></td></tr></table></figure></integer></p>
<p>　　有的码友看到这里会对call()方法中的subscriber参数就是订阅时传入的Observer有些不解，那么我们一起来看源码。<br>　　先看下call()方法中的参数Subscriber：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Subscription</span> </span>&#123;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　可以看出Subscriber是Observer的抽象实现类，与Observer一个类型。再来看订阅时调用的subscribe(observer)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</div><div class="line">    <span class="comment">//无视</span></div><div class="line">    <span class="keyword">if</span> (observer <span class="keyword">instanceof</span> Subscriber) &#123;</div><div class="line">        <span class="keyword">return</span> subscribe((Subscriber&lt;? <span class="keyword">super</span> T&gt;)observer);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> subscribe(<span class="keyword">new</span> Subscriber&lt;T&gt;() &#123;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">            observer.onCompleted();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">            observer.onError(e);</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">            observer.onNext(t);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　这里将传入的Observer对象通过代理转换为Subscriber对象作为参数传入并调用重载方法subscribe()，我们再来看这个subscribe()方法的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Observable.subscribe(subscriber, <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　这里继续调用重载方法subscribe()，将由Observer转换为的subscriber对象与当前Observable对象作为参数传入，继续往下追踪源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber, Observable&lt;T&gt; observable)</span> </span>&#123;</div><div class="line">    ......</div><div class="line">    subscriber.onStart();</div><div class="line">    ......</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);</div><div class="line">        <span class="keyword">return</span> hook.onSubscribeReturn(subscriber);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        ......</div><div class="line">        <span class="keyword">return</span> Subscriptions.unsubscribed();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　精简一下代码发现，<code>subscriber.onStart()</code>用来通知被观察者准备开始发送事件了。重点看<code>hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);</code>我们发现<code>hook.onSubscribeStart(observable, observable.onSubscribe)</code>方法返回的是其第二个参数observable.onSubscribe，这个参数正是新建Observable时create()方法中传入的OnSubscribe对象。接着又通过这个onSubscribe调用call(subscriber)方法，将subscriber作为参数传入，码友们有没有发现，这个subscriber传来传去究其根源，正是一开始由订阅方法subscribe(observer)传入的observer通过代理转换为的那个subscriber。<br>　　这样前后逻辑就连接上了，通过阅读源码我们才能发现为何创建Observable时call()方法中的subscriber参数其实就是订阅时传入的Observer。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　到此，本篇关于RxJava的基本原理与使用就讲解完毕了，下一篇我们将一起研究RxJava的四类操作符中的创建操作符都有哪些以及如何使用。<br>　　这里感谢下张磊大神撰写的RxJava系列的帮助：<br>　　<a href="https://zhuanlan.zhihu.com/p/20687307" target="_blank" rel="external">RxJava系列2(基本概念及使用介绍)</a><br>　　技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。<br>　　附上RxJavaDemo的地址：<br>　　<a href="https://github.com/LeiHolmes/RxJavaDemo" target="_blank" rel="external">RxJavaDemo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;　　上一篇我们了解了RxJava的介绍以及通过一个例子学习了RxJava的展现形式，相信大家现在已经对RxJava有一个初步的印象与概念了。本篇我们将更深入的学习RxJava的基本原理以及如何使用RxJava。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="RxJava" scheme="http://LeiHolmes.github.io/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava简介与入门(一)</title>
    <link href="http://LeiHolmes.github.io/2017/09/21/RxJava%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%85%A5%E9%97%A8(%E4%B8%80)/"/>
    <id>http://LeiHolmes.github.io/2017/09/21/RxJava简介与入门(一)/</id>
    <published>2017-09-20T16:00:00.000Z</published>
    <updated>2017-10-13T08:32:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　最近在学习RxJava的过程中,越发感受到这个框架的强大，对于提升开发效率，降低维护成本有很大的作用。有必要强行安利一波，一起来看看RxJava简介，基本概念，原理与使用，本篇主要介绍RxJava的简介。<br>　　<a id="more"></a></p>
<h3 id="响应式编程ReactiveX"><a href="#响应式编程ReactiveX" class="headerlink" title="响应式编程ReactiveX"></a>响应式编程ReactiveX</h3><p>　　RxJava是ReactiveX中使用Java语言实现的版本，那什么是ReactiveX呢？ReactiveX就是一种新兴的编程模式–响应式编程，定义为一种基于异步数据流概念的编程模式，可分解为”观察者模式+迭代器模式+函数式编程”。</p>
<h3 id="扩展的观察者模式"><a href="#扩展的观察者模式" class="headerlink" title="扩展的观察者模式"></a>扩展的观察者模式</h3><p>　　有关观察者模式的概念不懂得童鞋可自行google，这里就不再赘述。RxJava扩展了观察者模式，通过使用可观察的对象序列流来表述一系列事件，订阅者进行占点观察并对序列流做出反应（或持久化或输出显示等等）；借鉴迭代器模式，对多个对象序列进行迭代输出，订阅者可以依次处理不同的对象序列；使用函数式编程思想，简化繁琐的逻辑代码。<br>　　而RxJava的核心便是被观察者Observables与观察者Observer，由Observables发出一系列的事件，Observer通过subscribe()方法进行订阅接收事件并进行处理，类似观察者模式，不同之处在于，若没有观察者，被观察者是不会发出任何事件的。<br>　　所以说，<strong>RxJava本质上是一个异步操作库，是一个能让你用极其简洁的逻辑去处理繁琐复杂任务的异步事件库。</strong></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>　　概念理解起来未免晦涩难懂，我们来看一个例子：<br>　　有这样一个需求：开发一个类似房天下的App，某功能需要检索出某一片区所有住宅小区中购房总价&lt;200W的房源并展示出来。先看原始实现方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//获取要查询的小区集合</span></div><div class="line">        List&lt;Community&gt; communities = getCommunities();</div><div class="line">        <span class="keyword">for</span> (Community community : communities) &#123;</div><div class="line">            <span class="comment">//获取小区中的房源集合</span></div><div class="line">            List&lt;House&gt; houses = community.getHouses();</div><div class="line">            <span class="keyword">for</span> (House house : houses) &#123;</div><div class="line">                <span class="keyword">if</span> (house.getPrice() &lt; <span class="number">200</span>) &#123;</div><div class="line">                    runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                            <span class="comment">//显示查询出来的房源信息</span></div><div class="line">                            ShowSearchedHousesMessage();</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<p>　　RxJava实现方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取要查询的小区集合</span></div><div class="line">List&lt;Community&gt; communities = getCommunities();</div><div class="line">Observable.from(communities)</div><div class="line">        .flatMap(<span class="keyword">new</span> Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;House&gt; <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Observable.from(community.getHouses());</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .filter(<span class="keyword">new</span> Func1&lt;House, Boolean&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> house.getPrice() &lt; <span class="number">200</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="comment">//显示查询出来的房源信息</span></div><div class="line">                ShowSearchedHousesMessage();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>　　RxJava的实现方式看上去更复杂了，但是它的逻辑很清晰简洁，修改起来很方便，后期维护起来也能提高工作效率。再来看下配合Lambda表达式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取要查询的小区集合</span></div><div class="line">List&lt;Community&gt; communities = getCommunities();</div><div class="line">Observable.from(communities)</div><div class="line">        .flatMap(community -&gt; Observable.from(community.getHouses())</div><div class="line">        .filter(house -&gt; house.getPrice() &lt; <span class="number">200</span>)</div><div class="line">        .subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(house -&gt; ShowSearchedHousesMessage());</div></pre></td></tr></table></figure></p>
<p>　　搭配上Lambda表达式，代码的简洁度是不是更上一层楼呢？不懂Lambda表达式的童鞋可以跳转到我写的另一篇讲解Lambda表达式的文章：<br>　　<a href="http://xulei.tech/2017/07/24/Lambda表达式基本语法与应用/" target="_blank" rel="external">Android开发之Lambda表达式基本语法与应用</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　到此，本篇关于RxJava的简介就介绍完毕了，本篇的目的主要是给大家引入一个RxJava的概念，以便后期更轻松的理解RxJava的原理与运作。下一篇我们再来一起详细研究RxJava的原理及如何使用。<br>　　技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。附上RxJavaDemo的地址：<br>　　<a href="https://github.com/LeiHolmes/RxJavaDemo" target="_blank" rel="external">RxJavaDemo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;　　最近在学习RxJava的过程中,越发感受到这个框架的强大，对于提升开发效率，降低维护成本有很大的作用。有必要强行安利一波，一起来看看RxJava简介，基本概念，原理与使用，本篇主要介绍RxJava的简介。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="RxJava" scheme="http://LeiHolmes.github.io/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Lambda表达式基本语法与应用</title>
    <link href="http://LeiHolmes.github.io/2017/07/24/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>http://LeiHolmes.github.io/2017/07/24/Lambda表达式基本语法与应用/</id>
    <published>2017-07-23T16:00:00.000Z</published>
    <updated>2017-09-28T08:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lambda简介"><a href="#Lambda简介" class="headerlink" title="Lambda简介"></a>Lambda简介</h3><p>　　Lambda表达式是Java8中提供的一种新的特性，它支持Java也能进行简单的“函数式编程”，即Lambda允许你通过表达式来代替功能接口，即可使用更少的代码来实现同样的功能。<br>　　<a id="more"></a><br>　　用官方的解释就是：</p>
<blockquote>
<p>A lambda expression is a block of code with parameters.<br>(Lambda表达式是一个带有参数的表达式)</p>
</blockquote>
<h3 id="添加支持"><a href="#添加支持" class="headerlink" title="添加支持"></a>添加支持</h3><p>　　首先Java版本需要为1.8，然后在build.gradle中添加：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    ……</div><div class="line">    defaultConfig &#123;</div><div class="line">        ……</div><div class="line">        jackOptions&#123;</div><div class="line">            enabled <span class="keyword">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    compileOptions &#123;</div><div class="line">        <span class="comment">//升级Android Studio的Language level为1.8</span></div><div class="line">        sourceCompatibility JavaVersion.VERSION_1_8</div><div class="line">        targetCompatibility JavaVersion.VERSION_1_8</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123;</div><div class="line">    Log.i(<span class="string">"TAG"</span>, <span class="string">"x:"</span> + x + <span class="string">"  y:"</span> + y);</div><div class="line">    <span class="keyword">return</span> x + y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　这是一个完整的Lambda表达式的写法，通常由三部分组成：<br>　　1. (int x, int y)：Lambda表达式的参数部分，包括参数类型与参数名<br>　　2. “-&gt;”：箭头goes to，指向代码块<br>　　3. 代码块：用”{}”包裹的代码</p>
<h4 id="忽略参数类型"><a href="#忽略参数类型" class="headerlink" title="忽略参数类型"></a>忽略参数类型</h4><p>　　在大多数情况下，参数的类型系统可根据上下文推断出来。这种情况参数类型就可以忽略不写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(x, y) -&gt; &#123;</div><div class="line">    Log.i(<span class="string">"TAG"</span>, <span class="string">"x:"</span> + x + <span class="string">"  y:"</span> + y);</div><div class="line">    <span class="keyword">return</span> x + y;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="忽略：”-”"><a href="#忽略：”-”" class="headerlink" title="忽略：”()”"></a>忽略：”()”</h4><p>　　当只有一个参数时，”()”可以忽略不写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x -&gt; &#123;</div><div class="line">    Log.i(<span class="string">"TAG"</span>, <span class="string">"x:"</span> + x);</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　当没有参数时，”()”不可忽略。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">() -&gt; &#123;</div><div class="line">    Log.i(<span class="string">"TAG"</span>, <span class="string">"无参数"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="忽略：”-”-1"><a href="#忽略：”-”-1" class="headerlink" title="忽略：”{}”"></a>忽略：”{}”</h4><p>　　当代码块只包含一条语句时可忽略”{}”不写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(x, y) -&gt; <span class="keyword">return</span> x + y;</div></pre></td></tr></table></figure></p>
<h4 id="忽略return"><a href="#忽略return" class="headerlink" title="忽略return"></a>忽略return</h4><p>　　而return关键字也是可以忽略不写的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(x, y) -&gt; x + y;</div></pre></td></tr></table></figure></p>
<p>　　精简到最后只需要一行代码就可以搞定，是不是很方便。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="无参数-语句-代码块"><a href="#无参数-语句-代码块" class="headerlink" title="无参数+语句/代码块"></a>无参数+语句/代码块</h4><p>　　常规写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.i(<span class="string">"TAG"</span>, <span class="string">"测试无参数+语句/代码块"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure></p>
<p>　　Lambda写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(() -&gt; Log.i(<span class="string">"TAG"</span>, <span class="string">"测试无参数+语句/代码块"</span>)).start();</div></pre></td></tr></table></figure></p>
<p>　　适用于匿名内部类中方法无参数的情况</p>
<h4 id="有参数-语句"><a href="#有参数-语句" class="headerlink" title="有参数+语句"></a>有参数+语句</h4><p>　　常规写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">findViewById(R.id.button).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        Log.i(<span class="string">"TAG"</span>, <span class="string">"测试有参数+语句"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>　　Lambda写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">findViewById(R.id.button).setOnClickListener(v -&gt; Log.i(<span class="string">"TAG"</span>, <span class="string">"测试有参数+语句"</span>));</div></pre></td></tr></table></figure></p>
<p>　　适用于匿名内部类中方法只有一个参数的情况</p>
<h4 id="有参数-代码块"><a href="#有参数-代码块" class="headerlink" title="有参数+代码块"></a>有参数+代码块</h4><p>　　常规写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CheckBox checkBox = (CheckBox) findViewById(R.id.checkBox);</div><div class="line">checkBox.setOnCheckedChangeListener(<span class="keyword">new</span> CompoundButton.OnCheckedChangeListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCheckedChanged</span><span class="params">(CompoundButton buttonView, <span class="keyword">boolean</span> isChecked)</span> </span>&#123;</div><div class="line">        Log.i(<span class="string">"TAG"</span>, <span class="string">"测试有参数+代码块1"</span>);</div><div class="line">        Log.i(<span class="string">"TAG"</span>, <span class="string">"测试有参数+代码块2"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>　　Lambda写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">checkBox.setOnCheckedChangeListener((buttonView, isChecked) -&gt; &#123;</div><div class="line">    Log.i(<span class="string">"TAG"</span>, <span class="string">"测试有参数+代码块1"</span>);</div><div class="line">    Log.i(<span class="string">"TAG"</span>, <span class="string">"测试有参数+代码块2"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>　　适用于匿名内部类中方法不止一个参数且执行语句不止一行的情况</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　Lambda表达式的应用场景很多，例如可与RxJava，Retrofit等进行完美配合，更多的就等待各位码友去实践发掘了。而到此，本篇关于Lambda表达式的详解与应用就讲解完毕了。技术渣一枚，有写的不对的地方欢迎大神们留言指正。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Lambda简介&quot;&gt;&lt;a href=&quot;#Lambda简介&quot; class=&quot;headerlink&quot; title=&quot;Lambda简介&quot;&gt;&lt;/a&gt;Lambda简介&lt;/h3&gt;&lt;p&gt;　　Lambda表达式是Java8中提供的一种新的特性，它支持Java也能进行简单的“函数式编程”，即Lambda允许你通过表达式来代替功能接口，即可使用更少的代码来实现同样的功能。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="Lambda" scheme="http://LeiHolmes.github.io/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>ORM框架之GreenDao3.0使用详解(二)</title>
    <link href="http://LeiHolmes.github.io/2017/07/13/ORM%E6%A1%86%E6%9E%B6%E4%B9%8BGreenDao3.0%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3(%E4%BA%8C)/"/>
    <id>http://LeiHolmes.github.io/2017/07/13/ORM框架之GreenDao3.0使用详解(二)/</id>
    <published>2017-07-12T16:00:00.000Z</published>
    <updated>2017-09-28T08:57:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h3><p>　　上一篇讲解了GreenDao3.0如何集成环境与添加各类注解，这一篇我们来看看如何使用GreenDao实现数据库增删改查的功能，还是上一篇公司Company与雇员Employee的例子。<br>　　<a id="more"></a></p>
<h3 id="数据库初始化"><a href="#数据库初始化" class="headerlink" title="数据库初始化"></a>数据库初始化</h3><p>　　首先初始化数据库与表，可封装一个工具类，这里献上我的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenDaoUtil</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DaoSession daoSession;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SQLiteDatabase database;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 初始化数据库</div><div class="line">     * 建议放在Application中执行</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initDataBase</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="comment">//通过DaoMaster的内部类DevOpenHelper，可得到一个SQLiteOpenHelper对象。</span></div><div class="line">        DaoMaster.DevOpenHelper devOpenHelper = <span class="keyword">new</span> DaoMaster.DevOpenHelper</div><div class="line">        (context, <span class="string">"greendaoutil.db"</span>, <span class="keyword">null</span>); <span class="comment">//数据库名称</span></div><div class="line">        database = devOpenHelper.getWritableDatabase();</div><div class="line">        DaoMaster daoMaster = <span class="keyword">new</span> DaoMaster(database);</div><div class="line">        daoSession = daoMaster.newSession();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DaoSession <span class="title">getDaoSession</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> daoSession;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SQLiteDatabase <span class="title">getDatabase</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> database;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　然后在Application中调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">        GreenDaoUtil.initDataBase(getApplicationContext());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>　　插入公司与雇员的假数据：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取实体Dao</span></div><div class="line">CompanyDao companyDao = GreenDaoUtil.getDaoSession().getCompanyDao();</div><div class="line">EmployeeDao employeeDao = GreenDaoUtil.getDaoSession().getEmployeeDao();</div><div class="line"><span class="comment">//插入公司</span></div><div class="line">Company company1 = <span class="keyword">new</span> Company();</div><div class="line">company1.setId(<span class="keyword">null</span>);</div><div class="line">company1.setCompanyName(<span class="string">"Netease"</span>);</div><div class="line">company1.setIndustry(<span class="string">"news"</span>);</div><div class="line">Company company2 = <span class="keyword">new</span> Company();</div><div class="line">company2.setId(<span class="keyword">null</span>);</div><div class="line">company2.setCompanyName(<span class="string">"Tencent"</span>);</div><div class="line">company2.setIndustry(<span class="string">"chat"</span>);</div><div class="line">companyDao.insert(company1);</div><div class="line">companyDao.insert(company2);</div><div class="line"></div><div class="line"><span class="comment">//插入不同公司的雇员</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">    Employee employee = <span class="keyword">new</span> Employee(<span class="keyword">null</span>, company1.getId(), <span class="string">"Sherlock"</span> + i, <span class="number">11000</span> + i * <span class="number">1000</span>);</div><div class="line">    employeeDao.insert(employee);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">    Employee employee = <span class="keyword">new</span> Employee(<span class="keyword">null</span>, company2.getId(), <span class="string">"Richard"</span> + i, <span class="number">8000</span> + i * <span class="number">1000</span>);</div><div class="line">    employeeDao.insert(employee);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　注意：设置setId(null)，GreenDao会自动分配自增Id。</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>　　由于删除与更新基本都需要先进行查询，所以咱们来看看如何进行查询：</p>
<h4 id="QueryBuilder"><a href="#QueryBuilder" class="headerlink" title="QueryBuilder"></a>QueryBuilder</h4><p>　　举例：查询Tencent公司中薪水大于等于10000的职员。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//查询Company表中名为Tencent的公司</span></div><div class="line">Company company = companyDao.queryBuilder()</div><div class="line">.where(CompanyDao.Properties.CompanyName.eq(<span class="string">"Tencent"</span>))</div><div class="line">.unique();</div><div class="line"><span class="comment">//查询Employee表中属于Tencent公司且薪水水大于等于10000的Employee</span></div><div class="line">List&lt;Employee&gt; employeeList = employeeDao.queryBuilder()</div><div class="line">.where(EmployeeDao.Properties.CompanyId.eq(company.getId()), </div><div class="line">EmployeeDao.Properties.Salary.ge(<span class="number">10000</span>))</div><div class="line">.list();</div></pre></td></tr></table></figure></p>
<p>　　注意：如果查询调用.unique()的话，需注意本次查询的结果必须唯一，否则会报错。where中为查询条件，支持多条件查询以” , “隔开。</p>
<h4 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h4><p>　　使用Query可进行重复查询，更改查询条件参数即可，还是上面的例子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//查询Company表中名为Tencent的公司</span></div><div class="line">Company company = companyDao.queryBuilder()</div><div class="line">.where(CompanyDao.Properties.CompanyName.eq(<span class="string">"Tencent"</span>))</div><div class="line">.unique();</div><div class="line"><span class="comment">//查询Employee表中属于Tencent公司且薪水水大于等于10000的Employee</span></div><div class="line">Query query = employeeDao.queryBuilder()</div><div class="line">.where(EmployeeDao.Properties.CompanyId.eq(company.getId()), </div><div class="line">EmployeeDao.Properties.Salary.ge(<span class="number">10000</span>))</div><div class="line">.build();</div><div class="line"><span class="comment">//修改查询条件参数</span></div><div class="line">query.setParameter(<span class="number">0</span>, company.getId());</div><div class="line">query.setParameter(<span class="number">1</span>, <span class="number">11000</span>);</div><div class="line">List&lt;Employee&gt; employeeList = query.list();</div></pre></td></tr></table></figure></p>
<h4 id="load-Long-key"><a href="#load-Long-key" class="headerlink" title="load(Long key)"></a>load(Long key)</h4><p>　　根据主键查询一条记录<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Company company =  companyDao.load(<span class="number">1l</span>);</div></pre></td></tr></table></figure></p>
<h4 id="loadAll"><a href="#loadAll" class="headerlink" title="loadAll()"></a>loadAll()</h4><p>　　查询表中所有记录<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;Company&gt; companyList = companyDao.loadAll();</div><div class="line">List&lt;Employee&gt; employeeList = employeeDao.loadAll();</div></pre></td></tr></table></figure></p>
<h4 id="原声sql查询"><a href="#原声sql查询" class="headerlink" title="原声sql查询"></a>原声sql查询</h4><p>　　推荐通过QueryBuilder和WhereCondition.StringCondition来实现原声sql查询。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Query query = companyDao.queryBuilder()</div><div class="line">.where( <span class="keyword">new</span> StringCondition(<span class="string">"_ID IN "</span> + <span class="string">"(SELECT USER_ID FROM USER_MESSAGE WHERE READ_FLAG = 0)"</span>))</div><div class="line">.build();</div></pre></td></tr></table></figure></p>
<p>　　也可使用queryRaw()或queryRawCreate()方法来实现。</p>
<h4 id="多线程查询"><a href="#多线程查询" class="headerlink" title="多线程查询"></a>多线程查询</h4><p>　　如果数据量过大，对于数据库查询的操作是很耗时的，所以需要开启新的线程进行查询。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">queryThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Query query = employeeDao.queryBuilder().build();</div><div class="line">    <span class="keyword">new</span> Thread()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            List list = query.forCurrentThread().list();</div><div class="line">        &#125;</div><div class="line">    &#125;.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="查询条件判断"><a href="#查询条件判断" class="headerlink" title="查询条件判断"></a>查询条件判断</h4><h5 id="eq-noteq与like查询"><a href="#eq-noteq与like查询" class="headerlink" title="eq,noteq与like查询"></a>eq,noteq与like查询</h5><p>　　eq判断值是否相等，通常用来具体查找，返回一条指定类型数据。<br>　　noteq与eq相反，判断值是否不等，通常用来模糊查找，返回指定类型的集合。<br>　　like相当于通配符查询，包含查询值的实体都会返回，同样模糊查找，返回指定类型的集合。</p>
<h5 id="gt-、-lt-、-gt-、-lt-查询"><a href="#gt-、-lt-、-gt-、-lt-查询" class="headerlink" title="&gt;、&lt;、&gt;=、&lt;=查询"></a>&gt;、&lt;、&gt;=、&lt;=查询</h5><p>　　分别对应方法：<br>　　&gt;: gt()<br>　　&lt;: lt()<br>　　&gt;=: ge()<br>　　&lt;=: le()</p>
<h5 id="isNull与isNotNull"><a href="#isNull与isNotNull" class="headerlink" title="isNull与isNotNull"></a>isNull与isNotNull</h5><p>　　为空与不为空，判断数据库中有无数据。</p>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>　　对查询结果进行排序，有升序与降序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;Employee&gt; employeeList = employeeDao.queryBuilder()</div><div class="line">.where(EmployeeDao.Properties.CompanyId.eq(company.getId()))</div><div class="line">.orderAsc(EmployeeDao.Properties.Salary)</div><div class="line">.list();</div></pre></td></tr></table></figure></p>
<p>　　上例中的<code>.orderAsc(EmployeeDao.Properties.Salary)</code>就是对查询出来的Employee按工资进行升序排序。同理降序为<code>.orderDesc(EmployeeDao.Properties.Salary)</code>。　　</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>　　删除主要有三种方式：</p>
<h4 id="deleteBykey-Long-key"><a href="#deleteBykey-Long-key" class="headerlink" title="deleteBykey(Long key)"></a>deleteBykey(Long key)</h4><p>　　根据key进行删除。举例：删除Tencent公司中薪水小于10000的人，需先查询出Employee表中属于Tencent公司且薪水小于10000的Employee实体，再进行删除。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//查询Company表中名为Tencent的公司</span></div><div class="line">Company companyTencent = companyDao.queryBuilder()</div><div class="line">.where(CompanyDao.Properties.CompanyName.eq(<span class="string">"Tencent"</span>))</div><div class="line">.unique();</div><div class="line"><span class="keyword">if</span> (companyTencent != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">//查询Employee表中属于Tencent公司且薪水小于10000的Employee</span></div><div class="line">    List&lt;Employee&gt; employeeList = employeeDao.queryBuilder()</div><div class="line">    .where(EmployeeDao.Properties.CompanyId.eq(companyTencent.getId()), </div><div class="line">    EmployeeDao.Properties.Salary.lt(<span class="number">10000</span>))</div><div class="line">    .list();</div><div class="line">    <span class="keyword">if</span> (employeeList != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (Employee employee : employeeList) &#123;</div><div class="line">            <span class="comment">//进行删除</span></div><div class="line">            employeeDao.deleteByKey(employee.getId());</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Log.e(<span class="string">"greendao_test"</span>, <span class="string">"delete:deleteList为空"</span>);</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    Log.e(<span class="string">"greendao_test"</span>, <span class="string">"delete:company为空"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="delete-Employee-entity"><a href="#delete-Employee-entity" class="headerlink" title="delete(Employee entity)"></a>delete(Employee entity)</h4><p>　　根据实体进行删除。举例：删除名为Tencent的公司。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//查询Company表中名为Tencent的公司</span></div><div class="line">Company companyTencent = companyDao.queryBuilder()</div><div class="line">.where(CompanyDao.Properties.CompanyName.eq(<span class="string">"Tencent"</span>))</div><div class="line">.unique();</div><div class="line">companyDao.delete(companyTencent);</div></pre></td></tr></table></figure></p>
<h4 id="deleteAll"><a href="#deleteAll" class="headerlink" title="deleteAll()"></a>deleteAll()</h4><p>　 若需删除表中所有实体，则调用此方法。举例：删除所有雇员。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">employeeDao.deleteAll();</div></pre></td></tr></table></figure></p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>　　若需对某个已存入数据库实体的属性进行修改，则需进行update操作。举例：修改Netease公司中薪水小于等于13000人的名字<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//查询Company表中名为Netease的公司</span></div><div class="line">Company companyNetease = companyDao.queryBuilder()</div><div class="line">.where(CompanyDao.Properties.CompanyName.eq(<span class="string">"Netease"</span>))</div><div class="line">.unique();</div><div class="line"><span class="keyword">if</span> (companyNetease != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">//查询Employee表中查询Employee表中属于Netease公司且薪水小于等于13000人的Employee</span></div><div class="line">    List&lt;Employee&gt; employeeList = employeeDao.queryBuilder()</div><div class="line">    .where(EmployeeDao.Properties.CompanyId.eq(companyNetease.getId()), </div><div class="line">    EmployeeDao.Properties.Salary.le(<span class="number">13000</span>))</div><div class="line">    .list();</div><div class="line">    <span class="keyword">if</span> (employeeList != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (Employee employee : employeeList) &#123;</div><div class="line">            <span class="comment">//修改属性</span></div><div class="line">            employee.setEmployeeName(<span class="string">"baozi"</span>);</div><div class="line">            <span class="comment">//进行更新</span></div><div class="line">            employeeDao.update(employee);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Log.e(<span class="string">"greendao_test"</span>, <span class="string">"update:updateList为空"</span>);</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    Log.e(<span class="string">"greendao_test"</span>, <span class="string">"update:company为空"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　到此，这一篇关于GreenDao3.0的使用就讲解完毕了，可结合上一篇集成与注解详解一起看。<br>　　技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者不懂的地方也可以在我Github上GreenDaoDemo项目的Issues中提出，我会及时解答。附上GreenDaoDemo的地址：<br>　　<a href="https://github.com/LeiHolmes/GreenDaoDemo" target="_blank" rel="external">GreenDaoDemo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h3&gt;&lt;p&gt;　　上一篇讲解了GreenDao3.0如何集成环境与添加各类注解，这一篇我们来看看如何使用GreenDao实现数据库增删改查的功能，还是上一篇公司Company与雇员Employee的例子。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="GreenDao" scheme="http://LeiHolmes.github.io/tags/GreenDao/"/>
    
  </entry>
  
  <entry>
    <title>ORM框架之GreenDao3.0集成与注解(一)</title>
    <link href="http://LeiHolmes.github.io/2017/07/10/ORM%E6%A1%86%E6%9E%B6%E4%B9%8BGreenDao3.0%E9%9B%86%E6%88%90%E4%B8%8E%E6%B3%A8%E8%A7%A3(%E4%B8%80)/"/>
    <id>http://LeiHolmes.github.io/2017/07/10/ORM框架之GreenDao3.0集成与注解(一)/</id>
    <published>2017-07-09T16:00:00.000Z</published>
    <updated>2019-12-09T08:37:02.202Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GreenDao简介"><a href="#GreenDao简介" class="headerlink" title="GreenDao简介"></a>GreenDao简介</h3><p>　　GreenDao是一个将对象映射到SQLite数据库中的轻量且快速的ORM数据库框架，本文将讲解如何集成GreenDao3.0环境，如何使用GreenDao自动生成代码及注解的使用。<br>　　<a id="more"></a><br>　　<a href="http://greenrobot.org/greendao/" target="_blank" rel="external">GreenDao官网</a><br>　　<a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="external">GreenDao GitHub</a></p>
<h3 id="GreenDao3-0优势"><a href="#GreenDao3-0优势" class="headerlink" title="GreenDao3.0优势"></a>GreenDao3.0优势</h3><p>　　GreenDao相较于ORMLite等其他数据库框架有以下优势：<br>　　1. 一个精简的库<br>　　2. 性能最大化<br>　　3. 内存开销最小化<br>　　4. 易于使用的 APIs<br>　　5. 对 Android 进行高度优化<br>　　而GreenDao3.0的版本主要使用注解方式定义实体类，通过gradle插件生成相应的代码。相较于3.0之前的版本集成步骤更为便捷，使用起来也更为简单。本文使用的版本为3.2.0。</p>
<h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3><h4 id="项目下build-gradle"><a href="#项目下build-gradle" class="headerlink" title="项目下build.gradle"></a>项目下build.gradle</h4><p>　　GitHub中提示添加maven仓库，但是AndroidStudio项目已经默认包含了jcenter仓库，而jcenter仓库就是maven仓库的一个分支，因此不需要再添加仓库，直接添加classPath即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath <span class="string">'com.android.tools.build:gradle:2.3.2'</span></div><div class="line">        classpath <span class="string">'org.greenrobot:greendao-gradle-plugin:3.2.1'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="app下build-gradle"><a href="#app下build-gradle" class="headerlink" title="app下build.gradle"></a>app下build.gradle</h4><p>　　在app下build.gradle文件中我们需要声明GreenDao插件，及配置GreenDao生成dao路径等信息，声明GreenDao依赖。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">apply plugin: <span class="string">'org.greenrobot.greendao'</span></div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line">greendao &#123;</div><div class="line">    schemaVersion <span class="number">1</span> <span class="comment">//数据库版本号    </span></div><div class="line">    daoPackage <span class="string">'com.holmeslei.greendaodemo.database'</span> <span class="comment">//设置时生成代码的目录    </span></div><div class="line">    targetGenDir <span class="string">'src/main/java'</span> <span class="comment">//设置DaoMaster、DaoSession、Dao目录   </span></div><div class="line">    <span class="comment">//targetGenDirTest：设置生成单元测试目录    </span></div><div class="line">    <span class="comment">//generateTests：设置自动生成单元测试用例</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    ......</div><div class="line">    compile <span class="string">'org.greenrobot:greendao:3.2.0'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="初始化实体"><a href="#初始化实体" class="headerlink" title="初始化实体"></a>初始化实体</h3><h4 id="编写实体类"><a href="#编写实体类" class="headerlink" title="编写实体类"></a>编写实体类</h4><p>　　集成好使用环境后需要初始化实体，首先编写实体类。这里演示使用公司Company与雇员Employer实体例子。使用@Entity注解。莫急，注解机制在之后小节有详细讲解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</div><div class="line">    <span class="meta">@Id</span>(autoincrement = <span class="keyword">true</span>) <span class="comment">//自增</span></div><div class="line">    <span class="keyword">private</span> Long id; <span class="comment">//主键</span></div><div class="line">    <span class="keyword">private</span> String companyName; <span class="comment">//公司名称</span></div><div class="line">    <span class="keyword">private</span> String industry; <span class="comment">//行业</span></div><div class="line">    <span class="meta">@ToMany</span>(referencedJoinProperty = <span class="string">"companyId"</span>) <span class="comment">//设置外键companyId</span></div><div class="line">    <span class="keyword">private</span> List&lt;Employee&gt; employeeList; <span class="comment">//公司与雇员建立一对多关系</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</div><div class="line">    <span class="meta">@Id</span>(autoincrement = <span class="keyword">true</span>)</div><div class="line">    <span class="keyword">private</span> Long id; <span class="comment">//主键</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> companyId; <span class="comment">//指向Company主键</span></div><div class="line">    <span class="keyword">private</span> String employeeName; <span class="comment">//雇员姓名</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> salary; <span class="comment">//薪水</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h4><p>　　实体类与注解添加完毕后编译项目，就会为所有带注解的实体生成Dao文件，及DaoMaster与DaoSession。若未在build.gradle中配置过则默认生成目录为build/generated/source。若配置过则生成在配置的目录下。<br><img src="https://s2.ax1x.com/2019/12/09/Qwc4KS.png" alt="编译项目"></p>
<p><center>编译项目</center><br><img src="https://s2.ax1x.com/2019/12/09/QwcWgf.png" alt="生成代码"></p>
<p><center>生成代码</center></p>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>　　3.0之后最大的不同就是使用的注解来配置实体类属性，便捷且灵活。下面来看一下各类注解：</p>
<h5 id="实体类注解"><a href="#实体类注解" class="headerlink" title="实体类注解"></a>实体类注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Entity</span>(</div><div class="line">        schema = <span class="string">"myschema"</span>,</div><div class="line">        active = <span class="keyword">true</span>,       </div><div class="line">        nameInDb = <span class="string">"AWESOME_USERS"</span>,</div><div class="line">        indexes = &#123;</div><div class="line">                <span class="meta">@Index</span>(value = <span class="string">"name DESC"</span>, unique = <span class="keyword">true</span>)</div><div class="line">        &#125;,</div><div class="line">        createInDb = <span class="keyword">false</span></div><div class="line">)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>@Entity：用于标识当前实体需要GreenDao生成代码。</li>
<li>schema：项目中存在多个Schema时，表明当前实体属于哪个Schema。</li>
<li>active：标记实体是否处于活动状态，活动状态才支持更新删除刷新等操作。</li>
<li>nameInDb：存储在数据库中的表名，不写默认与类名一致。</li>
<li>indexes：定义索引，可跨越多个列。</li>
<li>createInDb：标记创建数据库表，若有多个实体关联此表可设为false避免重复创建，默认为true。</li>
</ul>
<h5 id="属性注解"><a href="#属性注解" class="headerlink" title="属性注解"></a>属性注解</h5><ul>
<li>@Id :主键Long型，可以通过<code>@Id(autoincrement = true)</code>设置自增长。</li>
<li>@Property：设置一个非默认关系映射所对应的列名，默认是的使用字段名例如<code>@Property (nameInDb=&quot;name&quot;)</code>。</li>
<li>@NotNul：设置数据库表当前列不能为空。</li>
<li>@OrderBy：指定排序。</li>
<li>@Transient：添加此标记之后不会生成数据库表的列。</li>
<li>@Generated：为build之后GreenDao自动生成的注解，为防止重复，每一块代码生成后会加个hash作为标记。</li>
</ul>
<h5 id="索引注解"><a href="#索引注解" class="headerlink" title="索引注解"></a>索引注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</div><div class="line">    <span class="meta">@Id</span>(autoincrement = <span class="keyword">true</span>)</div><div class="line">    <span class="keyword">private</span> Long id;</div><div class="line">    <span class="meta">@Index</span>(unique = <span class="keyword">true</span>)</div><div class="line">    <span class="keyword">private</span> String industry;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</div><div class="line">    <span class="meta">@Id</span>(autoincrement = <span class="keyword">true</span>)</div><div class="line">    <span class="keyword">private</span> Long id;</div><div class="line">    <span class="meta">@Unique</span> </div><div class="line">    <span class="keyword">private</span> String employeeName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>@Index：创建索引，通过设置name设置别名，设置unique添加约束。</li>
<li>@Unique：添加唯一约束与(unique = true)作用相同。</li>
</ul>
<h5 id="关系注解"><a href="#关系注解" class="headerlink" title="关系注解"></a>关系注解</h5><ul>
<li>@ToOne：定义与另一实体一对一的关联。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</div><div class="line">    <span class="meta">@Id</span> (autoincrement = <span class="keyword">true</span>)</div><div class="line">    <span class="keyword">private</span> Long id;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> customerId;</div><div class="line">    <span class="meta">@ToOne</span>(joinProperty = <span class="string">"employeeId"</span>)</div><div class="line">    <span class="keyword">private</span> Employee employee;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</div><div class="line">    <span class="meta">@Id</span>(autoincrement = <span class="keyword">true</span>)</div><div class="line">    <span class="keyword">private</span> Long id;</div><div class="line">    <span class="keyword">private</span> String employeeName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>@ToMany：定义与多个实体对象一对多的关联，referencedJoinProperty为外键约束。</li>
<li>@JoinProperty：标明目标属性的源属性。</li>
<li>@JoinEntity：建立表连接关系。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一种：Employee实体通过外键companyId指向Company实体的主键Id建立一对多关联</span></div><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</div><div class="line">    <span class="meta">@Id</span>(autoincrement = <span class="keyword">true</span>)</div><div class="line">    <span class="keyword">private</span> Long id;</div><div class="line">    <span class="keyword">private</span> String companyName; </div><div class="line">    <span class="keyword">private</span> String industry;</div><div class="line">    <span class="meta">@ToMany</span>(referencedJoinProperty = <span class="string">"companyId"</span>)</div><div class="line">    <span class="keyword">private</span> List&lt;Employee&gt; employeeList;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</div><div class="line">    <span class="meta">@Id</span>(autoincrement = <span class="keyword">true</span>)</div><div class="line">    <span class="keyword">private</span> Long id;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> companyId;</div><div class="line">    <span class="keyword">private</span> String employeeName;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> salary;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//第二种：Employee以companyId为外键，与Company非主键不为空的键employeeTag建立一对多关联。</span></div><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</div><div class="line">    <span class="meta">@Id</span>(autoincrement = <span class="keyword">true</span>)</div><div class="line">    <span class="keyword">private</span> Long id;</div><div class="line">    <span class="keyword">private</span> String companyName; </div><div class="line">    <span class="keyword">private</span> String industry;  </div><div class="line">    <span class="meta">@ToMany</span>(joinProperties = &#123;</div><div class="line">            <span class="meta">@JoinProperty</span>(name = <span class="string">"employeeTag"</span>, referencedName = <span class="string">"companyId"</span>)</div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">private</span> List&lt;Employee&gt; employeeList;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</div><div class="line">    <span class="meta">@Id</span>(autoincrement = <span class="keyword">true</span>)</div><div class="line">    <span class="keyword">private</span> Long id;</div><div class="line">    <span class="keyword">private</span> String employeeName;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> salary;</div><div class="line">    <span class="meta">@NotNull</span> </div><div class="line">    <span class="keyword">private</span> String companyId;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//第三种：通过第三者实体类建立关联，用的较少</span></div><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</div><div class="line">    <span class="meta">@Id</span>(autoincrement = <span class="keyword">true</span>)</div><div class="line">    <span class="keyword">private</span> Long id;</div><div class="line">    <span class="keyword">private</span> String employeeName;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> salary;</div><div class="line">  </div><div class="line">    <span class="meta">@ToMany</span></div><div class="line">    <span class="meta">@JoinEntity</span>(</div><div class="line">            entity = JoinEmployeeToCompany.class,</div><div class="line">            sourceProperty = <span class="string">"employeeId"</span>,</div><div class="line">            targetProperty = <span class="string">"companyId"</span></div><div class="line">    )</div><div class="line">    <span class="keyword">private</span> List&lt;Company&gt; companyList;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinEmployeeToCompany</span> </span>&#123;</div><div class="line">    <span class="meta">@Id</span>(autoincrement = <span class="keyword">true</span>)</div><div class="line">    <span class="keyword">private</span> Long id;</div><div class="line">    <span class="keyword">private</span> Long employeeId;</div><div class="line">    <span class="keyword">private</span> Long companyId;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</div><div class="line">    <span class="meta">@Id</span>(autoincrement = <span class="keyword">true</span>)</div><div class="line">    <span class="keyword">private</span> Long id;</div><div class="line">    <span class="keyword">private</span> String companyName; </div><div class="line">    <span class="keyword">private</span> String industry;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　到此，这一篇关于GreenDao3.0的集成与注解就讲解完毕了，欢迎参看下一篇关于如何使用GreenDao3.0对数据库进行增删改查。<br>　　技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者不懂的地方也可以在我Github上GreenDaoDemo项目的Issues中提出，我会及时解答。附上GreenDaoDemo的地址：<br>　　<a href="https://github.com/LeiHolmes/GreenDaoDemo" target="_blank" rel="external">GreenDaoDemo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;GreenDao简介&quot;&gt;&lt;a href=&quot;#GreenDao简介&quot; class=&quot;headerlink&quot; title=&quot;GreenDao简介&quot;&gt;&lt;/a&gt;GreenDao简介&lt;/h3&gt;&lt;p&gt;　　GreenDao是一个将对象映射到SQLite数据库中的轻量且快速的ORM数据库框架，本文将讲解如何集成GreenDao3.0环境，如何使用GreenDao自动生成代码及注解的使用。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://LeiHolmes.github.io/categories/Android/"/>
    
    
      <category term="GreenDao" scheme="http://LeiHolmes.github.io/tags/GreenDao/"/>
    
  </entry>
  
</feed>
