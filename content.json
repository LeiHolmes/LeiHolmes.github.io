{"meta":{"title":"Lei’s Blog","subtitle":"不忘初心，淡然前行","description":null,"author":"徐雷","url":"http://LeiHolmes.github.io"},"pages":[{"title":"categories","date":"2017-05-10T06:00:40.000Z","updated":"2017-05-11T07:01:56.000Z","comments":false,"path":"categories/index.html","permalink":"http://LeiHolmes.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-05-10T05:55:45.000Z","updated":"2017-05-11T07:01:30.000Z","comments":false,"path":"tags/index.html","permalink":"http://LeiHolmes.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android开发之Lambda表达式基本语法与应用","slug":"Android开发之Lambda表达式基本语法与应用","date":"2017-07-23T16:00:00.000Z","updated":"2017-07-24T06:24:31.000Z","comments":true,"path":"2017/07/24/Android开发之Lambda表达式基本语法与应用/","link":"","permalink":"http://LeiHolmes.github.io/2017/07/24/Android开发之Lambda表达式基本语法与应用/","excerpt":"Lambda简介 Lambda表达式是Java8中提供的一种新的特性，它支持Java也能进行简单的“函数式编程”，即Lambda允许你通过表达式来代替功能接口，即可使用更少的代码来实现同样的功能。","text":"Lambda简介 Lambda表达式是Java8中提供的一种新的特性，它支持Java也能进行简单的“函数式编程”，即Lambda允许你通过表达式来代替功能接口，即可使用更少的代码来实现同样的功能。 用官方的解释就是： A lambda expression is a block of code with parameters.(Lambda表达式是一个带有参数的表达式) 添加支持 首先Java版本需要为1.8，然后在build.gradle中添加：1234567891011121314android &#123; …… defaultConfig &#123; …… jackOptions&#123; enabled true &#125; &#125; compileOptions &#123; //升级Android Studio的Language level为1.8 sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125; 语法完整示例1234(int x, int y) -&gt; &#123; Log.i(\"TAG\", \"x:\" + x + \" y:\" + y); return x + y;&#125; 这是一个完整的Lambda表达式的写法，通常由三部分组成： 1. (int x, int y)：Lambda表达式的参数部分，包括参数类型与参数名 2. “-&gt;”：箭头goes to，指向代码块 3. 代码块：用”{}”包裹的代码 忽略参数类型 在大多数情况下，参数的类型系统可根据上下文推断出来。这种情况参数类型就可以忽略不写。1234(x, y) -&gt; &#123; Log.i(\"TAG\", \"x:\" + x + \" y:\" + y); return x + y;&#125; 忽略：”()” 当只有一个参数时，”()”可以忽略不写。1234x -&gt; &#123; Log.i(\"TAG\", \"x:\" + x); return x;&#125; 当没有参数时，”()”不可忽略。1234() -&gt; &#123; Log.i(\"TAG\", \"无参数\"); return 0;&#125; 忽略：”{}” 当代码块只包含一条语句时可忽略”{}”不写。1(x, y) -&gt; return x + y; 忽略return 而return关键字也是可以忽略不写的。1(x, y) -&gt; x + y; 精简到最后只需要一行代码就可以搞定，是不是很方便。 应用无参数+语句/代码块 常规写法：123456new Thread(new Runnable() &#123; @Override public void run() &#123; Log.i(\"TAG\", \"测试无参数+语句/代码块\"); &#125;&#125;).start(); Lambda写法：1new Thread(() -&gt; Log.i(\"TAG\", \"测试无参数+语句/代码块\")).start(); 适用于匿名内部类中方法无参数的情况 有参数+语句 常规写法：123456findViewById(R.id.button).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.i(\"TAG\", \"测试有参数+语句\"); &#125;&#125;); Lambda写法：1findViewById(R.id.button).setOnClickListener(v -&gt; Log.i(\"TAG\", \"测试有参数+语句\")); 适用于匿名内部类中方法只有一个参数的情况 有参数+代码块 常规写法：12345678CheckBox checkBox = (CheckBox) findViewById(R.id.checkBox);checkBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; Log.i(\"TAG\", \"测试有参数+代码块1\"); Log.i(\"TAG\", \"测试有参数+代码块2\"); &#125;&#125;); Lambda写法：1234checkBox.setOnCheckedChangeListener((buttonView, isChecked) -&gt; &#123; Log.i(\"TAG\", \"测试有参数+代码块1\"); Log.i(\"TAG\", \"测试有参数+代码块2\");&#125;); 适用于匿名内部类中方法不止一个参数且执行语句不止一行的情况 总结 Lambda表达式的应用场景很多，例如可与RxJava，Retrofit等进行完美配合，更多的就等待各位码友去实践发掘了。而到此，本篇关于Lambda表达式的详解与应用就讲解完毕了。技术渣一枚，有写的不对的地方欢迎大神们留言指正。","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"Lambda","slug":"Lambda","permalink":"http://LeiHolmes.github.io/tags/Lambda/"}]},{"title":"Android开发ORM框架之GreenDao3.0增删改查使用详解(二)","slug":"Android开发ORM框架之GreenDao3.0增删改查使用详解(二)","date":"2017-07-12T16:00:00.000Z","updated":"2017-08-13T07:40:10.000Z","comments":true,"path":"2017/07/13/Android开发ORM框架之GreenDao3.0增删改查使用详解(二)/","link":"","permalink":"http://LeiHolmes.github.io/2017/07/13/Android开发ORM框架之GreenDao3.0增删改查使用详解(二)/","excerpt":"本文介绍 上一篇讲解了GreenDao3.0如何集成环境与添加各类注解，这一篇我们来看看如何使用GreenDao实现数据库增删改查的功能，还是上一篇公司Company与雇员Employee的例子。","text":"本文介绍 上一篇讲解了GreenDao3.0如何集成环境与添加各类注解，这一篇我们来看看如何使用GreenDao实现数据库增删改查的功能，还是上一篇公司Company与雇员Employee的例子。 数据库初始化 首先初始化数据库与表，可封装一个工具类，这里献上我的：123456789101112131415161718192021222324public class GreenDaoUtil &#123; private static DaoSession daoSession; private static SQLiteDatabase database; /** * 初始化数据库 * 建议放在Application中执行 */ public static void initDataBase(Context context) &#123; //通过DaoMaster的内部类DevOpenHelper，可得到一个SQLiteOpenHelper对象。 DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper (context, \"greendaoutil.db\", null); //数据库名称 database = devOpenHelper.getWritableDatabase(); DaoMaster daoMaster = new DaoMaster(database); daoSession = daoMaster.newSession(); &#125; public static DaoSession getDaoSession() &#123; return daoSession; &#125; public static SQLiteDatabase getDatabase() &#123; return database; &#125;&#125; 然后在Application中调用。1234567public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); GreenDaoUtil.initDataBase(getApplicationContext()); &#125;&#125; 插入 插入公司与雇员的假数据：123456789101112131415161718192021222324//获取实体DaoCompanyDao companyDao = GreenDaoUtil.getDaoSession().getCompanyDao();EmployeeDao employeeDao = GreenDaoUtil.getDaoSession().getEmployeeDao();//插入公司Company company1 = new Company();company1.setId(null);company1.setCompanyName(\"Netease\");company1.setIndustry(\"news\");Company company2 = new Company();company2.setId(null);company2.setCompanyName(\"Tencent\");company2.setIndustry(\"chat\");companyDao.insert(company1);companyDao.insert(company2);//插入不同公司的雇员for (int i = 0; i &lt; 5; i++) &#123; Employee employee = new Employee(null, company1.getId(), \"Sherlock\" + i, 11000 + i * 1000); employeeDao.insert(employee);&#125;for (int i = 0; i &lt; 5; i++) &#123; Employee employee = new Employee(null, company2.getId(), \"Richard\" + i, 8000 + i * 1000); employeeDao.insert(employee);&#125; 注意：设置setId(null)，GreenDao会自动分配自增Id。 查询 由于删除与更新基本都需要先进行查询，所以咱们来看看如何进行查询： QueryBuilder 举例：查询Tencent公司中薪水大于等于10000的职员。123456789//查询Company表中名为Tencent的公司Company company = companyDao.queryBuilder().where(CompanyDao.Properties.CompanyName.eq(\"Tencent\")).unique();//查询Employee表中属于Tencent公司且薪水水大于等于10000的EmployeeList&lt;Employee&gt; employeeList = employeeDao.queryBuilder().where(EmployeeDao.Properties.CompanyId.eq(company.getId()), EmployeeDao.Properties.Salary.ge(10000)).list(); 注意：如果查询调用.unique()的话，需注意本次查询的结果必须唯一，否则会报错。where中为查询条件，支持多条件查询以” , “隔开。 Query 使用Query可进行重复查询，更改查询条件参数即可，还是上面的例子。12345678910111213//查询Company表中名为Tencent的公司Company company = companyDao.queryBuilder().where(CompanyDao.Properties.CompanyName.eq(\"Tencent\")).unique();//查询Employee表中属于Tencent公司且薪水水大于等于10000的EmployeeQuery query = employeeDao.queryBuilder().where(EmployeeDao.Properties.CompanyId.eq(company.getId()), EmployeeDao.Properties.Salary.ge(10000)).build();//修改查询条件参数query.setParameter(0, company.getId());query.setParameter(1, 11000);List&lt;Employee&gt; employeeList = query.list(); load(Long key) 根据主键查询一条记录1Company company = companyDao.load(1l); loadAll() 查询表中所有记录12List&lt;Company&gt; companyList = companyDao.loadAll();List&lt;Employee&gt; employeeList = employeeDao.loadAll(); 原声sql查询 推荐通过QueryBuilder和WhereCondition.StringCondition来实现原声sql查询。123Query query = companyDao.queryBuilder().where( new StringCondition(\"_ID IN \" + \"(SELECT USER_ID FROM USER_MESSAGE WHERE READ_FLAG = 0)\")).build(); 也可使用queryRaw()或queryRawCreate()方法来实现。 多线程查询 如果数据量过大，对于数据库查询的操作是很耗时的，所以需要开启新的线程进行查询。123456789private void queryThread() &#123; final Query query = employeeDao.queryBuilder().build(); new Thread()&#123; @Override public void run() &#123; List list = query.forCurrentThread().list(); &#125; &#125;.start();&#125; 查询条件判断eq,noteq与like查询 eq判断值是否相等，通常用来具体查找，返回一条指定类型数据。 noteq与eq相反，判断值是否不等，通常用来模糊查找，返回指定类型的集合。 like相当于通配符查询，包含查询值的实体都会返回，同样模糊查找，返回指定类型的集合。 &gt;、&lt;、&gt;=、&lt;=查询 分别对应方法： &gt;: gt() &lt;: lt() &gt;=: ge() &lt;=: le() isNull与isNotNull 为空与不为空，判断数据库中有无数据。 排序 对查询结果进行排序，有升序与降序。1234List&lt;Employee&gt; employeeList = employeeDao.queryBuilder().where(EmployeeDao.Properties.CompanyId.eq(company.getId())).orderAsc(EmployeeDao.Properties.Salary).list(); 上例中的.orderAsc(EmployeeDao.Properties.Salary)就是对查询出来的Employee按工资进行升序排序。同理降序为.orderDesc(EmployeeDao.Properties.Salary)。 删除 删除主要有三种方式： deleteBykey(Long key) 根据key进行删除。举例：删除Tencent公司中薪水小于10000的人，需先查询出Employee表中属于Tencent公司且薪水小于10000的Employee实体，再进行删除。123456789101112131415161718192021//查询Company表中名为Tencent的公司Company companyTencent = companyDao.queryBuilder().where(CompanyDao.Properties.CompanyName.eq(\"Tencent\")).unique();if (companyTencent != null) &#123; //查询Employee表中属于Tencent公司且薪水小于10000的Employee List&lt;Employee&gt; employeeList = employeeDao.queryBuilder() .where(EmployeeDao.Properties.CompanyId.eq(companyTencent.getId()), EmployeeDao.Properties.Salary.lt(10000)) .list(); if (employeeList != null) &#123; for (Employee employee : employeeList) &#123; //进行删除 employeeDao.deleteByKey(employee.getId()); &#125; &#125; else &#123; Log.e(\"greendao_test\", \"delete:deleteList为空\"); &#125;&#125; else &#123; Log.e(\"greendao_test\", \"delete:company为空\");&#125; delete(Employee entity) 根据实体进行删除。举例：删除名为Tencent的公司。12345//查询Company表中名为Tencent的公司Company companyTencent = companyDao.queryBuilder().where(CompanyDao.Properties.CompanyName.eq(\"Tencent\")).unique();companyDao.delete(companyTencent); deleteAll() 若需删除表中所有实体，则调用此方法。举例：删除所有雇员。1employeeDao.deleteAll(); 更新 若需对某个已存入数据库实体的属性进行修改，则需进行update操作。举例：修改Netease公司中薪水小于等于13000人的名字1234567891011121314151617181920212223//查询Company表中名为Netease的公司Company companyNetease = companyDao.queryBuilder().where(CompanyDao.Properties.CompanyName.eq(\"Netease\")).unique();if (companyNetease != null) &#123; //查询Employee表中查询Employee表中属于Netease公司且薪水小于等于13000人的Employee List&lt;Employee&gt; employeeList = employeeDao.queryBuilder() .where(EmployeeDao.Properties.CompanyId.eq(companyNetease.getId()), EmployeeDao.Properties.Salary.le(13000)) .list(); if (employeeList != null) &#123; for (Employee employee : employeeList) &#123; //修改属性 employee.setEmployeeName(\"baozi\"); //进行更新 employeeDao.update(employee); &#125; &#125; else &#123; Log.e(\"greendao_test\", \"update:updateList为空\"); &#125;&#125; else &#123; Log.e(\"greendao_test\", \"update:company为空\");&#125; 总结 到此，这一篇关于GreenDao3.0的使用就讲解完毕了，可结合上一篇集成与注解详解一起看。 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者不懂的地方也可以在我Github上GreenDaoDemo项目的Issues中提出，我会及时解答。附上GreenDaoDemo的地址： GreenDaoDemo","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"GreenDao","slug":"GreenDao","permalink":"http://LeiHolmes.github.io/tags/GreenDao/"}]},{"title":"Android开发ORM框架之GreenDao3.0集成与注解(一)","slug":"Android开发ORM框架之GreenDao3.0集成与注解(一)","date":"2017-07-09T16:00:00.000Z","updated":"2017-07-13T08:20:17.000Z","comments":true,"path":"2017/07/10/Android开发ORM框架之GreenDao3.0集成与注解(一)/","link":"","permalink":"http://LeiHolmes.github.io/2017/07/10/Android开发ORM框架之GreenDao3.0集成与注解(一)/","excerpt":"GreenDao简介 GreenDao是一个将对象映射到SQLite数据库中的轻量且快速的ORM数据库框架，本文将讲解如何集成GreenDao3.0环境，如何使用GreenDao自动生成代码及注解的使用。","text":"GreenDao简介 GreenDao是一个将对象映射到SQLite数据库中的轻量且快速的ORM数据库框架，本文将讲解如何集成GreenDao3.0环境，如何使用GreenDao自动生成代码及注解的使用。 GreenDao官网 GreenDao GitHub GreenDao3.0优势 GreenDao相较于ORMLite等其他数据库框架有以下优势： 1. 一个精简的库 2. 性能最大化 3. 内存开销最小化 4. 易于使用的 APIs 5. 对 Android 进行高度优化 而GreenDao3.0的版本主要使用注解方式定义实体类，通过gradle插件生成相应的代码。相较于3.0之前的版本集成步骤更为便捷，使用起来也更为简单。本文使用的版本为3.2.0。 集成项目下build.gradle GitHub中提示添加maven仓库，但是AndroidStudio项目已经默认包含了jcenter仓库，而jcenter仓库就是maven仓库的一个分支，因此不需要再添加仓库，直接添加classPath即可。123456789buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.2' classpath 'org.greenrobot:greendao-gradle-plugin:3.2.1' &#125;&#125; app下build.gradle 在app下build.gradle文件中我们需要声明GreenDao插件，及配置GreenDao生成dao路径等信息，声明GreenDao依赖。12345678910111213141516apply plugin: 'org.greenrobot.greendao'......greendao &#123; schemaVersion 1 //数据库版本号 daoPackage 'com.holmeslei.greendaodemo.database' //设置时生成代码的目录 targetGenDir 'src/main/java' //设置DaoMaster、DaoSession、Dao目录 //targetGenDirTest：设置生成单元测试目录 //generateTests：设置自动生成单元测试用例&#125;dependencies &#123; ...... compile 'org.greenrobot:greendao:3.2.0'&#125; 初始化实体编写实体类 集成好使用环境后需要初始化实体，首先编写实体类。这里演示使用公司Company与雇员Employer实体例子。使用@Entity注解。莫急，注解机制在之后小节有详细讲解。123456789@Entitypublic class Company &#123; @Id(autoincrement = true) //自增 private Long id; //主键 private String companyName; //公司名称 private String industry; //行业 @ToMany(referencedJoinProperty = \"companyId\") //设置外键companyId private List&lt;Employee&gt; employeeList; //公司与雇员建立一对多关系&#125; 12345678@Entitypublic class Employee &#123; @Id(autoincrement = true) private Long id; //主键 private long companyId; //指向Company主键 private String employeeName; //雇员姓名 private int salary; //薪水&#125; 生成代码 实体类与注解添加完毕后编译项目，就会为所有带注解的实体生成Dao文件，及DaoMaster与DaoSession。若未在build.gradle中配置过则默认生成目录为build/generated/source。若配置过则生成在配置的目录下。 编译项目 生成代码 注解 3.0之后最大的不同就是使用的注解来配置实体类属性，便捷且灵活。下面来看一下各类注解： 实体类注解123456789101112@Entity( schema = \"myschema\", active = true, nameInDb = \"AWESOME_USERS\", indexes = &#123; @Index(value = \"name DESC\", unique = true) &#125;, createInDb = false)public class Company &#123; ......&#125; @Entity：用于标识当前实体需要GreenDao生成代码。 schema：项目中存在多个Schema时，表明当前实体属于哪个Schema。 active：标记实体是否处于活动状态，活动状态才支持更新删除刷新等操作。 nameInDb：存储在数据库中的表名，不写默认与类名一致。 indexes：定义索引，可跨越多个列。 createInDb：标记创建数据库表，若有多个实体关联此表可设为false避免重复创建，默认为true。 属性注解 @Id :主键Long型，可以通过@Id(autoincrement = true)设置自增长。 @Property：设置一个非默认关系映射所对应的列名，默认是的使用字段名例如@Property (nameInDb=&quot;name&quot;)。 @NotNul：设置数据库表当前列不能为空。 @OrderBy：指定排序。 @Transient：添加此标记之后不会生成数据库表的列。 @Generated：为build之后GreenDao自动生成的注解，为防止重复，每一块代码生成后会加个hash作为标记。 索引注解123456789101112131415@Entitypublic class Company &#123; @Id(autoincrement = true) private Long id; @Index(unique = true) private String industry;&#125; @Entitypublic class Employee &#123; @Id(autoincrement = true) private Long id; @Unique private String employeeName;&#125; @Index：创建索引，通过设置name设置别名，设置unique添加约束。 @Unique：添加唯一约束与(unique = true)作用相同。 关系注解 @ToOne：定义与另一实体一对一的关联。 123456789101112131415@Entitypublic class Company &#123; @Id (autoincrement = true) private Long id; private long customerId; @ToOne(joinProperty = \"employeeId\") private Employee employee;&#125; @Entitypublic class Employee &#123; @Id(autoincrement = true) private Long id; private String employeeName;&#125; @ToMany：定义与多个实体对象一对多的关联，referencedJoinProperty为外键约束。 @JoinProperty：标明目标属性的源属性。 @JoinEntity：建立表连接关系。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//第一种：Employee实体通过外键companyId指向Company实体的主键Id建立一对多关联@Entitypublic class Company &#123; @Id(autoincrement = true) private Long id; private String companyName; private String industry; @ToMany(referencedJoinProperty = \"companyId\") private List&lt;Employee&gt; employeeList;&#125; @Entitypublic class Employee &#123; @Id(autoincrement = true) private Long id; private long companyId; private String employeeName; private int salary;&#125;//第二种：Employee以companyId为外键，与Company非主键不为空的键employeeTag建立一对多关联。@Entitypublic class Company &#123; @Id(autoincrement = true) private Long id; private String companyName; private String industry; @ToMany(joinProperties = &#123; @JoinProperty(name = \"employeeTag\", referencedName = \"companyId\") &#125;) private List&lt;Employee&gt; employeeList;&#125; @Entitypublic class Employee &#123; @Id(autoincrement = true) private Long id; private String employeeName; private int salary; @NotNull private String companyId;&#125; //第三种：通过第三者实体类建立关联，用的较少@Entitypublic class Employee &#123; @Id(autoincrement = true) private Long id; private String employeeName; private int salary; @ToMany @JoinEntity( entity = JoinEmployeeToCompany.class, sourceProperty = \"employeeId\", targetProperty = \"companyId\" ) private List&lt;Company&gt; companyList;&#125; @Entitypublic class JoinEmployeeToCompany &#123; @Id(autoincrement = true) private Long id; private Long employeeId; private Long companyId;&#125; @Entitypublic class Company &#123; @Id(autoincrement = true) private Long id; private String companyName; private String industry; &#125; 总结 到此，这一篇关于GreenDao3.0的集成与注解就讲解完毕了，欢迎参看下一篇关于如何使用GreenDao3.0对数据库进行增删改查。 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者不懂的地方也可以在我Github上GreenDaoDemo项目的Issues中提出，我会及时解答。附上GreenDaoDemo的地址： GreenDaoDemo","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"GreenDao","slug":"GreenDao","permalink":"http://LeiHolmes.github.io/tags/GreenDao/"}]},{"title":"Android开发之DataBinding基本实现","slug":"Android开发之DataBinding基本实现","date":"2017-05-14T16:00:00.000Z","updated":"2017-07-10T07:01:31.000Z","comments":true,"path":"2017/05/15/Android开发之DataBinding基本实现/","link":"","permalink":"http://LeiHolmes.github.io/2017/05/15/Android开发之DataBinding基本实现/","excerpt":"DataBinding简介 DataBinding是基于MVVM思想实现数据与UI绑定的框架，有了Data Binding，在Android中也可以很方便的实现MVVM。它于2015年7月由Google在Studio1.3上引入，2016年4月在Studio2.0上得到正式支持。DataBinding是一个support库，最低支持到Android2.1（API Level 7+）。","text":"DataBinding简介 DataBinding是基于MVVM思想实现数据与UI绑定的框架，有了Data Binding，在Android中也可以很方便的实现MVVM。它于2015年7月由Google在Studio1.3上引入，2016年4月在Studio2.0上得到正式支持。DataBinding是一个support库，最低支持到Android2.1（API Level 7+）。 在引入DataBinding之前，我们需要敲很多很鸡肋的代码，如 findViewById()、setText()，setVisibility()，setEnabled() 或 setOnClickListener() 等，通过 DataBinding , 我们可以通过声明式布局以精简的代码来绑定应用程序逻辑和布局，这样就不用编写大量的冗余的代码了。这一节我们来讲一讲DataBinding的基本实现之常量绑定、变量绑定与事件绑定。 初始化在build.gradle中添加123456android &#123; dataBinding &#123; enabled = true; &#125; ......&#125; 在xml文件最外层结构添加1234&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\"&gt; ......&lt;/layout&gt; 即是将最外层标签改为&lt;layout&gt;&lt;/layout&gt; 替换原setContentView方法1ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main); 命名规则：这里的ActivityMainBinding命名由来是其layout名称转换为驼峰形式再加上”Binding得到”。例如activity_main-&gt;ActivityMainBinding。 开始绑定常量绑定 在xml中：1234&lt;TextView android:id=\"@+id/text_view1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; 在Activity中：1binding.textView1.setText(\"Helloworld\"); 命名规则：控件id带下划线时，调用时使用其id的驼峰命名形式 。不带下划线时，调用时与id一致。例如id为text_view1，调用时使用binding.textView1。 变量绑定 首先创建一个简单的数据来源类MyBean：123456789101112131415161718192021222324252627package com.sherlock.databindingdemo;public class MyBean &#123; private String name; private int age; public MyBean(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 然后在xml文件layout标签下添加：123456&lt;data&gt; &lt;variable name=\"mybean\" type=\"com.sherlock.databindingdemo.MyBean\" /&gt; &lt;/data&gt;&lt;!--name：提供数据的bean的别名；type：bean的类名--&gt; 在控件中设置变量绑定：123456&lt;TextView android:id=\"@+id/text_view1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginRight=\"10dp\" android:text=\"@&#123;mybean.name&#125;\"/&gt; 在Activity中设置数据：12binding.setMybean(myBean);//binding.setVariable(BR.mybean,myBean); //另一种方法 注意：@{mybean.name}中的name必须为String类型，若要绑定别的类型，比如int类型，可以这样@{String.valueOf(mybean.age)}。 事件绑定 当然我们也可以用DataBinding实现事件绑定，它有两种实现方式。 第一种：首先添加一个事件回调类Presenter，这里演示Click与TextChange事件:123456789public class Presenter &#123; public void onTextChanged(CharSequence s, int start, int before, int count) &#123; myBean.setName(s.toString()); binding.setMybean(myBean); &#125; public void onClick(View view)&#123; Toast.makeText(MainActivity.this, \"点击成功\", Toast.LENGTH_SHORT).show(); &#125;&#125; 注意：使用这种事件绑定方式，Presenter中的方法需和控件监听方法完全一致。 在xml中：1234567891011121314151617&lt;data&gt; &lt;variable name=\"presenter\" type=\"com.sherlock.databindingdemo.MainActivity.Presenter\" /&gt;&lt;/data&gt;&lt;EditText android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:onTextChanged=\"@&#123;presenter.onTextChanged&#125;\" /&gt; &lt;!--或者@&#123;presenter::onTextChanged&#125;--&gt;&lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"@&#123;presenter.onClick&#125;\" /&gt; &lt;!--或者@&#123;presenter::onClick&#125;--&gt; 在Activity中：1binding.setPresenter(new Presenter()); 第二种：也可以设置自定义的监听器Binding，可回传参数，需要使用Lambda表达式： 在xml中：12345&lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"@&#123;() -&gt; presenter.onButtonClick(mybean)&#125;\" /&gt; &lt;!--或者@&#123;(view) -&gt; presenter.onButtonClick(mybean)&#125;--&gt; 在Presenter中：123public void onButtonClick(MyBean myBean)&#123; Toast.makeText(MainActivity.this, myBean.getName(), Toast.LENGTH_SHORT).show();&#125; 注意：使用这种事件绑定，Presenter中的监听方法就不需要与View的监听方法完全一致了，而且可以获取View在事件中回传的数据。 总结 这一节到此DataBinding的常量，变量，事件绑定的用法就讲解完毕了，实际操作起来感觉目前AndroidStudio对DataBinding的支持还不够，排错有点费劲，有时会出现找不到DataBinding的错误，这时应先查看下是否由于自己修改了某个类名，而xml调用时没有修改导致。若没有问题则删除app下的build文件夹重新Rebuild下项目试试。 首次接触DataBinding，可能有写的不对的地方欢迎大神们留言指正，有什么疑惑或者不懂的地方也可以在我Github上DataBindingDemo项目的Issues中提出，我会及时解答。附上DataBindingDemo地址： DataBindingDemo","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"DataBinding","slug":"DataBinding","permalink":"http://LeiHolmes.github.io/tags/DataBinding/"}]},{"title":"Android开发之RecyclerView初尝试","slug":"Android开发之RecyclerView初尝试","date":"2017-03-27T16:00:00.000Z","updated":"2017-07-10T07:01:37.000Z","comments":true,"path":"2017/03/28/Android开发之RecyclerView初尝试/","link":"","permalink":"http://LeiHolmes.github.io/2017/03/28/Android开发之RecyclerView初尝试/","excerpt":"RecyclerView简介 RecyclerView是一种新的视图组，目标是为任何基于适配器的视图提供相似的渲染方式。它被作为ListView和GridView控件的继承者，具有更优的灵活性与可替代性。在最新的support-v7版本中提供支持。本文将讲解RecyclerView的简单实现，添加删除条目，点击事件添加与瀑布流的实现。","text":"RecyclerView简介 RecyclerView是一种新的视图组，目标是为任何基于适配器的视图提供相似的渲染方式。它被作为ListView和GridView控件的继承者，具有更优的灵活性与可替代性。在最新的support-v7版本中提供支持。本文将讲解RecyclerView的简单实现，添加删除条目，点击事件添加与瀑布流的实现。 相关原理与简单实现添加依赖 在AndroidStudio的build.gradle中添加依赖： dependencies { ... compile &#39;com.android.support:recyclerview-v7:25.3.0&#39; } 在布局中使用 添加完依赖后就可以在布局中使用RecyclerView了： &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/main_recyclerview\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; RecyclerView.Adapter RecyclerView封装了一种新型的适配器，与现在使用的适配器大同小异。它强制用户使用RecyclerView提供的ViewHolder，使用时主要需要重写onCreateViewHolder与onBindViewHolder方法。前者用来展现视图及其持有者，且只有真正需要一个新view时才会被回调，不需要检查是否已经被回收。后者用来绑定数据到View上。 import android.content.Context; import android.support.v7.widget.RecyclerView; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; import java.util.List; public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; { private Context context; private List&lt;String&gt; list; private LayoutInflater inflater; public MyAdapter(Context context, List&lt;String&gt; list) { this.context = context; this.list = list; inflater = LayoutInflater.from(context); } @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = inflater.inflate(R.layout.item_recyclerview, parent, false); MyViewHolder holder = new MyViewHolder(view); return holder; } @Override public void onBindViewHolder(MyViewHolder holder, int position) { holder.textView.setText(list.get(position)); } @Override public int getItemCount() { return list.size(); } class MyViewHolder extends RecyclerView.ViewHolder { TextView textView; public MyViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.item_textview); } } } LayoutManager RecyclerView通过布局管理器LayoutManager控制每一个item如何进行排列摆放，何时展示和隐藏。回收或重用一个View时LayoutManager会向适配器请求新的数据来替换旧的数据，这种机制避免了创建过多的View和频繁的调用findViewById方法，目前其自带的主要有以下三种： - LinearLayoutManager：ListView样式 - GridLayoutManager：GridView样式 - StaggeredGridLayoutManager：瀑布流样式 ItemDecoration RecyclerView并不能像ListView一样直接在xml布局中修改item分割线样式。需要在Activity动态设置，当然更推荐在单个条目布局中设置margin或者padding来实现分割线效果，这里提供一个分割线。 import android.content.Context; import android.content.res.TypedArray; import android.graphics.Canvas; import android.graphics.Rect; import android.graphics.drawable.Drawable; import android.support.v7.widget.LinearLayoutManager; import android.support.v7.widget.RecyclerView; import android.view.View; public class DividerItemDecoration extends RecyclerView.ItemDecoration { private static final int[] ATTRS = new int[]{ android.R.attr.listDivider }; public static final int HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL; public static final int VERTICAL_LIST = LinearLayoutManager.VERTICAL; private Drawable mDivider; private int mOrientation; public DividerItemDecoration(Context context, int orientation) { final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); a.recycle(); setOrientation(orientation); } public void setOrientation(int orientation) { if (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) { throw new IllegalArgumentException(\"invalid orientation\"); } mOrientation = orientation; } @Override public void onDraw(Canvas c, RecyclerView parent) { if (mOrientation == VERTICAL_LIST) { drawVertical(c, parent); } else { drawHorizontal(c, parent); } } public void drawVertical(Canvas c, RecyclerView parent) { final int left = parent.getPaddingLeft(); final int right = parent.getWidth() - parent.getPaddingRight(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int top = child.getBottom() + params.bottomMargin; final int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); } } public void drawHorizontal(Canvas c, RecyclerView parent) { final int top = parent.getPaddingTop(); final int bottom = parent.getHeight() - parent.getPaddingBottom(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int left = child.getRight() + params.rightMargin; final int right = left + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); } } @Override public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) { if (mOrientation == VERTICAL_LIST) { outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); } else { outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); } } } ItemAnimator ItemAnimator会根据适配器上收到的通知来动画显示视图组的修改，比如item的添加与删除。DefaultItemAnimator已经能很好的展现动画效果了。 RecyclerView初始化 若想初始化一个RecyclerView使其进入工作状态，你需要在Activity中做以下的操作： RecyclerView recyclerView = (RecyclerView)findViewById(R.id.recycler_view_main); MyAdapter adapter = new MyAdapter(this, list); //设置RecyclerView保持固定的大小 recyclerView.setHasFixedSize(true); //设置适配器 recyclerView.setAdapter(adapter); //设置RecyclerView ListView样式布局管理 recyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)); //设置RecyclerView的Item分割线 recyclerView.addItemDecoration(new DividerItemDecoration(this, DividerItemDecoration.VERTICAL_LIST)); //设置RecyclerView的动画 recyclerView.setItemAnimator(new DefaultItemAnimator()); //设置RecyclerView GridView样式 //recyclerView.setLayoutManager(new GridLayoutManager(MainActivity.this, 3)); //设置RecyclerView 水平GridView样式 //recyclerView.setLayoutManager(new StaggeredGridLayoutManager(5, StaggeredGridLayoutManager.HORIZONTAL)); //设置RecyclerView 瀑布流样式 //recyclerView.setLayoutManager(new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL)); 点击事件与添加删除Item 美中不足的是RecyclerView并没有提供像ListView一样的Item点击与Item长点击事件，不提供咱们就自己造，通过接口回调来实现。 Adapter中import android.content.Context; import android.support.v7.widget.RecyclerView; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; import java.util.ArrayList; public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; { private Context context; private LayoutInflater inflater; protected ArrayList&lt;String&gt; datas; private onItemClickedListener onItemClickedListener; public MyAdapter(Context context, ArrayList&lt;String&gt; datas) { this.context = context; this.datas = datas; inflater = LayoutInflater.from(context); } public void setOnItemClickedListener(MyAdapter.onItemClickedListener onItemClickedListener) { this.onItemClickedListener = onItemClickedListener; } @Override public void onBindViewHolder(MyViewHolder holder, int position) { holder.textView.setText(datas.get(position)); } @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = inflater.inflate(R.layout.item_recycler_view, parent, false); MyViewHolder myViewHolder = new MyViewHolder(view); return myViewHolder; } @Override public int getItemCount() { return datas.size(); } /** * 添加条目 */ public void addItem(int position) { datas.add(position, \"xulei\"); // notifyDataSetChanged(); notifyItemInserted(position);//调用这个才有动画效果 } /** * 移除条目 */ public void removeItem(int position) { datas.remove(position); notifyItemRemoved(position); } class MyViewHolder extends RecyclerView.ViewHolder { TextView textView; public MyViewHolder(View itemView) { super(itemView); //初始化控件 textView = (TextView) itemView.findViewById(R.id.item_textview); //设置当前条目单击监听 itemView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { if (onItemClickedListener != null) onItemClickedListener.onClick(view, getAdapterPosition());//可立刻获取到当前position // onItemClickedListener.onClick(view, getLayoutPosition());//需等当前视图更新完才能获取到当前position，&lt;16ms。 } }); //设置当前条目长按监听 itemView.setOnLongClickListener(new View.OnLongClickListener() { @Override public boolean onLongClick(View view) { if (onItemClickedListener != null) onItemClickedListener.onLongClick(view, getAdapterPosition()); return false; } }); } } /** * 点击回调的接口 */ interface onItemClickedListener { void onClick(View view, int position); void onLongClick(View view, int position); } } Activity中 在Activity中实例化Adapter之后添加如下代码： adapter.setOnItemClickedListener(new MyAdapter.onItemClickedListener() { @Override public void onClick(View view, int position) { adapter.addItem(position); Toast.makeText(MainActivity.this, \"点击click:\" + position, Toast.LENGTH_SHORT).show(); } @Override public void onLongClick(View view, int position) { adapter.removeItem(position); Toast.makeText(MainActivity.this, \"长按click:\" + position, Toast.LENGTH_SHORT).show(); } }); 瀑布流的实现 想实现瀑布流的样式通过使用RecyclerView也很容易就能实现。 首先在Activity中设置LayoutManager时选择：recyclerView.setLayoutManager(new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL)); 修改Adapter 瀑布流自然是每个条目的高度不同才能出现瀑布的效果（水平布局则是宽度不同），那么只需在每个条目绑定数据时动态改变下其高度即可，贴出瀑布流Adapter代码： import android.content.Context; import android.view.ViewGroup; import java.util.ArrayList; import java.util.List; public class StaggerAdapter extends MyAdapter { private List&lt;Integer&gt; heights; public StaggerAdapter(Context context, ArrayList&lt;String&gt; datas) { super(context, datas); heights = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; datas.size(); i++) { heights.add((int) (100 + Math.random() * 300)); } } @Override public void onBindViewHolder(MyViewHolder holder, int position) { ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams(); layoutParams.height = heights.get(position); // layoutParams.width = heights.get(position); holder.itemView.setLayoutParams(layoutParams); holder.textView.setText(datas.get(position)); } } 总结 通过实践发现RecyclerView相较于ListView与GridView确实强大很多，更加的灵活与方便，提高了开发效率。但也有不足之处，如并未封装点击事件的回调，确实是比较头疼。期待Google的完善。附上GitHub源码：RecyclerViewDemoRecyclerViewDevelop","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://LeiHolmes.github.io/tags/RecyclerView/"}]},{"title":"Android开发之AlarmManager闹钟+Notification通知","slug":"Android开发之AlarmManager闹钟+Notification通知","date":"2016-12-12T16:00:00.000Z","updated":"2017-07-10T07:01:23.000Z","comments":true,"path":"2016/12/13/Android开发之AlarmManager闹钟+Notification通知/","link":"","permalink":"http://LeiHolmes.github.io/2016/12/13/Android开发之AlarmManager闹钟+Notification通知/","excerpt":"AlarmManager简介 AlarmManager实质是一个全局的定时器，是Android中常用的一种系统级别的提示服务，在指定时间或周期性启动其它组件（包括Activity,Service,BroadcastReceiver）。本文将讲解一下如何使用AlarmManager实现定时提醒功能。","text":"AlarmManager简介 AlarmManager实质是一个全局的定时器，是Android中常用的一种系统级别的提示服务，在指定时间或周期性启动其它组件（包括Activity,Service,BroadcastReceiver）。本文将讲解一下如何使用AlarmManager实现定时提醒功能。 闹钟配置周期闹钟12345Intent intent = new Intent();intent.setAction(GlobalValues.TIMER_ACTION_REPEATING);PendingIntent sender = PendingIntent.getBroadcast(context, 0, intent, 0);AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);alarm.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + 5 * 1000, 3 * 1000, sender); 1setRepeating(int type,long startTime,long intervalTime,PendingIntent pi) 该方法用于设置周期性执行的定时服务。type：闹钟类型，startTime：闹钟首次执行时间，intervalTime：闹钟两次执行的间隔时间，pi：闹钟响应动作。1setInexactRepeating(int type,long startTime,long intervalTime,PendingIntent pi) 该方法也用于设置周期定式服务，与上一种类似。不过其两个闹钟执行的间隔时间不是固定的。它相对而言更省电一些，因为系统可能会将几个差不多的闹钟合并为一个来执行，减少设备的唤醒次数。 intervalTime内置变量间隔一天： INTERVAL_DAY间隔半天： INTERVAL_HALF_DAY间隔15分钟： INTERVAL_FIFTEEN_MINUTES间隔半个小时： INTERVAL_HALF_HOUR间隔一个小时： INTERVAL_HOUR 定时闹钟123456789//获得系统提供的AlarmManager服务的对象AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);//Intent设置要启动的组件，这里启动广播Intent myIntent = new Intent();myIntent.setAction(GlobalValues.TIMER_ACTION);//PendingIntent对象设置动作,启动的是Activity还是Service,或广播!PendingIntent sender = PendingIntent.getBroadcast(context, 0, myIntent,0);//注册闹钟alarm.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + 5 * 1000, sender); 1set(int type,long startTime,PendingIntent pi) 该方法用于设置一次性定时服务。type：闹钟类型，startTime：闹钟执行时间，pi：闹钟响应动作。 取消闹钟123456Intent myIntent = new Intent();myIntent.setAction(GlobalValues.TIMER_ACTION);//myIntent.setAction(GlobalValues.TIMER_ACTION_REPEATING);PendingIntent sender = PendingIntent.getBroadcast(context, 0, myIntent,0);AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);alarm.cancel(sender); 设置多个闹钟： 若连续设置多个闹钟，则只有最后一个闹钟会生效，那么这种情况我们怎么处理呢？其实很简单。我们可以给每个闹钟设置唯一的id，传入getBroadcast()第二个参数。在这里我是每设置一个id则自增1存入Shareprefrence里，保证id唯一性。1234 //给每个闹钟设置不同ID防止覆盖int alarmId = SharedPreUtils.getInteger(context, \"alarm_id\", 0);SharedPreUtils.setInteger(context, \"alarm_id\", ++alarmId);PendingIntent sender = PendingIntent.getBroadcast(context, alarmId, myIntent, 0); 在取消闹钟时我们也可以根据这个id关闭不同的闹钟。 参数详解type：闹钟类型ELAPSED_REALTIME： 在指定的延时过后，发送广播，但不唤醒设备（闹钟在睡眠状态下不可用）。如果在系统休眠时闹钟触发，它将不会被传递，直到下一次设备唤醒。ELAPSED_REALTIME_WAKEUP： 在指定的延时过后，发送广播，并唤醒设备（即使关机也会执行operation所对应的组件） 。延时是要把系统启动的时间SystemClock.elapsedRealtime()算进去的。RTC： 指定当系统调用System.currentTimeMillis()方法返回的值与triggerAtTime相等时启动operation所对应的设备（在指定的时刻，发送广播，但不唤醒设备）。如果在系统休眠时闹钟触发，它将不会被传递，直到下一次设备唤醒（闹钟在睡眠状态下不可用）。RTC_WAKEUP： 指定当系统调用System.currentTimeMillis()方法返回的值与triggerAtTime相等时启动operation所对应的设备（在指定的时刻，发送广播，并唤醒设备）。即使系统关机也会执行operation所对应的组件。POWER_OFF_WAKEUP： 表示闹钟在手机关机状态下也能正常进行提示功能，所以是5个状态中用的最多的状态之一，该状态下闹钟也是用绝对时间，状态值为4；不过本状态好像受SDK版本影响，某些版本并不支持。 long intervalTime：执行时间 闹钟的第一次执行时间，以毫秒为单位，可以自定义时间，不过一般使用当前时间。需要注意的是，本属性与第一个属性（type）密切相关，如果第一个参数对应的闹钟使用的是相对时间（ELAPSED_REALTIME和ELAPSED_REALTIME_WAKEUP），那么本属性就得使用相对时间（相对于系统启动时间来说），比如当前时间就表示为：SystemClock.elapsedRealtime();如果第一个参数对应的闹钟使用的是绝对时间（RTC、RTC_WAKEUP、POWER_OFF_WAKEUP），那么本属性就得使用绝对时间，比如当前时间就表示为：System.currentTimeMillis() long startTime：间隔时间 对于周期定时方式来说，存在本属性，表示两次闹钟执行的间隔时间，也是以毫秒为单位。 PendingIntent pi：执行动作 是闹钟的执行动作，比如发送一个广播、给出提示等等。PendingIntent是Intent的封装类。需要注意的是，如果是通过启动服务来实现闹钟提示的话，PendingIntent对象的获取就应该采用Pending.getService(Context c,int i,Intent intent,int j)方法；如果是通过广播来实现闹钟提示的话，PendingIntent对象的获取就应该采用PendingIntent.getBroadcast(Context c,int i,Intent intent,int j)方法；如果是采用Activity的方式来实现闹钟提示的话，PendingIntent对象的获取就应该采用PendingIntent.getActivity(Context c,int i,Intent intent,int j)方法。如果这三种方法错用了的话，虽然不会报错，但是看不到闹钟提示效果。。 广播配置新建闹钟BroadCastReceiver：1234567891011121314151617181920212223242526272829public class AlarmReceiver extends BroadcastReceiver &#123; private NotificationManager m_notificationMgr = null; private static final int NOTIFICATION_FLAG = 3; @Override public void onReceive(Context context, Intent intent) &#123; m_notificationMgr = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVIC if (intent.getAction().equals(GlobalValues.TIMER_ACTION_REPEATING)) &#123; Log.e(\"alarm_receiver\", \"周期闹钟\"); &#125; else if (intent.getAction().equals(GlobalValues.TIMER_ACTION)) &#123; Log.e(\"alarm_receiver\", \"定时闹钟\"); Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.logo); Intent intent1 = new Intent(context, WriteDiaryActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent1, 0); Notification notify = new Notification.Builder(context) .setSmallIcon(R.drawable.logo) // 设置状态栏中的小图片，尺寸一般建议在24×24 .setLargeIcon(bitmap) // 这里也可以设置大图标 .setTicker(\"亲情日历\") // 设置显示的提示文字 .setContentTitle(\"亲情日历\") // 设置显示的标题 .setContentText(\"您有日记提醒哦\") // 消息的详细内容 .setContentIntent(pendingIntent) // 关联PendingIntent .setNumber(1) // 在TextView的右方显示的数字，可以在外部定义一个变量，点击累加setNumber(count),这时显示的和 .getNotification(); // 需要注意build()是在API level16及之后增加的，在API11中可以使用getNotificatin()来 notify.flags |= Notification.FLAG_AUTO_CANCEL; NotificationManager manager = (NotificationManager) context.getSystemService(Context.NOTIF manager.notify(NOTIFICATION_FLAG, notify); bitmap.recycle(); //回收bitmap &#125; &#125;&#125; 注册BroadCastReceiver： 最后别忘了在清单里注册广播。1234567&lt;!--闹钟接收广播--&gt;&lt;receiver android:name=\".util.service.AlarmReceiver\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.e_eduspace.TIMER_ACTION_REPEATING\" /&gt; &lt;action android:name=\"com.e_eduspace.TIMER_ACTION\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 附件常量：123456public class GlobalValues &#123; // 周期性的闹钟 public final static String TIMER_ACTION_REPEATING = \"com.e_eduspace.TIMER_ACTION_REPEATING\"; // 定时闹钟 public final static String TIMER_ACTION = \"com.e_eduspace.TIMER_ACTION\";&#125; 工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.e_eduspace.familycalendar.util;import android.app.AlarmManager;import android.app.PendingIntent;import android.content.Context;import android.content.Intent;import com.prolificinteractive.materialcalendarview.CalendarDay;/** * 闹钟定时工具类 * * @author xulei * @time 2016/12/13 10:03 */public class AlarmTimer &#123; /** * 设置周期性闹钟 * * @param context * @param firstTime * @param cycTime * @param action * @param AlarmManagerType 闹钟的类型，常用的有5个值：AlarmManager.ELAPSED_REALTIME、 * AlarmManager.ELAPSED_REALTIME_WAKEUP、AlarmManager.RTC、 * AlarmManager.RTC_WAKEUP、AlarmManager.POWER_OFF_WAKEUP */ public static void setRepeatingAlarmTimer(Context context, long firstTime, long cycTime, String action, int AlarmManagerType) &#123; Intent myIntent = new Intent(); myIntent.setAction(action); PendingIntent sender = PendingIntent.getBroadcast(context, 0, myIntent, 0); AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE); alarm.setRepeating(AlarmManagerType, firstTime, cycTime, sender); //param1：闹钟类型，param1：闹钟首次执行时间，param1：闹钟两次执行的间隔时间，param1：闹钟响应动作。 &#125; /** * 设置定时闹钟 * * @param context * @param cycTime * @param action * @param AlarmManagerType 闹钟的类型，常用的有5个值：AlarmManager.ELAPSED_REALTIME、 * AlarmManager.ELAPSED_REALTIME_WAKEUP、AlarmManager.RTC、 * AlarmManager.RTC_WAKEUP、AlarmManager.POWER_OFF_WAKEUP */ public static void setAlarmTimer(Context context, long cycTime, String action, int AlarmManagerType, CalendarDay date) &#123; Intent myIntent = new Intent(); //传递定时日期 myIntent.putExtra(\"date\", date); myIntent.setAction(action); //给每个闹钟设置不同ID防止覆盖 int alarmId = SharedPreUtils.getInteger(context, \"alarm_id\", 0); SharedPreUtils.setInteger(context, \"alarm_id\", ++alarmId); PendingIntent sender = PendingIntent.getBroadcast(context, alarmId, myIntent, 0); AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE); alarm.set(AlarmManagerType, cycTime, sender); &#125; /** * 取消闹钟 * * @param context * @param action */ public static void cancelAlarmTimer(Context context, String action) &#123; Intent myIntent = new Intent(); myIntent.setAction(action); PendingIntent sender = PendingIntent.getBroadcast(context, 0, myIntent,0); AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE); alarm.cancel(sender); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"AlarmManager","slug":"AlarmManager","permalink":"http://LeiHolmes.github.io/tags/AlarmManager/"}]},{"title":"Android开发网络请求框架之Retrofit2.0初尝试","slug":"Android开发网络请求框架之Retrofit2.0初尝试","date":"2016-04-28T16:00:00.000Z","updated":"2017-07-21T06:10:36.000Z","comments":true,"path":"2016/04/29/Android开发网络请求框架之Retrofit2.0初尝试/","link":"","permalink":"http://LeiHolmes.github.io/2016/04/29/Android开发网络请求框架之Retrofit2.0初尝试/","excerpt":"Retrofit2.0简介 Retrofit是一套RESTful架构的Android(Java)客户端实现，基于注解，提供JSON to POJO(Plain Ordinary Java Object,简单Java对象)，POJO to JSON，网络请求(POST，GET,PUT，DELETE等)封装。用官方自己的介绍就是: A type-safe REST client for Android and Java 现已更新到2.0的版本，与1.0版本的使用上还是不小的差别，我也是第一次用，这里主要和大家研究研究2.0版本简单使用。也可参详官方示例。","text":"Retrofit2.0简介 Retrofit是一套RESTful架构的Android(Java)客户端实现，基于注解，提供JSON to POJO(Plain Ordinary Java Object,简单Java对象)，POJO to JSON，网络请求(POST，GET,PUT，DELETE等)封装。用官方自己的介绍就是: A type-safe REST client for Android and Java 现已更新到2.0的版本，与1.0版本的使用上还是不小的差别，我也是第一次用，这里主要和大家研究研究2.0版本简单使用。也可参详官方示例。 准备工作添加权限 首先添加网络请求权限1&lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; 添加依赖 Retrofit2.0版本后只支持okhttp请求，也已经封装好了，就不需要添加okhttp的依赖了。1234dependencies &#123; compile 'com.squareup.retrofit2:retrofit:2.0.2' compile 'com.squareup.retrofit2:converter-gson:2.0.0-beta3'&#125; 简单使用 接下来瞧一瞧Retrofit初始化以及如何请求数据。 初始化Retrofit对象12345public static final String BASE_URL = \"https://api.github.com/\";Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .build(); BASE_URL就是你请求的Server地址。1.addConverterFactory(GsonConverterFactory.create()) Retrofit2.0不提供返回JSON数据的默认解析方式，需要手动指定，支持Jackson等多种解析方式。需要哪种就添加相应的依赖，这里添加的是Retrofit提供的converter-gson依赖。有点不爽的就是不支持FastJson解析，有需要的话可以自己写一个FastjsonConverterFactory继承Converter.Factory实现。 虽然Retrofit2.0后只支持okhttp请求，但你也可以自定义一个okhttp再配置进Retrofit。1234567891011121314OkHttpClient client = new OkHttpClient();client.interceptors().add(new Interceptor() &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Response response = chain.proceed(chain.request()); // Do anything with response here return response; &#125;Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .client(client) .addConverterFactory(GsonConverterFactory.create()) .build();&#125;); 定义请求接口 实现转换HTTP API为Java接口，Retrofit提供了5种内置的注解：GET、POST、PUT、DELETE和HEAD，在注解中指定的资源的相对URL。1234public interface NetWorkService &#123; @GET(\"users/basil2style\") Call&lt;DataBean&gt; getData();&#125; 使用替换块和参数进行动态更新,替换块是{ and }包围的字母数字组成的字符串，相应的参数必须使用相同的字符串被@Path进行注释。12345@GET(\"repos/&#123;params1&#125;/&#123;params2&#125;/contributors\")Call&lt;List&lt;DataBean2&gt;&gt; getData( @Path(\"params1\") String params1, @Path(\"params2\") String params2,); 当我们调用getData()这个方法的时候，Retrofit会创建这个URL。如果我们传入Square和Retrofit字符串，分别作为owner和repo参数。我们就会得到这个URL：https://api.github.com/repos/square/retrofit/contributors 添加查询参数12@GET(\"repos/square/&#123;retrofit&#125;/contributors\")Call&lt;List&lt;DataBean2&gt;&gt; groupData(@Path(\"retrofit\") String retrofit, @Query(\"sort\") String sort); 当我们调用getData()方法时，传入一个查询参数字符串”ok”,这样我们就能得到URL：https://api.github.com/repos/square/retrofit/contributors?sort=ok 当然如果查询参数过多，我们也可以使用Map进行组合再传进来。12@GET(\"repos/square/&#123;retrofit&#125;/contributors\")Call&lt;List&lt;DataBean2&gt;&gt; getData(@Path(\"repos\") String repos, @QueryMap Map&lt;String, String&gt; parameters); 请求数据 Retrifot支持同步和异步的请求方式，先使用Retrofit类生成接口NetWorkService的实现。1NetWorkService service = retrofit.create(NetWorkService.class); 同步请求12Call&lt;DataBean&gt; call = service.getData(Square,Retrofit);DataBean bean = call.execute().body(); 注意同步请求不可在主线程执行，你懂得。且call只能执行execute()方法一次，若要再次请求可通过Call&lt;DataBean&gt; call = call.clone()来再复制一个Call对象。 异步请求1234567891011call.enqueue(new Callback&lt;DataBean&gt;() &#123; @Override public void onResponse(Call&lt;DataBean&gt; call, Response&lt;DataBean&gt; response) &#123; Toast.makeText(MainActivity.this, \"请求成功\", Toast.LENGTH_SHORT).show(); DataBean bean = response.body(); tvMain.setText(bean.toString()); &#125; @Override public void onFailure(Call&lt;DataBean&gt; call, Throwable t) &#123; &#125;&#125;); 当我们执行的同步或异步加入队列后，可以随时使用call.cancel()方法取消请求。 注意 注解中参数的写法与BASE_URL的拼接一定要注意，请看以下写法。 错误示例1 BASE_URL：https://api.github.com/repos/square Get注解： @GET(“/basil2style”) 结果URL： https://api.github.com/basil2style 错误示例2 BASE_URL：https://api.github.com/repos/square Get注解： @GET(“basil2style”) 结果URL： https://api.github.com/repos/basil2style 推荐写法 BASE_URL：https://api.github.com/repos/square/ Get注解： @GET(“basil2style”) 结果URL： https://api.github.com/repos/square/basil2style 总结 Retrofit2.0的基本实现讲解完毕，Retrofit+Okhttp+Gson可以算是目前来说相当快的超级网络请求框架了。相比较于Volley都快不少，亲测结果很爽。小伙伴们赶紧整起来吧！ 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者不懂的地方也可以在我Github上Retrofit2Demo项目的Issues中提出，我会及时解答。附上GreenDaoDemo的地址： Retrofit2Demo","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"http://LeiHolmes.github.io/tags/Retrofit/"}]},{"title":"Android开发之神器Stetho调试Volley","slug":"Android开发之神器Stetho调试Volley","date":"2016-04-18T16:00:00.000Z","updated":"2017-07-10T07:01:16.000Z","comments":true,"path":"2016/04/19/Android开发之神器Stetho调试Volley/","link":"","permalink":"http://LeiHolmes.github.io/2016/04/19/Android开发之神器Stetho调试Volley/","excerpt":"Stetho简介 Stetho 是 Facebook 开源的一个 Android 调试工具。是一个 Chrome Developer Tools 的扩展，可用来检测应用的网络、数据库、WebKit 等方面的功能。开发者也可通过它的 dumpapp 工具提供强大的命令行接口来访问应用内部。无需root查看sqlite文件、sharedpreference文件等等。更多详细介绍可以进入Stetho官网。","text":"Stetho简介 Stetho 是 Facebook 开源的一个 Android 调试工具。是一个 Chrome Developer Tools 的扩展，可用来检测应用的网络、数据库、WebKit 等方面的功能。开发者也可通过它的 dumpapp 工具提供强大的命令行接口来访问应用内部。无需root查看sqlite文件、sharedpreference文件等等。更多详细介绍可以进入Stetho官网。 Stetho结合OkHttp使用添加依赖1234// Gradle dependency on Stetho dependencies &#123; compile 'com.facebook.stetho:stetho:1.1.1' &#125; Stetho初始化配置在App的Application中完成初始化。123456789101112public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); Stetho.initialize( Stetho.newInitializerBuilder(this) .enableDumpapp( Stetho.defaultDumperPluginsProvider(this)) .enableWebKitInspector( Stetho.defaultInspectorModulesProvider(this)) .build()); &#125;&#125; 官网中使用OkHttp为实例，使用如下12OkHttpClient client = new OkHttpClient();client.networkInterceptors().add(new StethoInterceptor()); 然后就可以运行App进行调试，基本上可以满足调试需求了。 Stetho结合Volley使用官网中Stetho是结合OkHttp的使用，如果项目中使用Volley做为网络请求框架，可以做如下修改。还是使用OkHttp做为Volley中HttpStack的实现，我们知道，Volley中网络请求在Android2.3及以上基于HttpURLConnection，2.3以下基于HttpClient实现，通过增加HttpStack的具体实现即可。这里使用Bryan Stern分享的代码。（网页可能被墙，可以通过VPN访问。需要VPN的可以点击这里） 添加依赖123compile 'com.facebook.stetho:stetho:1.1.1'compile 'com.facebook.stetho:stetho-okhttp:1.1.1'compile 'com.squareup.okhttp:okhttp:2.3.0' Stetho初始化配置123OkHttpClient client = new OkHttpClient();client.networkInterceptors().add(new StethoInterceptor());mRequestQueue = Volley.newRequestQueue(getApplicationContext(), new OkHttpStack(client)); 好了，基本上这样就能使用Stetho神器调试你的App了，感觉到强大了么~。 补充：使用中遇到的坑 Stetho inspect窗口空白 如果出现调试窗口空白，先升级下Chrome吧。升级最新版后再试一下（我被这个坑了）。 Stetho inspect窗口还是空白 如果Chrome是最新版，无论如何刷新都是空白，那么恭喜你你可能被墙了~用VPN试试吧 可以戳这里哦 我的测试代码和效果图如下：自定义Application类：12345678910111213141516171819202122232425262728293031public class MyAppliation extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); context = getApplicationContext(); instance = this; Stetho.initialize( Stetho.newInitializerBuilder(this) .enableDumpapp(Stetho.defaultDumperPluginsProvider(this)) .enableWebKitInspector(Stetho.defaultInspectorModulesProvider(this)) .build()); &#125; /** * @return The Volley Request queue */ public RequestQueue getRequestQueue() &#123; // lazy initialize the request queue, the queue instance will be // created when it is accessed for the first time synchronized (App.class) &#123; if (mRequestQueue == null) &#123; OkHttpClient client = new OkHttpClient(); client.networkInterceptors().add(new StethoInterceptor()); mRequestQueue = Volley.newRequestQueue(getApplicationContext(), new OkHttpStack(client)); &#125; &#125; return mRequestQueue; &#125;&#125; Activity类代码： 123456789101112131415161718192021222324252627282930public class MainActivity extends Activity &#123; private TextView tv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout_main); tv = (TextView)findViewById(R.id.tv); RequestQueue queue = App.getInstance().getRequestQueue(); String url = \"https://publicobject.com/helloworld.txt\"; StringRequest request = new StringRequest(Request.Method.GET, url, new Response.Listener&lt;String&gt;() &#123; @Override public void onResponse(String s) &#123; LogUtil.d(s); tv.setText(s); &#125; &#125;, new com.android.volley.Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError volleyError) &#123; LogUtil.e(volleyError.toString()); &#125; &#125;); queue.add(request); SharedPrfUtil.setInt(\"uid\",669); SharedPrfUtil.setString(\"username\",\"dongye\"); &#125;&#125; 实现效果如下图： Stetho调试效果图 调试程序列表 调试网络请求 读取数据存储","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"Stetho","slug":"Stetho","permalink":"http://LeiHolmes.github.io/tags/Stetho/"}]}]}