{"meta":{"title":"Lei’s Blog","subtitle":"不忘初心，淡然前行","description":null,"author":"徐雷","url":"http://LeiHolmes.github.io"},"pages":[{"title":"categories","date":"2017-05-10T06:00:40.000Z","updated":"2017-05-11T07:01:56.000Z","comments":false,"path":"categories/index.html","permalink":"http://LeiHolmes.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-05-10T05:55:45.000Z","updated":"2017-05-11T07:01:30.000Z","comments":false,"path":"tags/index.html","permalink":"http://LeiHolmes.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android开发之RecyclerView初尝试","slug":"Android开发之RecyclerView初尝试","date":"2017-03-28T02:26:00.000Z","updated":"2017-05-11T08:15:36.000Z","comments":true,"path":"2017/03/28/Android开发之RecyclerView初尝试/","link":"","permalink":"http://LeiHolmes.github.io/2017/03/28/Android开发之RecyclerView初尝试/","excerpt":"概述 RecyclerView是一种新的视图组，目标是为任何基于适配器的视图提供相似的渲染方式。它被作为ListView和GridView控件的继承者，具有更优的灵活性与可替代性。在最新的support-v7版本中提供支持。本文将讲解RecyclerView的简单实现，添加删除条目，点击事件添加与瀑布流的实现。","text":"概述 RecyclerView是一种新的视图组，目标是为任何基于适配器的视图提供相似的渲染方式。它被作为ListView和GridView控件的继承者，具有更优的灵活性与可替代性。在最新的support-v7版本中提供支持。本文将讲解RecyclerView的简单实现，添加删除条目，点击事件添加与瀑布流的实现。 相关原理与简单实现添加依赖 在AndroidStudio的build.gradle中添加依赖： dependencies { ... compile 'com.android.support:recyclerview-v7:25.3.0' } 在布局中使用 添加完依赖后就可以在布局中使用RecyclerView了： &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/main_recyclerview\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; RecyclerView.Adapter RecyclerView封装了一种新型的适配器，与现在使用的适配器大同小异。它强制用户使用RecyclerView提供的ViewHolder，使用时主要需要重写onCreateViewHolder与onBindViewHolder方法。前者用来展现视图及其持有者，且只有真正需要一个新view时才会被回调，不需要检查是否已经被回收。后者用来绑定数据到View上。 import android.content.Context; import android.support.v7.widget.RecyclerView; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; import java.util.List; public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; { private Context context; private List&lt;String&gt; list; private LayoutInflater inflater; public MyAdapter(Context context, List&lt;String&gt; list) { this.context = context; this.list = list; inflater = LayoutInflater.from(context); } @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = inflater.inflate(R.layout.item_recyclerview, parent, false); MyViewHolder holder = new MyViewHolder(view); return holder; } @Override public void onBindViewHolder(MyViewHolder holder, int position) { holder.textView.setText(list.get(position)); } @Override public int getItemCount() { return list.size(); } class MyViewHolder extends RecyclerView.ViewHolder { TextView textView; public MyViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.item_textview); } } } LayoutManager RecyclerView通过布局管理器LayoutManager控制每一个item如何进行排列摆放，何时展示和隐藏。回收或重用一个View时LayoutManager会向适配器请求新的数据来替换旧的数据，这种机制避免了创建过多的View和频繁的调用findViewById方法，目前其自带的主要有以下三种： - LinearLayoutManager：ListView样式 - GridLayoutManager：GridView样式 - StaggeredGridLayoutManager：瀑布流样式 ItemDecoration RecyclerView并不能像ListView一样直接在xml布局中修改item分割线样式。需要在Activity动态设置，当然更推荐在单个条目布局中设置margin或者padding来实现分割线效果，这里提供一个分割线。 import android.content.Context; import android.content.res.TypedArray; import android.graphics.Canvas; import android.graphics.Rect; import android.graphics.drawable.Drawable; import android.support.v7.widget.LinearLayoutManager; import android.support.v7.widget.RecyclerView; import android.view.View; public class DividerItemDecoration extends RecyclerView.ItemDecoration { private static final int[] ATTRS = new int[]{ android.R.attr.listDivider }; public static final int HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL; public static final int VERTICAL_LIST = LinearLayoutManager.VERTICAL; private Drawable mDivider; private int mOrientation; public DividerItemDecoration(Context context, int orientation) { final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); a.recycle(); setOrientation(orientation); } public void setOrientation(int orientation) { if (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) { throw new IllegalArgumentException(\"invalid orientation\"); } mOrientation = orientation; } @Override public void onDraw(Canvas c, RecyclerView parent) { if (mOrientation == VERTICAL_LIST) { drawVertical(c, parent); } else { drawHorizontal(c, parent); } } public void drawVertical(Canvas c, RecyclerView parent) { final int left = parent.getPaddingLeft(); final int right = parent.getWidth() - parent.getPaddingRight(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int top = child.getBottom() + params.bottomMargin; final int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); } } public void drawHorizontal(Canvas c, RecyclerView parent) { final int top = parent.getPaddingTop(); final int bottom = parent.getHeight() - parent.getPaddingBottom(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int left = child.getRight() + params.rightMargin; final int right = left + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); } } @Override public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) { if (mOrientation == VERTICAL_LIST) { outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); } else { outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); } } } ItemAnimator ItemAnimator会根据适配器上收到的通知来动画显示视图组的修改，比如item的添加与删除。DefaultItemAnimator已经能很好的展现动画效果了。 RecyclerView初始化 若想初始化一个RecyclerView使其进入工作状态，你需要在Activity中做以下的操作： RecyclerView recyclerView = (RecyclerView)findViewById(R.id.recycler_view_main); MyAdapter adapter = new MyAdapter(this, list); //设置RecyclerView保持固定的大小 recyclerView.setHasFixedSize(true); //设置适配器 recyclerView.setAdapter(adapter); //设置RecyclerView ListView样式布局管理 recyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)); //设置RecyclerView的Item分割线 recyclerView.addItemDecoration(new DividerItemDecoration(this, DividerItemDecoration.VERTICAL_LIST)); //设置RecyclerView的动画 recyclerView.setItemAnimator(new DefaultItemAnimator()); //设置RecyclerView GridView样式 //recyclerView.setLayoutManager(new GridLayoutManager(MainActivity.this, 3)); //设置RecyclerView 水平GridView样式 //recyclerView.setLayoutManager(new StaggeredGridLayoutManager(5, StaggeredGridLayoutManager.HORIZONTAL)); //设置RecyclerView 瀑布流样式 //recyclerView.setLayoutManager(new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL)); 点击事件与添加删除Item 美中不足的是RecyclerView并没有提供像ListView一样的Item点击与Item长点击事件，不提供咱们就自己造，通过接口回调来实现。 Adapter中import android.content.Context; import android.support.v7.widget.RecyclerView; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; import java.util.ArrayList; public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; { private Context context; private LayoutInflater inflater; protected ArrayList&lt;String&gt; datas; private onItemClickedListener onItemClickedListener; public MyAdapter(Context context, ArrayList&lt;String&gt; datas) { this.context = context; this.datas = datas; inflater = LayoutInflater.from(context); } public void setOnItemClickedListener(MyAdapter.onItemClickedListener onItemClickedListener) { this.onItemClickedListener = onItemClickedListener; } @Override public void onBindViewHolder(MyViewHolder holder, int position) { holder.textView.setText(datas.get(position)); } @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = inflater.inflate(R.layout.item_recycler_view, parent, false); MyViewHolder myViewHolder = new MyViewHolder(view); return myViewHolder; } @Override public int getItemCount() { return datas.size(); } /** * 添加条目 */ public void addItem(int position) { datas.add(position, \"xulei\"); // notifyDataSetChanged(); notifyItemInserted(position);//调用这个才有动画效果 } /** * 移除条目 */ public void removeItem(int position) { datas.remove(position); notifyItemRemoved(position); } class MyViewHolder extends RecyclerView.ViewHolder { TextView textView; public MyViewHolder(View itemView) { super(itemView); //初始化控件 textView = (TextView) itemView.findViewById(R.id.item_textview); //设置当前条目单击监听 itemView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { if (onItemClickedListener != null) onItemClickedListener.onClick(view, getAdapterPosition());//可立刻获取到当前position // onItemClickedListener.onClick(view, getLayoutPosition());//需等当前视图更新完才能获取到当前position，&lt;16ms。 } }); //设置当前条目长按监听 itemView.setOnLongClickListener(new View.OnLongClickListener() { @Override public boolean onLongClick(View view) { if (onItemClickedListener != null) onItemClickedListener.onLongClick(view, getAdapterPosition()); return false; } }); } } /** * 点击回调的接口 */ interface onItemClickedListener { void onClick(View view, int position); void onLongClick(View view, int position); } } Activity中 在Activity中实例化Adapter之后添加如下代码： adapter.setOnItemClickedListener(new MyAdapter.onItemClickedListener() { @Override public void onClick(View view, int position) { adapter.addItem(position); Toast.makeText(MainActivity.this, \"点击click:\" + position, Toast.LENGTH_SHORT).show(); } @Override public void onLongClick(View view, int position) { adapter.removeItem(position); Toast.makeText(MainActivity.this, \"长按click:\" + position, Toast.LENGTH_SHORT).show(); } }); 瀑布流的实现 想实现瀑布流的样式通过使用RecyclerView也很容易就能实现。 首先在Activity中设置LayoutManager时选择：recyclerView.setLayoutManager(new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL)); 修改Adapter 瀑布流自然是每个条目的高度不同才能出现瀑布的效果（水平布局则是宽度不同），那么只需在每个条目绑定数据时动态改变下其高度即可，贴出瀑布流Adapter代码： import android.content.Context; import android.view.ViewGroup; import java.util.ArrayList; import java.util.List; public class StaggerAdapter extends MyAdapter { private List&lt;Integer&gt; heights; public StaggerAdapter(Context context, ArrayList&lt;String&gt; datas) { super(context, datas); heights = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; datas.size(); i++) { heights.add((int) (100 + Math.random() * 300)); } } @Override public void onBindViewHolder(MyViewHolder holder, int position) { ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams(); layoutParams.height = heights.get(position); // layoutParams.width = heights.get(position); holder.itemView.setLayoutParams(layoutParams); holder.textView.setText(datas.get(position)); } } 总结 通过实践发现RecyclerView相较于ListView与GridView确实强大很多，更加的灵活与方便，提高了开发效率。但也有不足之处，如并未封装点击事件的回调，确实是比较头疼。期待Google的完善。附上GitHub源码：RecyclerViewDemoRecyclerViewDevelop","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://LeiHolmes.github.io/tags/RecyclerView/"}]},{"title":"Android开发之AlarmManager闹钟+Notification通知","slug":"Android开发之AlarmManager闹钟+Notification通知","date":"2016-12-13T03:11:11.000Z","updated":"2017-05-11T08:14:48.000Z","comments":true,"path":"2016/12/13/Android开发之AlarmManager闹钟+Notification通知/","link":"","permalink":"http://LeiHolmes.github.io/2016/12/13/Android开发之AlarmManager闹钟+Notification通知/","excerpt":"概述 AlarmManager实质是一个全局的定时器，是Android中常用的一种系统级别的提示服务，在指定时间或周期性启动其它组件（包括Activity,Service,BroadcastReceiver）。本文将讲解一下如何使用AlarmManager实现定时提醒功能。","text":"概述 AlarmManager实质是一个全局的定时器，是Android中常用的一种系统级别的提示服务，在指定时间或周期性启动其它组件（包括Activity,Service,BroadcastReceiver）。本文将讲解一下如何使用AlarmManager实现定时提醒功能。 闹钟配置周期闹钟12345Intent intent = new Intent();intent.setAction(GlobalValues.TIMER_ACTION_REPEATING);PendingIntent sender = PendingIntent.getBroadcast(context, 0, intent, 0);AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);alarm.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + 5 * 1000, 3 * 1000, sender); 1setRepeating(int type,long startTime,long intervalTime,PendingIntent pi) 该方法用于设置周期性执行的定时服务。type：闹钟类型，startTime：闹钟首次执行时间，intervalTime：闹钟两次执行的间隔时间，pi：闹钟响应动作。1setInexactRepeating(int type,long startTime,long intervalTime,PendingIntent pi) 该方法也用于设置周期定式服务，与上一种类似。不过其两个闹钟执行的间隔时间不是固定的。它相对而言更省电一些，因为系统可能会将几个差不多的闹钟合并为一个来执行，减少设备的唤醒次数。 intervalTime内置变量间隔一天： INTERVAL_DAY间隔半天： INTERVAL_HALF_DAY间隔15分钟： INTERVAL_FIFTEEN_MINUTES间隔半个小时： INTERVAL_HALF_HOUR间隔一个小时： INTERVAL_HOUR 定时闹钟123456789//获得系统提供的AlarmManager服务的对象AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);//Intent设置要启动的组件，这里启动广播Intent myIntent = new Intent();myIntent.setAction(GlobalValues.TIMER_ACTION);//PendingIntent对象设置动作,启动的是Activity还是Service,或广播!PendingIntent sender = PendingIntent.getBroadcast(context, 0, myIntent,0);//注册闹钟alarm.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + 5 * 1000, sender); 1set(int type,long startTime,PendingIntent pi) 该方法用于设置一次性定时服务。type：闹钟类型，startTime：闹钟执行时间，pi：闹钟响应动作。 取消闹钟123456Intent myIntent = new Intent();myIntent.setAction(GlobalValues.TIMER_ACTION);//myIntent.setAction(GlobalValues.TIMER_ACTION_REPEATING);PendingIntent sender = PendingIntent.getBroadcast(context, 0, myIntent,0);AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);alarm.cancel(sender); 设置多个闹钟： 若连续设置多个闹钟，则只有最后一个闹钟会生效，那么这种情况我们怎么处理呢？其实很简单。我们可以给每个闹钟设置唯一的id，传入getBroadcast()第二个参数。在这里我是每设置一个id则自增1存入Shareprefrence里，保证id唯一性。1234 //给每个闹钟设置不同ID防止覆盖int alarmId = SharedPreUtils.getInteger(context, \"alarm_id\", 0);SharedPreUtils.setInteger(context, \"alarm_id\", ++alarmId);PendingIntent sender = PendingIntent.getBroadcast(context, alarmId, myIntent, 0); 在取消闹钟时我们也可以根据这个id关闭不同的闹钟。 参数详解type：闹钟类型ELAPSED_REALTIME： 在指定的延时过后，发送广播，但不唤醒设备（闹钟在睡眠状态下不可用）。如果在系统休眠时闹钟触发，它将不会被传递，直到下一次设备唤醒。ELAPSED_REALTIME_WAKEUP： 在指定的延时过后，发送广播，并唤醒设备（即使关机也会执行operation所对应的组件） 。延时是要把系统启动的时间SystemClock.elapsedRealtime()算进去的。RTC： 指定当系统调用System.currentTimeMillis()方法返回的值与triggerAtTime相等时启动operation所对应的设备（在指定的时刻，发送广播，但不唤醒设备）。如果在系统休眠时闹钟触发，它将不会被传递，直到下一次设备唤醒（闹钟在睡眠状态下不可用）。RTC_WAKEUP： 指定当系统调用System.currentTimeMillis()方法返回的值与triggerAtTime相等时启动operation所对应的设备（在指定的时刻，发送广播，并唤醒设备）。即使系统关机也会执行operation所对应的组件。POWER_OFF_WAKEUP： 表示闹钟在手机关机状态下也能正常进行提示功能，所以是5个状态中用的最多的状态之一，该状态下闹钟也是用绝对时间，状态值为4；不过本状态好像受SDK版本影响，某些版本并不支持。 long intervalTime：执行时间 闹钟的第一次执行时间，以毫秒为单位，可以自定义时间，不过一般使用当前时间。需要注意的是，本属性与第一个属性（type）密切相关，如果第一个参数对应的闹钟使用的是相对时间（ELAPSED_REALTIME和ELAPSED_REALTIME_WAKEUP），那么本属性就得使用相对时间（相对于系统启动时间来说），比如当前时间就表示为：SystemClock.elapsedRealtime();如果第一个参数对应的闹钟使用的是绝对时间（RTC、RTC_WAKEUP、POWER_OFF_WAKEUP），那么本属性就得使用绝对时间，比如当前时间就表示为：System.currentTimeMillis() long startTime：间隔时间 对于周期定时方式来说，存在本属性，表示两次闹钟执行的间隔时间，也是以毫秒为单位。 PendingIntent pi：执行动作 是闹钟的执行动作，比如发送一个广播、给出提示等等。PendingIntent是Intent的封装类。需要注意的是，如果是通过启动服务来实现闹钟提示的话，PendingIntent对象的获取就应该采用Pending.getService(Context c,int i,Intent intent,int j)方法；如果是通过广播来实现闹钟提示的话，PendingIntent对象的获取就应该采用PendingIntent.getBroadcast(Context c,int i,Intent intent,int j)方法；如果是采用Activity的方式来实现闹钟提示的话，PendingIntent对象的获取就应该采用PendingIntent.getActivity(Context c,int i,Intent intent,int j)方法。如果这三种方法错用了的话，虽然不会报错，但是看不到闹钟提示效果。。 广播配置新建闹钟BroadCastReceiver：1234567891011121314151617181920212223242526272829public class AlarmReceiver extends BroadcastReceiver &#123; private NotificationManager m_notificationMgr = null; private static final int NOTIFICATION_FLAG = 3; @Override public void onReceive(Context context, Intent intent) &#123; m_notificationMgr = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVIC if (intent.getAction().equals(GlobalValues.TIMER_ACTION_REPEATING)) &#123; Log.e(\"alarm_receiver\", \"周期闹钟\"); &#125; else if (intent.getAction().equals(GlobalValues.TIMER_ACTION)) &#123; Log.e(\"alarm_receiver\", \"定时闹钟\"); Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.logo); Intent intent1 = new Intent(context, WriteDiaryActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent1, 0); Notification notify = new Notification.Builder(context) .setSmallIcon(R.drawable.logo) // 设置状态栏中的小图片，尺寸一般建议在24×24 .setLargeIcon(bitmap) // 这里也可以设置大图标 .setTicker(\"亲情日历\") // 设置显示的提示文字 .setContentTitle(\"亲情日历\") // 设置显示的标题 .setContentText(\"您有日记提醒哦\") // 消息的详细内容 .setContentIntent(pendingIntent) // 关联PendingIntent .setNumber(1) // 在TextView的右方显示的数字，可以在外部定义一个变量，点击累加setNumber(count),这时显示的和 .getNotification(); // 需要注意build()是在API level16及之后增加的，在API11中可以使用getNotificatin()来 notify.flags |= Notification.FLAG_AUTO_CANCEL; NotificationManager manager = (NotificationManager) context.getSystemService(Context.NOTIF manager.notify(NOTIFICATION_FLAG, notify); bitmap.recycle(); //回收bitmap &#125; &#125;&#125; 注册BroadCastReceiver： 最后别忘了在清单里注册广播。1234567&lt;!--闹钟接收广播--&gt;&lt;receiver android:name=\".util.service.AlarmReceiver\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.e_eduspace.TIMER_ACTION_REPEATING\" /&gt; &lt;action android:name=\"com.e_eduspace.TIMER_ACTION\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 附件常量：123456public class GlobalValues &#123; // 周期性的闹钟 public final static String TIMER_ACTION_REPEATING = \"com.e_eduspace.TIMER_ACTION_REPEATING\"; // 定时闹钟 public final static String TIMER_ACTION = \"com.e_eduspace.TIMER_ACTION\";&#125; 工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.e_eduspace.familycalendar.util;import android.app.AlarmManager;import android.app.PendingIntent;import android.content.Context;import android.content.Intent;import com.prolificinteractive.materialcalendarview.CalendarDay;/** * 闹钟定时工具类 * * @author xulei * @time 2016/12/13 10:03 */public class AlarmTimer &#123; /** * 设置周期性闹钟 * * @param context * @param firstTime * @param cycTime * @param action * @param AlarmManagerType 闹钟的类型，常用的有5个值：AlarmManager.ELAPSED_REALTIME、 * AlarmManager.ELAPSED_REALTIME_WAKEUP、AlarmManager.RTC、 * AlarmManager.RTC_WAKEUP、AlarmManager.POWER_OFF_WAKEUP */ public static void setRepeatingAlarmTimer(Context context, long firstTime, long cycTime, String action, int AlarmManagerType) &#123; Intent myIntent = new Intent(); myIntent.setAction(action); PendingIntent sender = PendingIntent.getBroadcast(context, 0, myIntent, 0); AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE); alarm.setRepeating(AlarmManagerType, firstTime, cycTime, sender); //param1：闹钟类型，param1：闹钟首次执行时间，param1：闹钟两次执行的间隔时间，param1：闹钟响应动作。 &#125; /** * 设置定时闹钟 * * @param context * @param cycTime * @param action * @param AlarmManagerType 闹钟的类型，常用的有5个值：AlarmManager.ELAPSED_REALTIME、 * AlarmManager.ELAPSED_REALTIME_WAKEUP、AlarmManager.RTC、 * AlarmManager.RTC_WAKEUP、AlarmManager.POWER_OFF_WAKEUP */ public static void setAlarmTimer(Context context, long cycTime, String action, int AlarmManagerType, CalendarDay date) &#123; Intent myIntent = new Intent(); //传递定时日期 myIntent.putExtra(\"date\", date); myIntent.setAction(action); //给每个闹钟设置不同ID防止覆盖 int alarmId = SharedPreUtils.getInteger(context, \"alarm_id\", 0); SharedPreUtils.setInteger(context, \"alarm_id\", ++alarmId); PendingIntent sender = PendingIntent.getBroadcast(context, alarmId, myIntent, 0); AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE); alarm.set(AlarmManagerType, cycTime, sender); &#125; /** * 取消闹钟 * * @param context * @param action */ public static void cancelAlarmTimer(Context context, String action) &#123; Intent myIntent = new Intent(); myIntent.setAction(action); PendingIntent sender = PendingIntent.getBroadcast(context, 0, myIntent,0); AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE); alarm.cancel(sender); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"AlarmManager","slug":"AlarmManager","permalink":"http://LeiHolmes.github.io/tags/AlarmManager/"}]},{"title":"Retrofit2.0网络请求框架初尝试","slug":"Retrofit","date":"2016-04-29T07:41:00.000Z","updated":"2016-05-12T03:31:01.000Z","comments":true,"path":"2016/04/29/Retrofit/","link":"","permalink":"http://LeiHolmes.github.io/2016/04/29/Retrofit/","excerpt":"Retrofit2.0简介 Retrofit是一套RESTful架构的Android(Java)客户端实现，基于注解，提供JSON to POJO(Plain Ordinary Java Object,简单Java对象)，POJO to JSON，网络请求(POST，GET,PUT，DELETE等)封装。用官方自己的介绍就是: A type-safe REST client for Android and Java 现已更新到2.0的版本，与1.0版本的使用上还是不小的差别，我也是第一次用，这里主要和大家研究研究2.0版本简单使用。也可参详官方示例。","text":"Retrofit2.0简介 Retrofit是一套RESTful架构的Android(Java)客户端实现，基于注解，提供JSON to POJO(Plain Ordinary Java Object,简单Java对象)，POJO to JSON，网络请求(POST，GET,PUT，DELETE等)封装。用官方自己的介绍就是: A type-safe REST client for Android and Java 现已更新到2.0的版本，与1.0版本的使用上还是不小的差别，我也是第一次用，这里主要和大家研究研究2.0版本简单使用。也可参详官方示例。 准备工作添加权限首先添加网络请求权限 &lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; 添加依赖Retrofit2.0版本后只支持okhttp请求，也已经封装好了，就不需要添加okhttp的依赖了。 dependencies { compile &#39;com.squareup.retrofit2:retrofit:2.0.2&#39; compile &#39;com.squareup.retrofit2:converter-gson:2.0.0-beta3&#39; } 简单使用接下来瞧一瞧Retrofit初始化以及如何请求数据。 初始化Retrofit对象public static final String BASE_URL = \"https://api.github.com/\"; Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .build(); BASE_URL就是你请求的Server地址。 .addConverterFactory(GsonConverterFactory.create()) Retrofit2.0不提供返回JSON数据的默认解析方式，需要手动指定，支持Jackson等多种解析方式。需要哪种就添加相应的依赖，这里添加的是Retrofit提供的converter-gson依赖。有点不爽的就是不支持FastJson解析，有需要的话可以自己写一个FastjsonConverterFactory继承Converter.Factory实现。 虽然Retrofit2.0后只支持okhttp请求，但你也可以自定义一个okhttp再配置进Retrofit。 OkHttpClient client = new OkHttpClient(); client.interceptors().add(new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { Response response = chain.proceed(chain.request()); // Do anything with response here return response; } Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .client(client) .addConverterFactory(GsonConverterFactory.create()) .build(); }); 定义请求接口实现转换HTTP API为Java接口，Retrofit提供了5种内置的注解：GET、POST、PUT、DELETE和HEAD，在注解中指定的资源的相对URL。 public interface NetWorkService { @GET(\"users/basil2style\") Call&lt;DataBean&gt; getData(); } 使用替换块和参数进行动态更新,替换块是{ and }包围的字母数字组成的字符串，相应的参数必须使用相同的字符串被@Path进行注释。 @GET(\"repos/{params1}/{params2}/contributors\") Call&lt;List&lt;DataBean2&gt;&gt; getData( @Path(\"params1\") String params1, @Path(\"params2\") String params2, ); 当我们调用getData()这个方法的时候，Retrofit会创建这个URL。如果我们传入Square和Retrofit字符串，分别作为owner和repo参数。我们就会得到这个URL：https://api.github.com/repos/square/retrofit/contributors 添加查询参数 @GET(\"repos/square/{retrofit}/contributors\") Call&lt;List&lt;DataBean2&gt;&gt; groupData(@Path(\"retrofit\") String retrofit, @Query(\"sort\") String sort); 当我们调用getData()方法时，传入一个查询参数字符串”ok”,这样我们就能得到URL：https://api.github.com/repos/square/retrofit/contributors?sort=ok 当然如果查询参数过多，我们也可以使用Map进行组合再传进来。 @GET(\"repos/square/{retrofit}/contributors\") Call&lt;List&lt;DataBean2&gt;&gt; getData(@Path(\"repos\") String repos, @QueryMap Map&lt;String, String&gt; parameters); 请求数据Retrifot支持同步和异步的请求方式，先使用Retrofit类生成接口NetWorkService的实现。 NetWorkService service = retrofit.create(NetWorkService.class); 同步请求Call&lt;DataBean&gt; call = service.getData(Square,Retrofit); DataBean bean = call.execute().body(); 注意同步请求不可在主线程执行，你懂得。且call只能执行execute()方法一次，若要再次请求可通过Call&lt;DataBean&gt; call = call.clone()来再复制一个Call对象。 异步请求call.enqueue(new Callback&lt;DataBean&gt;() { @Override public void onResponse(Call&lt;DataBean&gt; call, Response&lt;DataBean&gt; response) { Toast.makeText(MainActivity.this, \"请求成功\", Toast.LENGTH_SHORT).show(); DataBean bean = response.body(); tvMain.setText(bean.toString()); } @Override public void onFailure(Call&lt;DataBean&gt; call, Throwable t) { } }); 当我们执行的同步或异步加入队列后，可以随时使用call.cancel()方法取消请求。 注意注解中参数的写法与BASE_URL的拼接一定要注意，请看以下写法。 错误示例1BASE_URL：https://api.github.com/repos/squareGet注解： @GET(“/basil2style”)结果URL： https://api.github.com/basil2style 错误示例2BASE_URL：https://api.github.com/repos/squareGet注解： @GET(“basil2style”)结果URL： https://api.github.com/repos/basil2style 推荐写法BASE_URL：https://api.github.com/repos/square/Get注解： @GET(“basil2style”)结果URL： https://api.github.com/repos/square/basil2style 总结最简单的Retrofit实现流程完毕，Retrofit+Okhttp+Gson可以算是目前来说相当快的超级网络请求框架了。相比较于Volley都快不少，亲测结果：爽爽爽。小伙伴们赶紧整起来吧！","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"http://LeiHolmes.github.io/tags/Retrofit/"}]},{"title":"android神器Stetho调试Volley","slug":"volley-stetho","date":"2016-04-19T04:19:16.000Z","updated":"2017-05-11T08:16:02.000Z","comments":true,"path":"2016/04/19/volley-stetho/","link":"","permalink":"http://LeiHolmes.github.io/2016/04/19/volley-stetho/","excerpt":"Stetho简介Stetho 是 Facebook 开源的一个 Android 调试工具。是一个 Chrome Developer Tools 的扩展，可用来检测应用的网络、数据库、WebKit 等方面的功能。开发者也可通过它的 dumpapp 工具提供强大的命令行接口来访问应用内部。无需root查看sqlite文件、sharedpreference文件等等。更多详细介绍可以进入Stetho官网。","text":"Stetho简介Stetho 是 Facebook 开源的一个 Android 调试工具。是一个 Chrome Developer Tools 的扩展，可用来检测应用的网络、数据库、WebKit 等方面的功能。开发者也可通过它的 dumpapp 工具提供强大的命令行接口来访问应用内部。无需root查看sqlite文件、sharedpreference文件等等。更多详细介绍可以进入Stetho官网。 Stetho结合OkHttp使用添加依赖1234// Gradle dependency on Stetho dependencies &#123; compile 'com.facebook.stetho:stetho:1.1.1' &#125; Stetho初始化配置在App的Application中完成初始化。123456789101112public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); Stetho.initialize( Stetho.newInitializerBuilder(this) .enableDumpapp( Stetho.defaultDumperPluginsProvider(this)) .enableWebKitInspector( Stetho.defaultInspectorModulesProvider(this)) .build()); &#125;&#125; 官网中使用OkHttp为实例，使用如下12OkHttpClient client = new OkHttpClient();client.networkInterceptors().add(new StethoInterceptor()); 然后就可以运行App进行调试，基本上可以满足调试需求了。 Stetho结合Volley使用官网中Stetho是结合OkHttp的使用，如果项目中使用Volley做为网络请求框架，可以做如下修改。还是使用OkHttp做为Volley中HttpStack的实现，我们知道，Volley中网络请求在Android2.3及以上基于HttpURLConnection，2.3以下基于HttpClient实现，通过增加HttpStack的具体实现即可。这里使用Bryan Stern分享的代码。（网页可能被墙，可以通过VPN访问。需要VPN的可以点击这里） 添加依赖123compile 'com.facebook.stetho:stetho:1.1.1'compile 'com.facebook.stetho:stetho-okhttp:1.1.1'compile 'com.squareup.okhttp:okhttp:2.3.0' Stetho初始化配置123OkHttpClient client = new OkHttpClient();client.networkInterceptors().add(new StethoInterceptor());mRequestQueue = Volley.newRequestQueue(getApplicationContext(), new OkHttpStack(client)); 好了，基本上这样就能使用Stetho神器调试你的App了，感觉到强大了么~。 补充：使用中遇到的坑 Stetho inspect窗口空白 如果出现调试窗口空白，先升级下Chrome吧。升级最新版后再试一下（我被这个坑了）。 Stetho inspect窗口还是空白 如果Chrome是最新版，无论如何刷新都是空白，那么恭喜你你可能被墙了~用VPN试试吧 可以戳这里哦 我的测试代码和效果图如下：自定义Application类：12345678910111213141516171819202122232425262728293031public class MyAppliation extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); context = getApplicationContext(); instance = this; Stetho.initialize( Stetho.newInitializerBuilder(this) .enableDumpapp(Stetho.defaultDumperPluginsProvider(this)) .enableWebKitInspector(Stetho.defaultInspectorModulesProvider(this)) .build()); &#125; /** * @return The Volley Request queue */ public RequestQueue getRequestQueue() &#123; // lazy initialize the request queue, the queue instance will be // created when it is accessed for the first time synchronized (App.class) &#123; if (mRequestQueue == null) &#123; OkHttpClient client = new OkHttpClient(); client.networkInterceptors().add(new StethoInterceptor()); mRequestQueue = Volley.newRequestQueue(getApplicationContext(), new OkHttpStack(client)); &#125; &#125; return mRequestQueue; &#125;&#125; Activity类代码： 123456789101112131415161718192021222324252627282930public class MainActivity extends Activity &#123; private TextView tv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout_main); tv = (TextView)findViewById(R.id.tv); RequestQueue queue = App.getInstance().getRequestQueue(); String url = \"https://publicobject.com/helloworld.txt\"; StringRequest request = new StringRequest(Request.Method.GET, url, new Response.Listener&lt;String&gt;() &#123; @Override public void onResponse(String s) &#123; LogUtil.d(s); tv.setText(s); &#125; &#125;, new com.android.volley.Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError volleyError) &#123; LogUtil.e(volleyError.toString()); &#125; &#125;); queue.add(request); SharedPrfUtil.setInt(\"uid\",669); SharedPrfUtil.setString(\"username\",\"dongye\"); &#125;&#125; 实现效果如下图： Stetho调试效果图 调试程序列表 调试网络请求 读取数据存储","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"Stetho","slug":"Stetho","permalink":"http://LeiHolmes.github.io/tags/Stetho/"}]}]}