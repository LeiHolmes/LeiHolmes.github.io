{"meta":{"title":"Lei’s Blog","subtitle":"不忘初心，淡然前行","description":null,"author":"徐雷","url":"http://LeiHolmes.github.io"},"pages":[{"title":"categories","date":"2017-05-10T06:00:40.000Z","updated":"2017-05-11T07:01:56.000Z","comments":false,"path":"categories/index.html","permalink":"http://LeiHolmes.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-05-10T05:55:45.000Z","updated":"2017-05-11T07:01:30.000Z","comments":false,"path":"tags/index.html","permalink":"http://LeiHolmes.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"RxJava终章之实践出真知(七)","slug":"RxJava终章之实践出真知(七)","date":"2017-10-19T16:00:00.000Z","updated":"2017-10-20T05:52:16.000Z","comments":true,"path":"2017/10/20/RxJava终章之实践出真知(七)/","link":"","permalink":"http://LeiHolmes.github.io/2017/10/20/RxJava终章之实践出真知(七)/","excerpt":"前言 到本阶段，相信各位码友对RxJava的原理及操作符的使用方法已经基本掌握了。只是了解理论知识对于咱们程序猴来说当然远远不够，理论运用到实践才能出真知。一起来律动指尖到实际场景中看看怎么运用RxJava。本篇我们演示一下如何运用RxJava从手机中获取已安装的第三方应用并通过RecyclerView展示出来。","text":"前言 到本阶段，相信各位码友对RxJava的原理及操作符的使用方法已经基本掌握了。只是了解理论知识对于咱们程序猴来说当然远远不够，理论运用到实践才能出真知。一起来律动指尖到实际场景中看看怎么运用RxJava。本篇我们演示一下如何运用RxJava从手机中获取已安装的第三方应用并通过RecyclerView展示出来。 准备工作项目下build.gradle123456789buildscript &#123; ...... dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.2' //ButterKnife支持 classpath 'com.jakewharton:butterknife-gradle-plugin:8.7.0' &#125;&#125;...... app下build.gradle12345678910111213141516171819202122232425262728293031apply plugin: 'com.android.application'apply plugin: 'com.jakewharton.butterknife'android &#123; ...... defaultConfig &#123; ...... //Lambda支持 jackOptions &#123; enabled true &#125; &#125; //Lambda支持 compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125; ......&#125;dependencies &#123; ...... //RxJava支持 compile 'io.reactivex:rxjava:1.0.14' compile 'io.reactivex:rxandroid:1.0.1' //RecyclerView支持 compile 'com.android.support:recyclerview-v7:25.3.1' //ButterKnife支持 compile 'com.jakewharton:butterknife:8.7.0' annotationProcessor 'com.jakewharton:butterknife-compiler:8.7.0'&#125; 布局主布局 主布局没啥好说的，就是一个RecyclerView。123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.holmeslei.rxjavademo.ui.PracticeActivity&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/rv_app_list\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/RelativeLayout&gt; RecyclerView的Item布局 RecyclerView单个条目布局，我们需要一个ImageView及一个TextView用来展示每个应用的图标及名称。123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"80dp\" android:paddingLeft=\"20dp\"&gt; &lt;ImageView android:id=\"@+id/item_iv_head\" android:layout_width=\"50dp\" android:layout_height=\"50dp\" android:layout_centerVertical=\"true\" android:scaleType=\"fitXY\" android:src=\"@mipmap/ic_launcher\" /&gt; &lt;TextView android:id=\"@+id/item_iv_app_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerVertical=\"true\" android:layout_marginLeft=\"30dp\" android:layout_toRightOf=\"@+id/item_iv_head\" android:text=\"微信\" android:textColor=\"#555555\" android:textSize=\"18sp\" /&gt; &lt;/RelativeLayout&gt;&lt;/RelativeLayout&gt; Java代码实体类12345678910111213141516171819202122232425262728public class AppInfo &#123; private String appName; //应用名称 private Drawable appIcon; //应用图标 public String getAppName() &#123; return appName; &#125; public void setAppName(String appName) &#123; this.appName = appName; &#125; public Drawable getAppIcon() &#123; return appIcon; &#125; public void setAppIcon(Drawable appIcon) &#123; this.appIcon = appIcon; &#125; @Override public String toString() &#123; return \"AppInfo&#123;\" + \"appName='\" + appName + '\\'' + \", appIcon=\" + appIcon + '&#125;'; &#125;&#125; RecyclerView适配器12345678910111213141516171819202122232425262728293031323334353637383940public class AppInfoListAdapter extends RecyclerView.Adapter&lt;AppInfoListAdapter.MyViewHolder&gt; &#123; private Context context; private List&lt;AppInfo&gt; appInfoList; public AppInfoListAdapter(Context context, List&lt;AppInfo&gt; appInfoList) &#123; this.context = context; this.appInfoList = appInfoList; &#125; @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(context).inflate(R.layout.item_app_list, parent, false); return new MyViewHolder(view); &#125; @Override public void onBindViewHolder(MyViewHolder holder, int position) &#123; //设置应用图标 holder.ivHead.setImageDrawable(appInfoList.get(position).getAppIcon()); //设置应用名称 holder.tvAppName.setText(appInfoList.get(position).getAppName()); &#125; @Override public int getItemCount() &#123; return appInfoList.size(); &#125; class MyViewHolder extends RecyclerView.ViewHolder &#123; @BindView(R.id.item_iv_head) ImageView ivHead; @BindView(R.id.item_iv_app_name) TextView tvAppName; MyViewHolder(View itemView) &#123; super(itemView); ButterKnife.bind(this, itemView); &#125; &#125;&#125; Activity 核心来了，我们重点看initData()方法。分析一下需求，要获取手机中已安装的第三方应用并展示出来，主要分以下几步： 1. 从系统中获取所有应用列表数据的集合List&lt;ApplicationInfo&gt;。 2. 这个集合是已安装的所有应用集合，我们只需要其中的第三方应用，所以要使用到RxJava的filter操作符进行过滤。 3. 由于ApplicationInfo不满足我们的需求，需要将其转换为我们自定义的实体类AppInfo，所以要使用到RxJava的map操作符进行转换。 4. 由于获取应用集合，过滤，转换的过程可能是耗时的，我们需要指定Observable运行在io线程。 5. 由于获取到满足条件的数据后我们还需刷新UI进行展示，所以还需要指定Observer运行在Android的UI线程。 6. 最后还需要输出错误日志，及完成之后的刷新UI，所以需要重写RxJava错误状态及完成状态的回调方法。 了解的整个实现流程，接下来上代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class PracticeActivity extends AppCompatActivity &#123; @BindView(R.id.rv_app_list) RecyclerView rvAppList; private AppInfoListAdapter adapter; private List&lt;AppInfo&gt; appInfoList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_practice); ButterKnife.bind(this); initRecyclerView(); initData(); &#125; /** * 初始化RecyclerView */ private void initRecyclerView() &#123; LinearLayoutManager manager = new LinearLayoutManager(this); rvAppList.setLayoutManager(manager); adapter = new AppInfoListAdapter(this, appInfoList); rvAppList.setAdapter(adapter); &#125; /** * 初始化数据 */ private void initData() &#123; final PackageManager pm = getPackageManager(); //获取所有应用信息集合 List&lt;ApplicationInfo&gt; infoList = pm.getInstalledApplications(PackageManager.GET_UNINSTALLED_PACKAGES); Observable.from(infoList) //过滤出已安装的第三方应用 .filter(new Func1&lt;ApplicationInfo, Boolean&gt;() &#123; @Override public Boolean call(ApplicationInfo applicationInfo) &#123; return (applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) &lt;= 0; &#125; &#125;) //转换为自定义的AppInfo类 .map(new Func1&lt;ApplicationInfo, AppInfo&gt;() &#123; @Override public AppInfo call(ApplicationInfo applicationInfo) &#123; AppInfo appInfo = new AppInfo(); appInfo.setAppIcon(applicationInfo.loadIcon(pm)); appInfo.setAppName(applicationInfo.loadLabel(pm).toString()); return appInfo; &#125; &#125;) //Observable被观察者执行在io线程 .subscribeOn(Schedulers.io()) //Observer观察者执行在AndroidUI线程 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;AppInfo&gt;() &#123; @Override public void onCompleted() &#123; //更新列表UI adapter.notifyDataSetChanged(); &#125; @Override public void onError(Throwable e) &#123; //显示错误信息 Toast.makeText(PracticeActivity.this, e.getMessage(), Toast.LENGTH_LONG).show(); &#125; @Override public void onNext(AppInfo appInfo) &#123; //添加第三方应用数据到集合 appInfoList.add(appInfo); &#125; &#125;);&#125; Lambda简化 还记得我在RxJava系列第一篇中提到过吗？RxJava可结合Lambda表达式达到简化代码的作用，来看一下简化之后的代码：12345678910111213141516171819202122/** * 初始化数据 */ private void initData() &#123; final PackageManager pm = getPackageManager(); List&lt;ApplicationInfo&gt; infoList = pm.getInstalledApplications(PackageManager.GET_UNINSTALLED_PACKAGES); Observable.from(infoList) .filter(applicationInfo -&gt; (applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) &lt;= 0) .map(applicationInfo -&gt; &#123; AppInfo appInfo = new AppInfo(); appInfo.setAppIcon(applicationInfo.loadIcon(pm)); appInfo.setAppName(applicationInfo.loadLabel(pm).toString()); return appInfo; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe( appInfo -&gt; appInfoList.add(appInfo), throwable -&gt; Toast.makeText(PracticeActivity.this, throwable.getMessage(), Toast.LENGTH_LONG).show(), () -&gt; adapter.notifyDataSetChanged() );&#125; 是不是看起来清爽简洁呢？不太了解Lambda表达式的码友可跳转到我的另一篇讲解Lambda表达式的文章： Lambda表达式基本语法与应用 总结 到此，RxJava系列从理论到运用再到实践，整个过程我们通过了7篇文章来学习。然而RxJava的知识远远不止这些，这就需要各位码友去探索发掘了。本系列只是达到入门RxJava的程度，且是基于RxJava1.0版本进行讲解的。目前RxJava已经更新到了2.0+，与1.0版本也有不小的改动与优化的地方。后期我会专门对RxJava2.x有何改动开一篇文章进行讲解，敬请期待。 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。 附上RxJavaDemo的地址： RxJavaDemo","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://LeiHolmes.github.io/tags/RxJava/"}]},{"title":"RxJava操作符之组合操作符(六)","slug":"RxJava操作符之组合操作符(六)","date":"2017-10-17T16:00:00.000Z","updated":"2017-10-19T07:07:43.000Z","comments":true,"path":"2017/10/18/RxJava操作符之组合操作符(六)/","link":"","permalink":"http://LeiHolmes.github.io/2017/10/18/RxJava操作符之组合操作符(六)/","excerpt":"前言 上一篇文章我们学习了过滤类操作符，本篇我们将一起来学习RxJava组合类操作符。组合操作符主要是用来同时处理多个Observable，将他们进行组合创建出新的满足我们需求的Observable，一起来看下都有哪些。","text":"前言 上一篇文章我们学习了过滤类操作符，本篇我们将一起来学习RxJava组合类操作符。组合操作符主要是用来同时处理多个Observable，将他们进行组合创建出新的满足我们需求的Observable，一起来看下都有哪些。 组合操作符Merge merge操作符，将两个Observable要发射的观测序列合并为一个序列进行发射。按照两个序列每个元素的发射时间先后进行排序，同一时间点发射的元素则是无序的。1234567891011121314151617181920//将一个发送字母的Observable与发送数字的Observable合并发射final String[] words = new String[]&#123;\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\"&#125;;//字母Observable，每200ms发射一次Observable&lt;String&gt; wordSequence = Observable.interval(200, TimeUnit.MILLISECONDS) .map(new Func1&lt;Long, String&gt;() &#123; @Override public String call(Long position) &#123; return words[position.intValue()]; &#125; &#125;) .take(words.length);//数字Observable，每500ms发射一次Observable&lt;Long&gt; numberSequence = Observable.interval(500, TimeUnit.MILLISECONDS).take(4);Observable.merge(wordSequence, numberSequence) .subscribe(new Action1&lt;Serializable&gt;() &#123; @Override public void call(Serializable serializable) &#123; Log.e(\"rx_test\", \"merge：\" + serializable.toString()); &#125; &#125;); 输出结果：12345678910111213merge：Amerge：Bmerge：0merge：Cmerge：Dmerge：Emerge：1merge：Fmerge：Gmerge：2merge：Hmerge：Imerge：3 原理图： merge操作符还有一种入参merge(Observable[]),可传入含有多个Observable的集合，merge操作符也可将这多个Observable的序列合并后发射。 MergeDelayError mergeDelayError操作符，与merge功能类似，都是用来合并Observable的。不同之处在于mergeDelayError操作符在合并过程中发生异常的话不会立即停止合并，而会在所有元素合并发射完毕之后再发射异常。但发生异常的那个Observable就不会发射数据了。1234567891011121314151617181920212223242526272829303132//字母Observable，每200ms发射一次，模拟过程中产生一个异常Observable&lt;String&gt; wordSequence = Observable.interval(200, TimeUnit.MILLISECONDS) .map(new Func1&lt;Long, String&gt;() &#123; @Override public String call(Long position) &#123; Long cache = position; if (cache == 3) &#123; cache = cache / 0; &#125; return words[position.intValue()]; &#125; &#125;) .take(words.length);//数字Observable，每500ms发射一次Observable&lt;Long&gt; numberSequence = Observable.interval(500, TimeUnit.MILLISECONDS).take(4);Observable.mergeDelayError(wordSequence, numberSequence) .subscribe(new Action1&lt;Serializable&gt;() &#123; @Override public void call(Serializable serializable) &#123; Log.e(\"rx_test\", \"mergeDelayError：\" + serializable.toString()); &#125; &#125;, new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable throwable) &#123; Log.e(\"rx_test\", \"mergeDelayError：\" + throwable.getMessage()); &#125; &#125;, new Action0() &#123; @Override public void call() &#123; Log.e(\"rx_test\", \"mergeDelayError：onComplete\"); &#125; &#125;); 输出结果：12345678mergeDelayError：AmergeDelayError：BmergeDelayError：0mergeDelayError：CmergeDelayError：1mergeDelayError：2mergeDelayError：3mergeDelayError：divide by zero 由输出结果可看出，wordSequence在发射到C时抛出了一个异常，停止发射其剩下的数据，但合并没有停止。合并完成之后这个异常才被发射了出来。 原理图： Concat concat操作符，将多个Obserbavle发射的数据进行合并后发射，类似于merge操作符。但concat操作符是将Observable依次发射，是有序的。12345678910Observable&lt;String&gt; wordSequence = Observable.just(\"A\", \"B\", \"C\", \"D\", \"E\");Observable&lt;Integer&gt; numberSequence = Observable.just(1, 2, 3, 4, 5);Observable&lt;String&gt; nameSequence = Observable.just(\"Sherlock\", \"Holmes\", \"Xu\", \"Lei\");Observable.concat(wordSequence, numberSequence, nameSequence) .subscribe(new Action1&lt;Serializable&gt;() &#123; @Override public void call(Serializable serializable) &#123; Log.e(\"rx_test\", \"concat：\" + serializable.toString()); &#125; &#125;); 输出结果：1234567891011121314concat：Aconcat：Bconcat：Cconcat：Dconcat：Econcat：1concat：2concat：3concat：4concat：5concat：Sherloconcat：Holmesconcat：Xuconcat：Lei 原理图： Zip zip(Observable, Observable, Func2)操作符，根据Func2中的call()方法规则合并两个Observable的数据项并发射。 注意：若其中一个Observable数据发送结束或出现异常后，另一个Observable也会停止发射数据。12345678910111213Observable&lt;String&gt; wordSequence = Observable.just(\"A\", \"B\", \"C\", \"D\", \"E\");Observable&lt;Integer&gt; numberSequence = Observable.just(1, 2, 3, 4, 5, 6);Observable.zip(wordSequence, numberSequence, new Func2&lt;String, Integer, String&gt;() &#123; @Override public String call(String s, Integer integer) &#123; return s + integer; &#125;&#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e(\"rx_test\", \"zip：\" + s); &#125;&#125;); 输出结果：12345zip：A1zip：B2zip：C3zip：D4zip：E5 由输出结果可看出numberSequence观测序列最后的6并没有发射出来，由于wordSequence观测序列已发射完所有数据，所以组合序列也停止发射数据了。 原理图： StartWith startWith操作符，用于在源Observable发射的数据前，插入指定的数据并发射。12345678Observable.just(4, 5, 6, 7) .startWith(1, 2, 3) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.e(\"rx_test\", \"startWith：\" + integer); &#125; &#125;); 输出结果：1234567startWith：1startWith：2startWith：3startWith：4startWith：5startWith：6startWith：7 原理图： startWith还有两种入参： startWith(Iterable)：可在源Observable发射的数据前插入Iterable数据并发射。 startWith(Observable)：可在源Observable发射的数据前插入另一Observable发射的数据并发射。 SwitchOnNext switchOnNext操作符，用来将一个发射多个小Observable的源Observable转化为一个Observable，然后发射多个小Observable所发射的数据。若小Observable正在发射数据时，源Observable又发射了新的小Observable，则前一个小Observable还未发射的数据会被抛弃，直接发射新的小Observable所发射的数据，上例子。1234567891011121314151617181920212223//每隔500ms产生一个ObservableObservable&lt;Observable&lt;Long&gt;&gt; observable = Observable.interval(500, TimeUnit.MILLISECONDS) .map(new Func1&lt;Long, Observable&lt;Long&gt;&gt;() &#123; @Override public Observable&lt;Long&gt; call(Long aLong) &#123; //每隔200毫秒产生一组数据（0,10,20,30,40) return Observable.interval(200, TimeUnit.MILLISECONDS) .map(new Func1&lt;Long, Long&gt;() &#123; @Override public Long call(Long aLong) &#123; return aLong * 10; &#125; &#125;).take(5); &#125; &#125;).take(2); Observable.switchOnNext(observable) .subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; Log.e(\"rx_test\", \"switchOnNext：\" + aLong); &#125; &#125;); 输出结果：1234567switchOnNext：0switchOnNext：10switchOnNext：0switchOnNext：10switchOnNext：20switchOnNext：30switchOnNext：40 由输出结果发现第一个小Observable打印到10则停止了发射数据，说明其发射到10时，新的小Observable被创建了出来，第一个小Observable则被中断发射，开始发射新的小Observable的数据。 原理图： CombineLatest combineLatest操作符，用于将两个Observale最近发射的数据以Func2函数的规则进行组合并发射。12345678910111213141516171819202122232425//引用merge的例子final String[] words = new String[]&#123;\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\"&#125;;Observable&lt;String&gt; wordSequence = Observable.interval(300, TimeUnit.MILLISECONDS) .map(new Func1&lt;Long, String&gt;() &#123; @Override public String call(Long position) &#123; return words[position.intValue()]; &#125; &#125;) .take(words.length);Observable&lt;Long&gt; numberSequence = Observable.interval(500, TimeUnit.MILLISECONDS) .take(5);Observable.combineLatest(wordSequence, numberSequence, new Func2&lt;String, Long, String&gt;() &#123; @Override public String call(String s, Long aLong) &#123; return s + aLong; &#125; &#125;) .subscribe(new Action1&lt;Serializable&gt;() &#123; @Override public void call(Serializable serializable) &#123; Log.e(\"rx_test\", \"combineLatest：\" + serializable.toString()); &#125; &#125;); 输出结果：12345678910111213combineLatest：A0combineLatest：B0combineLatest：C0combineLatest：C1combineLatest：D1combineLatest：E1combineLatest：E2combineLatest：F2combineLatest：F3combineLatest：G3combineLatest：H3combineLatest：H4combineLatest：I4 如果将wordSequence与numberSequence的入参顺序互换，输出结果也会不同：12345678910111213combineLatest：0AcombineLatest：0BcombineLatest：0CcombineLatest：1CcombineLatest：1DcombineLatest：2DcombineLatest：2EcombineLatest：2FcombineLatest：3FcombineLatest：3GcombineLatest：3HcombineLatest：4HcombineLatest：4I wordSequence每300ms发射一个字符，numberSequence每500ms发射一个数字。可能有些码友不知道这个输出结果怎么来的，这个操作符确实不太好理解。我们来看一下这个原理图就很清楚了。 原理图： Join join(Observable, Func1, Func1, Func2)操作符，类似于combineLatest操作符，用于将ObservableA与ObservableB发射的数据进行排列组合。但join操作符可以控制Observable发射的每个数据的生命周期，在每个发射数据的生命周期内，可与另一个Observable发射的数据按照一定规则进行合并，来看下join的几个入参。 Observable：需要与源Observable进行组合的目标Observable。 Func1：接收从源Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了源Obsrvable发射出来的数据的有效期； Func1：接收目标Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了目标Obsrvable发射出来的数据的有效期； Func2：接收从源Observable和目标Observable发射出来的数据，并将这两个数据按自定的规则组合后返回。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//产生字母的序列,周期为1000msString[] words = new String[]&#123;\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"&#125;;Observable&lt;String&gt; observableA = Observable.interval(1000, TimeUnit.MILLISECONDS) .map(new Func1&lt;Long, String&gt;() &#123; @Override public String call(Long aLong) &#123; return words[aLong.intValue()]; &#125; &#125;).take(8);//产0,1,2,3,4,5,6,7的序列,延时500ms发射,周期为1000msObservable&lt;Long&gt; observableB = Observable.interval(500, 1000, TimeUnit.MILLISECONDS) .map(new Func1&lt;Long, Long&gt;() &#123; @Override public Long call(Long aLong) &#123; return aLong; &#125; &#125;).take(words.length);//joinobservableA.join(observableB, new Func1&lt;String, Observable&lt;Long&gt;&gt;() &#123; @Override public Observable&lt;Long&gt; call(String s) &#123; //ObservableA发射的数据有效期为600ms return Observable.timer(600, TimeUnit.MILLISECONDS); &#125; &#125;, new Func1&lt;Long, Observable&lt;Long&gt;&gt;() &#123; @Override public Observable&lt;Long&gt; call(Long aLong) &#123; //ObservableB发射的数据有效期为600ms return Observable.timer(600, TimeUnit.MILLISECONDS); &#125; &#125;, new Func2&lt;String, Long, String&gt;() &#123; @Override public String call(String s, Long aLong) &#123; return s + aLong; &#125; &#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e(\"rx_test\", \"join：\" + s); &#125;&#125;); join操作符的组合方式类似于数学上的排列组合规则，以ObservableA为基准源Observable，按照其自身周期发射数据，且每个发射出来的数据都有其有效期。而ObservableB每发射出来一个数据，都与A发射出来的并且还在有效期内的数据按Func2函数中的规则进行组合，B发射出来的数据也有其有效期。最后再将结果发射给观察者进行处理。 输出结果：123456789101112131415join：A0join：A1join：B1join：B2join：C2join：C3join：D3join：D4join：E4join：E5join：F5join：F6join：G6join：G7join：H7 原理图： GroupJoin groupJoin操作符，类似于join操作符，区别在于第四个参数Func2的传入函数不同，对join之后的结果包装了一层小的Observable，便于用户再次进行一些过滤转换等操作再发射给Observable。1234567891011121314151617181920212223242526272829303132333435observableA.groupJoin(observableB, new Func1&lt;String, Observable&lt;Long&gt;&gt;() &#123; @Override public Observable&lt;Long&gt; call(String s) &#123; return Observable.timer(600, TimeUnit.MILLISECONDS); &#125; &#125;, new Func1&lt;Long, Observable&lt;Long&gt;&gt;() &#123; @Override public Observable&lt;Long&gt; call(Long aLong) &#123; return Observable.timer(600, TimeUnit.MILLISECONDS); &#125; &#125;, new Func2&lt;String, Observable&lt;Long&gt;, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call(final String s, Observable&lt;Long&gt; longObservable) &#123; return longObservable.map(new Func1&lt;Long, String&gt;() &#123; @Override public String call(Long aLong) &#123; return s + aLong; &#125; &#125;); &#125; &#125;) .subscribe(new Action1&lt;Observable&lt;String&gt;&gt;() &#123; @Override public void call(Observable&lt;String&gt; stringObservable) &#123; stringObservable.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e(\"rx_test\", \"groupJoin：\" + s); &#125; &#125;); &#125; &#125;); 输出结果：123456789101112131415groupJoin：A0groupJoin：A1groupJoin：B1groupJoin：B2groupJoin：C2groupJoin：C3groupJoin：D3groupJoin：D4groupJoin：E4groupJoin：E5groupJoin：F5groupJoin：F6groupJoin：G6groupJoin：G7groupJoin：H7 原理图： 总结 到此，本篇关于RxJava的常用组合类操作符就讲解完毕了。通过以上四篇文章对RxJava四类操作符的学习，相信大家已经基本掌握RxJava如何使用了。实践是检验真理的唯一标准，下一篇我们来一起上项目看看实践中如何使用RxJava。 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。 附上RxJavaDemo的地址： RxJavaDemo","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://LeiHolmes.github.io/tags/RxJava/"}]},{"title":"RxJava操作符之过滤操作符(五)","slug":"RxJava操作符之过滤操作符(五)","date":"2017-10-15T16:00:00.000Z","updated":"2017-10-16T06:46:23.000Z","comments":true,"path":"2017/10/16/RxJava操作符之过滤操作符(五)/","link":"","permalink":"http://LeiHolmes.github.io/2017/10/16/RxJava操作符之过滤操作符(五)/","excerpt":"前言 上一篇文章我们学习了转换类操作符，本篇我们将一起来学习RxJava过滤类操作符。过滤操作符主要是用来对事件数据进行过滤与筛选，只返回满足条件的数据，一起来看下都有哪些。","text":"前言 上一篇文章我们学习了转换类操作符，本篇我们将一起来学习RxJava过滤类操作符。过滤操作符主要是用来对事件数据进行过滤与筛选，只返回满足条件的数据，一起来看下都有哪些。 过滤操作符Filter filter操作符，按照一定的约束条件过滤序列中我们不想要的数据，只返回满足条件的数据给观察者。1234567891011121314151617181920//结合flatmap，过滤出各小区中房源大小大于120平的房子Observable.from(communities) .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.getHouses()); &#125; &#125;) .filter(new Func1&lt;House, Boolean&gt;() &#123; @Override public Boolean call(House house) &#123; return house.getSize() &gt; 120f; &#125; &#125;) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; Log.e(\"rx_test\", \"filter：大于120平的房子：\" + house.getCommunityName() + \"小区，大小：\" + house.getSize()); &#125; &#125;); 由代码可见，我们需要new一个Func1对象给filter()，Func1&lt;House, Boolean&gt;()中第一个是由观测序列传入数据的类型，第二个是返回是否过滤的Boolean对象。满足filter()的条件则返回true，否则返回false。并将返回为true的数据发射给观察者。 输出结果：1234567filter：大于120平的房子：东方花园小区，大小：144.8filter：大于120平的房子：东方花园小区，大小：144.8filter：大于120平的房子：马德里春天小区，大小：123.4filter：大于120平的房子：马德里春天小区，大小：123.4filter：大于120平的房子：帝豪家园小区，大小：188.7filter：大于120平的房子：帝豪家园小区，大小：188.7filter：大于120平的房子：帝豪家园小区，大小：188.7 原理图： 实际项目开发中，filter操作符可用来过滤数据集合中的null值，方便实用。 Take take(int count)操作符，可用来截取观测序列中前count个元素并发射。123456789//take：获取前两个小区名Observable.from(communities) .take(2) .subscribe(new Action1&lt;Community&gt;() &#123; @Override public void call(Community community) &#123; Log.e(\"rx_test\", \"take：前两个小区：\" + community.getCommunityName()); &#125; &#125;); 输出结果：12take：前两个小区：东方花园take：前两个小区：马德里春天 原理图： TakeLast takeLast(int count)操作符，顾名思义，截取观测序列中后count个元素并发射。123456789//takeLast：获取后两个小区名Observable.from(communities) .takeLast(2) .subscribe(new Action1&lt;Community&gt;() &#123; @Override public void call(Community community) &#123; Log.e(\"rx_test\", \"takeLast：后两个小区：\" + community.getCommunityName()); &#125; &#125;); 输出结果：12takeLast：后两个小区：马德里春天takeLast：后两个小区：帝豪家园 原理图： TakeUntil takeUntil操作符有两种类型的入参。 1.takeUntil(Observable) 订阅并开始发射原始Observable，同时监视我们提供的第二个Observable。如果第二个Observable发射了一项数据或者发射了一个终止通知，takeUntil()返回的Observable会停止发射原始Observable并终止。123456789101112131415161718192021//observableA每300ms发射一个Long型自增数据//observableB每800ms发射一个Long型自增数据Observable&lt;Long&gt; observableA = Observable.interval(300, TimeUnit.MILLISECONDS);Observable&lt;Long&gt; observableB = Observable.interval(800, TimeUnit.MILLISECONDS);observableA.takeUntil(observableB) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; Log.e(\"rx_test\", \"takeUntil(Observable)：\" + \"onCompleted\"); &#125; @Override public void onError(Throwable e) &#123; Log.e(\"rx_test\", \"takeUntil(Observable)：onError：\" + e.getMessage()); &#125; @Override public void onNext(Long aLong) &#123; Log.e(\"rx_test\", \"takeUntil(Observable)：onNext：\" + aLong); &#125; &#125;); 输出结果：123takeUntil(Observable)：onNext：0takeUntil(Observable)：onNext：1takeUntil(Observable)：onCompleted 由输出结果可看出，订阅之后，observableA依次发射0，1之后就发射onCompleted标记停止了。这是由于observableA每300ms发射一次，当发射完1后，时间已过去600ms，到800ms时observableB开始发射数据，takeUntil起作用则中断了observableA的发射。 原理图： 2.takeUntil(Func1) 通过传入的Func1中的call()方法判断是否中止发射数据。1234567891011121314151617181920//takeUntil：与flatmap结合过滤直到房价大于500时中断当前小Observable发射HouseObservable.from(communities) .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.getHouses()); &#125; &#125;) .takeUntil(new Func1&lt;House, Boolean&gt;() &#123; @Override public Boolean call(House house) &#123; return house.getPrice() &gt; 500; &#125; &#125;) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; Log.e(\"rx_test\", \"takeUntil：大于500时中断发射：\" + house.getCommunityName() + \"小区，房价：\" + house.getPrice()); &#125; &#125;); 输出结果：12takeUntil(Func1)：大于500时中断发射：东方花园小区，房价：200takeUntil(Func1)：大于500时中断发射：东方花园小区，房价：520 原理图： TakeWhile takeWhile操作符，类似于takeUntil(Func1)，不过takeWhile()是当Observable发射的数据不满足条件时中止Observable的发射。1234567891011121314//takeWhile：当发射的数据等于3时中止发射Observable.just(1, 2, 3, 4, 5) .takeWhile(new Func1&lt;Integer, Boolean&gt;() &#123; @Override public Boolean call(Integer integer) &#123; return integer != 3; &#125; &#125;) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.e(\"rx_test\", \"takeWhile：\" + integer); &#125; &#125;); 输出结果：12takeWhile：1takeWhile：2 原理图： Skip skip(int count)操作符，忽略发射观测序列的前count项数据。123456789//忽略前两个小区数据Observable.from(communities) .skip(2) .subscribe(new Action1&lt;Community&gt;() &#123; @Override public void call(Community community) &#123; Log.e(\"rx_test\", \"skip：忽略前两个小区：\" + community.getCommunityName()); &#125; &#125;); 输出结果：1skip：忽略前两个小区：帝豪家园 原理图： SkipLast skipLast(int count)操作符，忽略发射观测序列的后count项数据。123456789//忽略后两个小区数据Observable.from(communities) .skipLast(2) .subscribe(new Action1&lt;Community&gt;() &#123; @Override public void call(Community community) &#123; Log.e(\"rx_test\", \"skip：忽略后两个小区：\" + community.getCommunityName()); &#125; &#125;); 输出结果：1忽略后两个小区：东方花园 原理图： SkipUntil skipUntil操作符，与takeUntil()相反。订阅并开始发射原始Observable，同时监视我们提供的第二个Observable。如果第二个Observable发射了一项数据或者发射了一个终止通知，skipUntil()返回的Observable才会开始发射数据，忽略之前的数据项。 原理图： SkipWhile skipWhile操作符，与takeWhile相反，当Observable发射的数据不满足条件时才开始发射数据，忽略之前的数据项。 原理图： Debounce debounce操作符有两种类型的入参。 1.debounce(long, TimeUnit) 过滤由Observable发射的速率过快的数据，起到限流的作用。第一个参数为限流时间，第二个参数为时间单位。123456789101112131415161718192021222324252627282930Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; try &#123; for (int i = 1; i &lt; 10; i++) &#123; subscriber.onNext(i); Thread.sleep(i * 100); //分别延时100，200，300，400，500......900ms发射数据 &#125; subscriber.onCompleted(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;).subscribeOn(Schedulers.newThread()) .debounce(400, TimeUnit.MILLISECONDS) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; Log.e(\"rx_test\", \"debounce：\" + \"onCompleted\"); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Integer integer) &#123; Log.e(\"rx_test\", \"debounce：\" + integer); &#125; &#125;); 输出结果：123456debounce：5debounce：6debounce：7debounce：8debounce：9debounce：onCompleted 由输出结果可以看出由于设定限流时间为500ms，所以1-4并没有被发射而是被过滤了。 注意：如果源Observable产生的最后一个结果在限流时间内内调用了onCompleted，那么通过debounce操作符也会把这个结果提交给订阅者。 原理图： 2.debounce(Func1) 根据Func1的call方法中的函数来过滤。Func1中的中的call方法返回了一个临时的Observable，如果原始的Observable在发射一个新的数据时，上一个数据根据Func1的call方法生成的临时Observable还没结束，那么上一个数据就会被过滤掉。 原理图： Distinct 1.distinct() 只允许还没有发射过的数据通过，达到去除序列中重复项的作用。123456789//去除重复数字Observable.just(1, 2, 2, 3, 4, 5, 6, 6, 6, 7) .distinct() .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.e(\"rx_test\", \"distinct：去重：\" + integer); &#125; &#125;); 输出结果：1234567distinct：去重：1distinct：去重：2distinct：去重：3distinct：去重：4distinct：去重：5distinct：去重：6distinct：去重：7 由输出结果可见有重复的2和6都被过滤了。 原理图： 2.distinct(Func1) 根据Func1中的call方法进行去重，call方法会根据Observable发射的值生成一个Key，然后比较这个key来判断两个数据是否相同，如果判定为重复则会和distinct()一样过滤掉重复的数据项。1234567891011121314151617181920//根据某属性去重，去除各小区大小相同的房源Observable.from(communities) .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.getHouses()); &#125; &#125;) .distinct(new Func1&lt;House, Float&gt;() &#123; @Override public Float call(House house) &#123; return house.getSize(); &#125; &#125;) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; Log.e(\"rx_test\", \"distinct(Func1)：去重：\" + house.getCommunityName() + \"小区，大小：\" + house.getSize()); &#125; &#125;); 输出结果：123456distinct(Func1)：去重：东方花园小区，大小：105.6distinct(Func1)：去重：东方花园小区，大小：144.8distinct(Func1)：去重：马德里春天小区，大小：88.6distinct(Func1)：去重：马德里春天小区，大小：123.4distinct(Func1)：去重：帝豪家园小区，大小：188.7distinct(Func1)：去重：帝豪家园小区，大小：56.4 DistinctUntilChanged 1.distinctUntilChanged() 通过当前数据项与前一项是否相同来进行去重。123456789//向前去重复数据Observable.just(1, 2, 2, 3, 4, 2, 3, 5, 5) .distinctUntilChanged() .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.e(\"rx_test\", \"distinctUntilChanged：向前去重：\" + integer); &#125; &#125;); 输出结果：1234567distinctUntilChanged：向前去重：1distinctUntilChanged：向前去重：2distinctUntilChanged：向前去重：3distinctUntilChanged：向前去重：4distinctUntilChanged：向前去重：2distinctUntilChanged：向前去重：3distinctUntilChanged：向前去重：5 原理图： 2.distinctUntilChanged(Func1) 与distinct(Func1)类似，根据Func1中call方法产生一个key来判断相邻两个数据项是否相同。1234567891011121314151617181920//根据某属性向前去重，去除各小区名相同的房源Observable.from(communities) .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.getHouses()) .distinctUntilChanged(new Func1&lt;House, String&gt;() &#123; @Override public String call(House house) &#123; return house.getCommunityName(); &#125; &#125;); &#125; &#125;) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; Log.e(\"rx_test\", \"distinctUntilChanged(Func1)：向前去重：\" + house.getCommunityName() + \"小区，大小：\" + house.getSize()); &#125; &#125;); 输出结果：123distinctUntilChanged(Func1)：向前去重：东方花园小区，大小：105.6distinctUntilChanged(Func1)：向前去重：马德里春天小区，大小：88.6distinctUntilChanged(Func1)：向前去重：帝豪家园小区，大小：188.7 ElementAt elementAt(int index)操作符，获取观测序列中第index项索引，并作为唯一数据发射给观察者，index索引从0开始。12345678Observable.from(communities) .elementAt(1) .subscribe(new Action1&lt;Community&gt;() &#123; @Override public void call(Community community) &#123; Log.e(\"rx_test\", \"elementAt：第二个小区：\" + community.getCommunityName()); &#125; &#125;); 输出结果：1elementAt：第二个小区：马德里春天 原理图： First 1.first() 只发射观测序列中的第一个数据项。12345678Observable.from(communities) .first() .subscribe(new Action1&lt;Community&gt;() &#123; @Override public void call(Community community) &#123; Log.e(\"rx_test\", \"first：\" + community.getCommunityName()); &#125; &#125;); 输出结果：1first：东方花园 原理图： 2.first(Func1) 根据Func1中call方法的条件，发射符合条件的第一个数据项。1234567891011121314//过滤出第一个小区名为马德里春天的小区Observable.from(communities) .first(new Func1&lt;Community, Boolean&gt;() &#123; @Override public Boolean call(Community community) &#123; return \"马德里春天\".equals(community.getCommunityName()); &#125; &#125;) .subscribe(new Action1&lt;Community&gt;() &#123; @Override public void call(Community community) &#123; Log.e(\"rx_test\", \"first(Func1)：\" + community.getCommunityName()); &#125; &#125;); 输出结果：1first(Func1)：马德里春天 Last 1.last() 只发射观测序列中的最后一个数据项。123456789//发送最后一个数据项Observable.from(communities) .last() .subscribe(new Action1&lt;Community&gt;() &#123; @Override public void call(Community community) &#123; Log.e(\"rx_test\", \"last：\" + community.getCommunityName()); &#125; &#125;); 输出结果：1last：帝豪家园 原理图： 2.last(Func1) 根据Func1中call方法的条件，发射符合条件的最后一个数据项。1234567891011121314151617181920//发送符合条件的最后一个数据项：过滤最后一个小区名为马德里春天的房源Observable.from(communities) .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.getHouses()); &#125; &#125;) .last(new Func1&lt;House, Boolean&gt;() &#123; @Override public Boolean call(House house) &#123; return \"马德里春天\".equals(house.getCommunityName()); &#125; &#125;) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; Log.e(\"rx_test\", \"last：\" + house.getCommunityName() + \"小区，大小：\" + house.getSize()); &#125; &#125;); 输出结果：1last：马德里春天小区，大小：88.6 总结 到此，本篇关于RxJava的常用过滤类操作符就讲解完毕了，下一篇我们将一起研究RxJava的四类操作符中的组合操作符都有哪些以及如何使用。 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。 附上RxJavaDemo的地址： RxJavaDemo","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://LeiHolmes.github.io/tags/RxJava/"}]},{"title":"RxJava操作符之转换操作符(四)","slug":"RxJava操作符之转换操作符(四)","date":"2017-10-11T16:00:00.000Z","updated":"2017-10-16T06:36:23.000Z","comments":true,"path":"2017/10/12/RxJava操作符之转换操作符(四)/","link":"","permalink":"http://LeiHolmes.github.io/2017/10/12/RxJava操作符之转换操作符(四)/","excerpt":"前言 上一篇文章我们学习了创建类操作符，本篇我们将一起来学习RxJava转换类操作符。所谓转换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。下面来看下转换类操作符都有哪些及其使用场景。","text":"前言 上一篇文章我们学习了创建类操作符，本篇我们将一起来学习RxJava转换类操作符。所谓转换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。下面来看下转换类操作符都有哪些及其使用场景。 初始化数据 还是使用系列第一篇的小区与房源的例子。先初始化假数据以便实践操作符时使用。12345678910111213//小区实体public class Community &#123; private String communityName; //小区名称 private List&lt;House&gt; houses; //房源集合&#125;//房源实体public class House &#123; private float size; //大小 private int floor; //楼层 private int price; //总价 private String decoration; //装修程度 private String communityName; //小区名称&#125; 12345678910111213141516171819202122232425262728293031323334private List&lt;Community&gt; communities;private void initData() &#123; communities = new ArrayList&lt;&gt;(); List&lt;House&gt; houses1 = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; if (i % 2 == 0) &#123; houses1.add(new House(105.6f, i, 200, \"简单装修\", \"东方花园\")); &#125; else &#123; houses1.add(new House(144.8f, i, 520, \"豪华装修\", \"东方花园\")); &#125; &#125; communities.add(new Community(\"东方花园\", houses1)); List&lt;House&gt; houses2 = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; if (i % 2 == 0) &#123; houses2.add(new House(88.6f, i, 166, \"中等装修\", \"马德里春天\")); &#125; else &#123; houses2.add(new House(123.4f, i, 321, \"精致装修\", \"马德里春天\")); &#125; &#125; communities.add(new Community(\"马德里春天\", houses2)); List&lt;House&gt; houses3 = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; if (i % 2 == 0) &#123; houses3.add(new House(188.7f, i, 724, \"豪华装修\", \"帝豪家园\")); &#125; else &#123; houses3.add(new House(56.4f, i, 101, \"普通装修\", \"帝豪家园\")); &#125; &#125; communities.add(new Community(\"帝豪家园\", houses3));&#125; 转换操作符Map map操作符，接收一个指定的Func1类型对象，然后将其应用到每一个由Observable发射的值上，进而将发射的值转换为我们期望的值。来看一下原理图与实例： 1234567891011121314151617181920212223242526272829//将一组Integer转换成StringObservable.just(1, 2, 3, 4, 5) .map(new Func1&lt;Integer, String&gt;() &#123; @Override public String call(Integer integer) &#123; return \"This is \" + integer; &#125; &#125;) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e(\"rx_test\", s); &#125; &#125;); //将Community集合转换为每一个Community并获取其nameObservable.from(communities) .map(new Func1&lt;Community, String&gt;() &#123; @Override public String call(Community community) &#123; return community.getCommunityName(); &#125; &#125;) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String communityName) &#123; Log.e(\"rx_test\", \"小区名称为：\" + communityName); &#125; &#125;); 输出结果：12345678This is 1This is 2This is 3This is 4This is 5小区名称为：东方花园小区名称为：马德里春天小区名称为：帝豪家园 由输出结果可看出，map操作符可用来进行数据的类型转换，拼接或者对集合进行遍历等1对1的转换。第一个例子中，Func1&lt;Integer, String&gt;()第一个参数是发射数据当前的类型，第二个参数是转换之后的数据类型。Action1&lt;String&gt;中参数也为发射数据转换之后的数据类型。 注意数据类型需对应准确，不要弄错了。 FlatMap flatMap操作符，也是用来转换的，但与map操作符不同之处是，flatMap()返回的是Observable对象，且这个Observable对象并不是被直接发送到了 Subscriber的回调方法中。 这么说可能不易理解，我们来看小区与房的例子，现在有3个小区，如果我们想打印出这3个小区中所有房源的信息，通过RxJava要如何做到？按照之前学习的我们或许会这么实现：12345678910Observable.from(communities) .subscribe(new Action1&lt;Community&gt;() &#123; @Override public void call(Community community) &#123; for (House house : community.getHouses()) &#123; Log.e(\"rx_test\", \"flatMap：小区名称：\" + house.getCommunityName() + \"，价格：\" + house.getPrice() + \"，楼层：\" + house.getFloor()); &#125; &#125; &#125;); 按照这种实现方法我们只可获取到每个小区这一层，想要获取小区中的房源还需进行一层for循环遍历，这就违背了RxJava的原则了。那么来看下flatMap()如何实现：1234567891011121314Observable.from(communities) .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.getHouses()); &#125; &#125;) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; Log.e(\"rx_test\", \"flatMap：小区名称：\" + house.getCommunityName() + \"，价格：\" + house.getPrice() + \"，楼层：\" + house.getFloor()); &#125; &#125;); 这样的代码是不是看起来舒心多了，再来看下flatMap()是如何实现的。 首先from()接收到小区集合communities后为其创建了一个Observable，依次将每个小区传递给flatMap()，flatMap()在每次接收到小区后会将其中包含的房源集合拿出来又创建了一个房源Observable，并激活这个房源Observable让其开始发射事件，之后返回给小区集合的Observable，最后小区集合的Observable再将这些事件统一交给Subscriber的回调方法去处理。 整个过程有两级Observable在运作，相当于将小区集合Observable这个初始对象铺平之后再通过统一路径分发下去，铺平这个工作就是flatMap所做的。 输出结果：123456789101112131415flatMap：小区名称：东方花园，价格：200，楼层：0flatMap：小区名称：东方花园，价格：520，楼层：1flatMap：小区名称：东方花园，价格：200，楼层：2flatMap：小区名称：东方花园，价格：520，楼层：3flatMap：小区名称：东方花园，价格：200，楼层：4flatMap：小区名称：马德里春天，价格：166，楼层：0flatMap：小区名称：马德里春天，价格：321，楼层：1flatMap：小区名称：马德里春天，价格：166，楼层：2flatMap：小区名称：马德里春天，价格：321，楼层：3flatMap：小区名称：马德里春天，价格：166，楼层：4flatMap：小区名称：帝豪家园，价格：724，楼层：0flatMap：小区名称：帝豪家园，价格：101，楼层：1flatMap：小区名称：帝豪家园，价格：724，楼层：2flatMap：小区名称：帝豪家园，价格：101，楼层：3flatMap：小区名称：帝豪家园，价格：724，楼层：4 由输出结果可看出这3个小区的所有房源信息都被依次打印了出来，但flatMap()有一个问题就是当数据量过大时可能会出现输出数据顺序交错的问题。 官方原理图： ConcatMap concatMap操作符，与flatMap()功能类似。不同之处是concatMap()采用连接方式而不是合并方式，所以其发射的数据是严格按照顺序的，这就解决了flatMap()有可能发生数据交错的问题。 原理图： FlatMapIterable flatMapIterable操作符，也与flatMap()相似，不同之处在于flatMapIterable转化多个Observable是使用Iterable作为源数据的。12345678910111213Observable.from(communities) .flatMapIterable(new Func1&lt;Community, Iterable&lt;House&gt;&gt;() &#123; @Override public Iterable&lt;House&gt; call(Community community) &#123; return community.getHouses(); &#125; &#125;).subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; Log.e(\"rx_test\", \"flatMap：小区名称：\" + house.getCommunityName() + \"，价格：\" + house.getPrice() + \"，楼层：\" + house.getFloor()); &#125;&#125;); SwitchMap switchMap转换操作符，也与flatMap()相似，每当源Observable发射新数据项(Observable)时，它将取消订阅并停止监视之前那个数据项产生Observable，并开始监视当前发射的这一个。1234567891011121314Observable.from(communities) .switchMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.getHouses()); &#125; &#125;) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; Log.e(\"rx_test\", \"flatMap：小区名称：\" + house.getCommunityName() + \"，价格：\" + house.getPrice() + \"，楼层：\" + house.getFloor()); &#125; &#125;); 如之前的例子，当数据量很大时，某一时刻，第一个小区所生成的小房源Observable正在发射数据，这时第二个小区所生成的小房源Observable被激活，则第一个小区的小Observable就会被取消订阅，其还未发射的数据也不在发射了。第二个小区小Observable开始发射数据，之后都同理。 原理图： Scan scan操作符，对一个序列的数据应用一个函数，并将这个函数的结果发射出去作为下个数据应用函数时的第一个参数使用。1234567891011121314//例如：先输出1，再将1+2=3作为下个数据发出，3+3=6再作为下个数据发出，以此类推。Observable.just(1, 2, 3, 4, 5) .scan(new Func2&lt;Integer, Integer, Integer&gt;() &#123; @Override public Integer call(Integer integer, Integer integer2) &#123; return integer + integer2; &#125; &#125;) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.e(\"rx_test\", \"scan：\" + integer); &#125; &#125;); 输出结果：12345scan：1scan：3scan：6scan：10scan：15 原理图： GroupBy groupBy操作符，将原始Observable发射的数据按照key来拆分成一些小的Observable，然后这些小的Observable分别发射其所包含的的数据。通俗的说就是按照某个字段将数据进行分类再发射。 来看一个例子：有几个小区的多套房源数据，现在需要将其按照小区名称进行分类并输出。1234567891011121314151617181920212223242526List&lt;House&gt; houseList = new ArrayList&lt;&gt;();houseList.add(new House(105.6f, 1, 200, \"简单装修\", \"东方花园\"));houseList.add(new House(144.8f, 3, 300, \"豪华装修\", \"马德里春天\"));houseList.add(new House(88.6f, 2, 170, \"简单装修\", \"东方花园\"));houseList.add(new House(123.4f, 1, 250, \"简单装修\", \"帝豪家园\"));houseList.add(new House(144.8f, 6, 350, \"豪华装修\", \"马德里春天\"));houseList.add(new House(105.6f, 4, 210, \"普通装修\", \"东方花园\"));houseList.add(new House(188.7f, 3, 400, \"精致装修\", \"帝豪家园\"));houseList.add(new House(88.6f, 2, 180, \"普通装修\", \"东方花园\"));//根据小区名称进行分类Observable&lt;GroupedObservable&lt;String, House&gt;&gt; groupByCommunityNameObservable = Observable .from(houseList) .groupBy(new Func1&lt;House, String&gt;() &#123; @Override public String call(House house) &#123; //提供分类规则的key return house.getCommunityName(); &#125; &#125;);Observable.concat(groupByCommunityNameObservable) //concat组合操作符，将多个Observable有序组合并发送，后期会详细讲解 .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; Log.e(\"rx_test\", \"groupBy：\" + \"小区：\" + house.getCommunityName() + \"，价格：\" + house.getPrice()); &#125; &#125;); 创建一个新的Observable：groupByCommunityNameObservable，它将会发送一个带有GroupedObservable的序列（也就是指发送的数据项的类型为GroupedObservable）。GroupedObservable是一个特殊的Observable，它基于一个分组的key，在这个例子中的key就是小区名。 输出结果：12345678groupBy：小区：东方花园，价格：200groupBy：小区：东方花园，价格：170groupBy：小区：东方花园，价格：210groupBy：小区：东方花园，价格：180groupBy：小区：马德里春天，价格：300groupBy：小区：马德里春天，价格：350groupBy：小区：帝豪家园，价格：250groupBy：小区：帝豪家园，价格：400 原理图： 总结 到此，本篇关于RxJava的常用转换类操作符就讲解完毕了，下一篇我们将一起研究RxJava的四类操作符中的过滤操作符都有哪些以及如何使用。 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。 附上RxJavaDemo的地址： RxJavaDemo","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://LeiHolmes.github.io/tags/RxJava/"}]},{"title":"RxJava操作符之创建操作符(三)","slug":"RxJava操作符之创建操作符(三)","date":"2017-10-10T16:00:00.000Z","updated":"2017-10-16T06:37:37.000Z","comments":true,"path":"2017/10/11/RxJava操作符之创建操作符(三)/","link":"","permalink":"http://LeiHolmes.github.io/2017/10/11/RxJava操作符之创建操作符(三)/","excerpt":"前言 通过前两篇文章对于RxJava概念，原理及使用的学习，想必各位码友已经基本掌握RxJava的逻辑与功能了，那么从这篇文章开始我们来研究RxJava的各类操作符。","text":"前言 通过前两篇文章对于RxJava概念，原理及使用的学习，想必各位码友已经基本掌握RxJava的逻辑与功能了，那么从这篇文章开始我们来研究RxJava的各类操作符。 什么是操作符？通过之前的学习，我们发现Observable负责发送事件，Observer负责接收事件，而这个过程中想要对事件数据做出修改就需要交给操作符来负责啦。主流RxJava中操作符主要分为三类：转换操作符，过滤操作符，组合操作符。而我个人将用来创建Observable的操作符归为了一个新类型。本篇我们就来看看常用的创建操作符都有哪些以及如何使用。 创建操作符Create 上一篇文章的例子中我们已经实践了create操作符如何使用了，这里我们介绍一种便捷的创建Observer的方式。1234567891011121314Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; for (int i = 0; i &lt; 5; i++) &#123; subscriber.onNext(\"xulei\" + i); &#125; subscriber.onCompleted(); &#125;&#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e(\"rx_test\", \"create:\" + s); &#125;&#125;); subscribe()的入参使用Action1代替原来的Observer，只需重写一个call()方法，等同于原Observer中onNext()方法。如果需要onComplete与onError状态，还可以如下：12345678910111213141516.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e(\"rx_test\", \"create:\" + s); &#125;&#125;, new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable throwable) &#123; Log.e(\"rx_test\", \"onError:\" + throwable.getMessage()); &#125;&#125;, new Action0() &#123; @Override public void call() &#123; Log.e(\"rx_test\", \"onCompleted\"); &#125;&#125;); 使用new ActionX代替new Observer，代码是不是看起来更加灵活与简洁呢。 Just just操作符可将某个或某些对象转化为Observable对象，并将其发射出去。参数可为一个或多个数字，字符串。也可为集合，数组，Iterate对象等。12345678910111213141516171819Observable.just(1, 2, 3, 4, 5, 6).subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.e(\"rx_test\", \"just:数字：\" + integer); //数字或者字符串都是单个发射多次 &#125;&#125;);List&lt;String&gt; stringList = new ArrayList&lt;&gt;();stringList.add(\"Hello\");stringList.add(\"Ha\");stringList.add(\"RxJava\");Observable.just(stringList).subscribe(new Action1&lt;List&lt;String&gt;&gt;() &#123; @Override public void call(List&lt;String&gt; strings) &#123; Log.e(\"rx_test\", \"just:集合：\" + strings.toString()); //集合或数组是直接发射集合整体，不会拆分 &#125;&#125;); 输出结果：1234567just:数字：1just:数字：2just:数字：3just:数字：4just:数字：5just:数字：6just:集合：[Hello, Ha, RxJava] From from操作符可将某个对象转化为Observable对象，并且将其发射出去。不同于just，他接收集合或数组，并可将集合数组遍历之后拆分发送。12345678910List&lt;String&gt; stringList = new ArrayList&lt;&gt;();stringList.add(\"Hello\");stringList.add(\"Ha\");stringList.add(\"RxJava\");Observable.from(stringList).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e(\"rx_test\", \"from：\" + s); &#125;&#125;); 输出结果：123from：Hellofrom：Hafrom：RxJava Range range(int start, int count)操作符，根据初始值start，与数量count，发射count次以start为基数依次增加的值。123456Observable.range(4, 5).subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.e(\"rx_test\", \"range：\" + integer); &#125;&#125;); 输出结果：12345range：4range：5range：6range：7range：8 Defer defer操作符功能类似于just操作符，不同之处在于defer只有在调用subscribe()方法进行订阅时才创建Observable，而just操作符在初始化Observable就已经创建了，且只创建一个Observable实例。这里我们通过与just对比进行实践。123456789101112131415161718192021222324Action1&lt;String&gt; action1 = new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e(\"rx_test\", s); &#125;&#125;;//deferObservable&lt;String&gt; deferObservable = Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call() &#123; Object o = new Object(); return Observable.just(\"defer：hashCode：\" + o.hashCode()); &#125;&#125;);deferObservable.subscribe(action1);deferObservable.subscribe(action1);deferObservable.subscribe(action1);//justObservable&lt;String&gt; justObservable = Observable.just(\"just：hashCode：\" + new Object().hashCode());justObservable.subscribe(action1);justObservable.subscribe(action1);justObservable.subscribe(action1); 输出结果：123456defer：hashCode：112449879defer：hashCode：118897732defer：hashCode：191664429just：hashCode：121878114just：hashCode：121878114just：hashCode：121878114 由输出结果我们可以看出defer每次输出的Observable哈西值是不同的，说明其每subscribe订阅一次都会创建一个新的Observable，从而可保证Observable中的数据都是最新的。而just只有初始化的时候创建一次Observable。 Interval interval创建操作符，创建一个Observabel并每隔一段时间周期发射一个由0开始增加的数字。 注意：此Observabel是运行在新的线程，所以更新UI需要在主线程中订阅12345678910//每隔100ms发射一个数字,从0自增Observable.interval(100, TimeUnit.MILLISECONDS) //单位为毫秒 .observeOn(AndroidSchedulers.mainThread()) .take(5) //取前5次事件发射，take为过滤操作符，后期会详细讲 .subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; Log.e(\"rx_test\", \"interval：\" + aLong); &#125; &#125;); 输出结果：12345678910100ms后...interval：0100ms后...interval：1100ms后...interval：2100ms后...interval：3100ms后...interval：4 Timer timer操作符，创建一个Observable并隔一段时间后发射一个特殊的值，仅发射一次。 注意：此Observabel是运行在新的线程，所以更新UI需要在主线程中订阅123456789//隔1s后发射一个数字Observable.timer(1, TimeUnit.SECONDS) //单位为秒 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; Log.e(\"rx_test\", \"timer：\" + aLong); &#125; &#125;); 输出结果：121秒后...timer：0 Delay delay操作符，可用于延迟一定时长再发送事件。123456789//延迟2秒后发射事件Observable.just(1, 2, 3) .delay(2, TimeUnit.SECONDS) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.e(\"rx_test\", \"delay：\" + integer); &#125; &#125;); 输出结果：12342秒后...delay：1delay：2delay：3 Repeat repeat(long count)操作符，将Observable重复发射count次。12345678//重复发射5次“Sherlock”Observable.just(\"Sherlock\").repeat(5) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e(\"rx_test\", \"repeat：\" + s); &#125; &#125;); 输出结果：12345repeat：Sherlockrepeat：Sherlockrepeat：Sherlockrepeat：Sherlockrepeat：Sherlock 以上就是常用的一些创建操作符，类似但不常用的还有empty、never、error等等就不一一介绍了，有兴趣的码友可以自行百度。 线程调度Scheduler RxJava就是用来处理异步任务的，所以就牵扯到生产事件所在线程，处理事件所在线程的问题，下面来看一下RxJava提供的线程调度Scheduler都有哪些。 有了Scheduler，RxJava当然也提供了方法来使用它们。 .subscribeOn()指定被观察者Observable的执行线程。 .observeOn()指定观察者Observer的执行线程。 如第一篇文章中的例子：1234567891011121314151617181920212223//获取要查询的小区集合Observable.from(getCommunitiesFromServer()) .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.getHouses()); &#125; &#125;) .filter(new Func1&lt;House, Boolean&gt;() &#123; @Override public Boolean call(House house) &#123; return house.getPrice() &lt; 200; &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; //显示查询出来的房源信息 ShowSearchedHousesMessage(); &#125; &#125;); 其中.subscribeOn(Schedulers.io())指定了Observable在io线程运行，通常用来执行从服务器获取数据，数据库加载等耗时操作。.observeOn(AndroidSchedulers.mainThread())指定了Observer在Android环境下的UI线程运行，通常用来获取到数据后进行UI刷新的操作。可根据实际需求选择不同线程类型。 总结 到此，本篇关于RxJava的创建类操作符以及线程调度就讲解完毕了，下一篇我们将一起研究RxJava的四类操作符中的转换操作符都有哪些以及如何使用。 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。 附上RxJavaDemo的地址： RxJavaDemo","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://LeiHolmes.github.io/tags/RxJava/"}]},{"title":"RxJava基本原理与使用(二)","slug":"RxJava基本原理与使用(二)","date":"2017-09-27T16:00:00.000Z","updated":"2017-10-16T09:54:17.000Z","comments":true,"path":"2017/09/28/RxJava基本原理与使用(二)/","link":"","permalink":"http://LeiHolmes.github.io/2017/09/28/RxJava基本原理与使用(二)/","excerpt":"前言 上一篇我们了解了RxJava的介绍以及通过一个例子学习了RxJava的展现形式，相信大家现在已经对RxJava有一个初步的印象与概念了。本篇我们将更深入的学习RxJava的基本原理以及如何使用RxJava。","text":"前言 上一篇我们了解了RxJava的介绍以及通过一个例子学习了RxJava的展现形式，相信大家现在已经对RxJava有一个初步的印象与概念了。本篇我们将更深入的学习RxJava的基本原理以及如何使用RxJava。 观察者模式 上一篇有提到RxJava的核心便是扩展的观察者模式，我们先来学习一下观察者模式。 事件：小明按下遥控器开关，空调启动并开始吹风了。按下制冷按键，空调吹出的风变为凉风。再按下3档风速按键，空调吹的风变大了。 在这个事件中，空调作为观察者，遥控器作为被观察者，空调通过红外线检测遥控器传来的信号并作出响应。 通过上图我们可以很清晰的看出遥控器作为事件的生产方主动发起事件，是事件的起点，而空调作为事件的处理方被动接收事件做出响应，是事件的终点。而在事件传递的过程中可对事件进行过滤，转换，合并等操作，就像例子中制冷与加大风速的效果。 这个概念是RxJava中的核心，它是基于观察者模式来组建自己的程序逻辑，遥控器就相当于RxJava的被观察者Observable，空调相当于观察者Observer，而对事件处理的一些操作相当于各类操作符。不同的是RxJava中观察者需要对被观察者进行订阅，这样当被观察者发出事件时，观察者才会接收到事件进行处理。若未进行订阅，被观察者是不会发出任何事件的。 使用 了解了观察者模式，接下来动起指尖尝试下怎么使用RxJava。 创建被观察者Observable 第一步：创建被观察者Observable：12345678910Observable&lt;Object&gt; observable = Observable.create(new Observable.OnSubscribe&lt;Object&gt;() &#123; @Override public void call(Subscriber&lt;? super Object&gt; subscriber) &#123; //被观察者的数据操作更新 for (int i = 0; i &lt; 5; i++) subscriber.onNext(\"xulei\" + i); &#125; subscriber.onCompleted(); &#125;&#125;); 通过Observable.create()方法创建并返回一个Observable对象，create()方法需要一个OnSubsribe对象作为参数传入并执行call()方法。此OnSubsribe对象继承自Action1。 而在call()方法中可通过subscriber.onNext()进行事件的发送，subscriber.onCompleted()标记为事件发送完毕。subscriber.onError()标记为事件发送过程出现异常。 除create()方法创建Observable方式外，还可以使用just()与from()等方式，这个在之后的创建操作符文章中会有讲解。 创建观察者Observer 第二步：创建观察者Observer：1234567891011121314Observer observer = new Observer() &#123; @Override public void onCompleted() &#123; //标记事件发送完毕的回调 Log.e(\"rx_test\", \"onCompleted\"); &#125; @Override public void onError(Throwable e) &#123; //事件发送过程出现异常的回调 Log.e(\"rx_test\", \"onError\"); &#125; @Override public void onNext(Object o) &#123; //接收到发送事件的回调 Log.e(\"rx_test\", \"onNext:\" + o.toString()); &#125;&#125;; 在以往普通的观察者模式中，观察者通常只提供一个update()的方法，而RxJava扩展的观察者模式中的观察者提供onNext(Object o)，onCompleted()，onError(Throwable e)三个方法，分别对应被观察者call()方法中重写的subscriber.onNext()，subscriber.onCompleted()，subscriber.onError()方法。而onNext()方法就对应普通观察者模式中的update()方法。 RxJava扩展的观察模式弥补了普通观察者模式的不足： 1. 当事件发送完毕可以调用onCompleted()方法进行标示。 2. 当事件发送过程中出现异常会自动触发onError()方法，也可进行手动调用。 3. Observable支持链式编程，从而避免了回调嵌套的问题，也简化了代码。 订阅 最后一步：被观察者Observable订阅观察者Observer。 这里不同于普通观察者模式，上一篇我们讲了在RxJava扩展观察者模式中，如果没有观察者，被观察者是不会发出任何事件的。所以这里是被观察者订阅观察者。1observable.subscribe(observer); 订阅很简单，一行代码搞定。调用Observable的subscribe()方法，传入观察者对象作为参数，这样被观察者与观察者就进行了绑定。 简写 RxJava可以使用链式编程：1234567891011121314151617181920212223Observable.create(new Observable.OnSubscribe&lt;Object&gt;() &#123; @Override public void call(Subscriber&lt;? super Object&gt; subscriber) &#123; //被观察者的数据操作更新 for (int i = 0; i &lt; 5; i++) &#123; subscriber.onNext(\"xulei\" + i); &#125; subscriber.onCompleted(); &#125;&#125;).subscribe(new Observer&lt;Object&gt;() &#123; @Override public void onCompleted() &#123; Log.e(\"rx_test\", \"onCompleted\"); &#125; @Override public void onError(Throwable e) &#123; Log.e(\"rx_test\", \"onError\"); &#125; @Override public void onNext(Object o) &#123; Log.e(\"rx_test\", \"onNext:\" + o.toString()); &#125;&#125;); 逻辑梳理 到此一个RxJava的简单调用就实现了，相信不少码友看完之后还是很懵13，那我们再来梳理一下整个流程。首先使用Observable.create()创建了一个Observable，并在create()方法中传入了一个OnSubscribe对象作为参数，重写OnSubscribe中的call()方法，当Observable进行订阅后就会自动触发call()方法发送事件。 注意：call()方法中的subscriber参数其实就是我们在调用subscribe()进行订阅时时传入的观察者Observer。所以当在call()方法中调用的5次onNext()方法与1次onCompleted()方法后，观察者Observer中输出的日志为：123456onNext:xulei0onNext:xulei1onNext:xulei2onNext:xulei3onNext:xulei4onCompleted 有的码友看到这里会对call()方法中的subscriber参数就是订阅时传入的Observer有些不解，那么我们一起来看源码。 先看下call()方法中的参数Subscriber：123public abstract class Subscriber&lt;T&gt; implements Observer&lt;T&gt;, Subscription &#123; ......&#125; 可以看出Subscriber是Observer的抽象实现类，与Observer一个类型。再来看订阅时调用的subscribe(observer)方法：1234567891011121314151617181920212223public final Subscription subscribe(final Observer&lt;? super T&gt; observer) &#123; //无视 if (observer instanceof Subscriber) &#123; return subscribe((Subscriber&lt;? super T&gt;)observer); &#125; return subscribe(new Subscriber&lt;T&gt;() &#123; @Override public void onCompleted() &#123; observer.onCompleted(); &#125; @Override public void onError(Throwable e) &#123; observer.onError(e); &#125; @Override public void onNext(T t) &#123; observer.onNext(t); &#125; &#125;);&#125; 这里将传入的Observer对象通过代理转换为Subscriber对象作为参数传入并调用重载方法subscribe()，我们再来看这个subscribe()方法的代码：123public final Subscription subscribe(Subscriber&lt;? super T&gt; subscriber) &#123; return Observable.subscribe(subscriber, this);&#125; 这里继续调用重载方法subscribe()，将由Observer转换为的subscriber对象与当前Observable对象作为参数传入，继续往下追踪源码：123456789101112private static &lt;T&gt; Subscription subscribe(Subscriber&lt;? super T&gt; subscriber, Observable&lt;T&gt; observable) &#123; ...... subscriber.onStart(); ...... try &#123; hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber); return hook.onSubscribeReturn(subscriber); &#125; catch (Throwable e) &#123; ...... return Subscriptions.unsubscribed(); &#125;&#125; 精简一下代码发现，subscriber.onStart()用来通知被观察者准备开始发送事件了。重点看hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);我们发现hook.onSubscribeStart(observable, observable.onSubscribe)方法返回的是其第二个参数observable.onSubscribe，这个参数正是新建Observable时create()方法中传入的OnSubscribe对象。接着又通过这个onSubscribe调用call(subscriber)方法，将subscriber作为参数传入，码友们有没有发现，这个subscriber传来传去究其根源，正是一开始由订阅方法subscribe(observer)传入的observer通过代理转换为的那个subscriber。 这样前后逻辑就连接上了，通过阅读源码我们才能发现为何创建Observable时call()方法中的subscriber参数其实就是订阅时传入的Observer。 总结 到此，本篇关于RxJava的基本原理与使用就讲解完毕了，下一篇我们将一起研究RxJava的四类操作符中的创建操作符都有哪些以及如何使用。 这里感谢下张磊大神撰写的RxJava系列的帮助： RxJava系列2(基本概念及使用介绍) 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。 附上RxJavaDemo的地址： RxJavaDemo","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://LeiHolmes.github.io/tags/RxJava/"}]},{"title":"RxJava简介与入门(一)","slug":"RxJava简介与入门(一)","date":"2017-09-20T16:00:00.000Z","updated":"2017-10-13T08:32:28.000Z","comments":true,"path":"2017/09/21/RxJava简介与入门(一)/","link":"","permalink":"http://LeiHolmes.github.io/2017/09/21/RxJava简介与入门(一)/","excerpt":"前言 最近在学习RxJava的过程中,越发感受到这个框架的强大，对于提升开发效率，降低维护成本有很大的作用。有必要强行安利一波，一起来看看RxJava简介，基本概念，原理与使用，本篇主要介绍RxJava的简介。","text":"前言 最近在学习RxJava的过程中,越发感受到这个框架的强大，对于提升开发效率，降低维护成本有很大的作用。有必要强行安利一波，一起来看看RxJava简介，基本概念，原理与使用，本篇主要介绍RxJava的简介。 响应式编程ReactiveX RxJava是ReactiveX中使用Java语言实现的版本，那什么是ReactiveX呢？ReactiveX就是一种新兴的编程模式–响应式编程，定义为一种基于异步数据流概念的编程模式，可分解为”观察者模式+迭代器模式+函数式编程”。 扩展的观察者模式 有关观察者模式的概念不懂得童鞋可自行google，这里就不再赘述。RxJava扩展了观察者模式，通过使用可观察的对象序列流来表述一系列事件，订阅者进行占点观察并对序列流做出反应（或持久化或输出显示等等）；借鉴迭代器模式，对多个对象序列进行迭代输出，订阅者可以依次处理不同的对象序列；使用函数式编程思想，简化繁琐的逻辑代码。 而RxJava的核心便是被观察者Observables与观察者Observer，由Observables发出一系列的事件，Observer通过subscribe()方法进行订阅接收事件并进行处理，类似观察者模式，不同之处在于，若没有观察者，被观察者是不会发出任何事件的。 所以说，RxJava本质上是一个异步操作库，是一个能让你用极其简洁的逻辑去处理繁琐复杂任务的异步事件库。 例子 概念理解起来未免晦涩难懂，我们来看一个例子： 有这样一个需求：开发一个类似房天下的App，某功能需要检索出某一片区所有住宅小区中购房总价&lt;200W的房源并展示出来。先看原始实现方式： 12345678910111213141516171819202122 new Thread(new Runnable() &#123; @Override public void run() &#123; //获取要查询的小区集合 List&lt;Community&gt; communities = getCommunities(); for (Community community : communities) &#123; //获取小区中的房源集合 List&lt;House&gt; houses = community.getHouses(); for (House house : houses) &#123; if (house.getPrice() &lt; 200) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; //显示查询出来的房源信息 ShowSearchedHousesMessage(); &#125; &#125;); &#125; &#125; &#125; &#125;&#125;).start(); RxJava实现方式：123456789101112131415161718192021222324//获取要查询的小区集合List&lt;Community&gt; communities = getCommunities();Observable.from(communities) .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.getHouses()); &#125; &#125;) .filter(new Func1&lt;House, Boolean&gt;() &#123; @Override public Boolean call(House house) &#123; return house.getPrice() &lt; 200; &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; //显示查询出来的房源信息 ShowSearchedHousesMessage(); &#125; &#125;); RxJava的实现方式看上去更复杂了，但是它的逻辑很清晰简洁，修改起来很方便，后期维护起来也能提高工作效率。再来看下配合Lambda表达式：12345678//获取要查询的小区集合List&lt;Community&gt; communities = getCommunities();Observable.from(communities) .flatMap(community -&gt; Observable.from(community.getHouses()) .filter(house -&gt; house.getPrice() &lt; 200) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(house -&gt; ShowSearchedHousesMessage()); 搭配上Lambda表达式，代码的简洁度是不是更上一层楼呢？不懂Lambda表达式的童鞋可以跳转到我写的另一篇讲解Lambda表达式的文章： Android开发之Lambda表达式基本语法与应用 总结 到此，本篇关于RxJava的简介就介绍完毕了，本篇的目的主要是给大家引入一个RxJava的概念，以便后期更轻松的理解RxJava的原理与运作。下一篇我们再来一起详细研究RxJava的原理及如何使用。 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。附上RxJavaDemo的地址： RxJavaDemo","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"http://LeiHolmes.github.io/tags/RxJava/"}]},{"title":"Lambda表达式基本语法与应用","slug":"Lambda表达式基本语法与应用","date":"2017-07-23T16:00:00.000Z","updated":"2017-09-28T08:56:54.000Z","comments":true,"path":"2017/07/24/Lambda表达式基本语法与应用/","link":"","permalink":"http://LeiHolmes.github.io/2017/07/24/Lambda表达式基本语法与应用/","excerpt":"Lambda简介 Lambda表达式是Java8中提供的一种新的特性，它支持Java也能进行简单的“函数式编程”，即Lambda允许你通过表达式来代替功能接口，即可使用更少的代码来实现同样的功能。","text":"Lambda简介 Lambda表达式是Java8中提供的一种新的特性，它支持Java也能进行简单的“函数式编程”，即Lambda允许你通过表达式来代替功能接口，即可使用更少的代码来实现同样的功能。 用官方的解释就是： A lambda expression is a block of code with parameters.(Lambda表达式是一个带有参数的表达式) 添加支持 首先Java版本需要为1.8，然后在build.gradle中添加：1234567891011121314android &#123; …… defaultConfig &#123; …… jackOptions&#123; enabled true &#125; &#125; compileOptions &#123; //升级Android Studio的Language level为1.8 sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125; 语法完整示例1234(int x, int y) -&gt; &#123; Log.i(\"TAG\", \"x:\" + x + \" y:\" + y); return x + y;&#125; 这是一个完整的Lambda表达式的写法，通常由三部分组成： 1. (int x, int y)：Lambda表达式的参数部分，包括参数类型与参数名 2. “-&gt;”：箭头goes to，指向代码块 3. 代码块：用”{}”包裹的代码 忽略参数类型 在大多数情况下，参数的类型系统可根据上下文推断出来。这种情况参数类型就可以忽略不写。1234(x, y) -&gt; &#123; Log.i(\"TAG\", \"x:\" + x + \" y:\" + y); return x + y;&#125; 忽略：”()” 当只有一个参数时，”()”可以忽略不写。1234x -&gt; &#123; Log.i(\"TAG\", \"x:\" + x); return x;&#125; 当没有参数时，”()”不可忽略。1234() -&gt; &#123; Log.i(\"TAG\", \"无参数\"); return 0;&#125; 忽略：”{}” 当代码块只包含一条语句时可忽略”{}”不写。1(x, y) -&gt; return x + y; 忽略return 而return关键字也是可以忽略不写的。1(x, y) -&gt; x + y; 精简到最后只需要一行代码就可以搞定，是不是很方便。 应用无参数+语句/代码块 常规写法：123456new Thread(new Runnable() &#123; @Override public void run() &#123; Log.i(\"TAG\", \"测试无参数+语句/代码块\"); &#125;&#125;).start(); Lambda写法：1new Thread(() -&gt; Log.i(\"TAG\", \"测试无参数+语句/代码块\")).start(); 适用于匿名内部类中方法无参数的情况 有参数+语句 常规写法：123456findViewById(R.id.button).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.i(\"TAG\", \"测试有参数+语句\"); &#125;&#125;); Lambda写法：1findViewById(R.id.button).setOnClickListener(v -&gt; Log.i(\"TAG\", \"测试有参数+语句\")); 适用于匿名内部类中方法只有一个参数的情况 有参数+代码块 常规写法：12345678CheckBox checkBox = (CheckBox) findViewById(R.id.checkBox);checkBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; Log.i(\"TAG\", \"测试有参数+代码块1\"); Log.i(\"TAG\", \"测试有参数+代码块2\"); &#125;&#125;); Lambda写法：1234checkBox.setOnCheckedChangeListener((buttonView, isChecked) -&gt; &#123; Log.i(\"TAG\", \"测试有参数+代码块1\"); Log.i(\"TAG\", \"测试有参数+代码块2\");&#125;); 适用于匿名内部类中方法不止一个参数且执行语句不止一行的情况 总结 Lambda表达式的应用场景很多，例如可与RxJava，Retrofit等进行完美配合，更多的就等待各位码友去实践发掘了。而到此，本篇关于Lambda表达式的详解与应用就讲解完毕了。技术渣一枚，有写的不对的地方欢迎大神们留言指正。","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"Lambda","slug":"Lambda","permalink":"http://LeiHolmes.github.io/tags/Lambda/"}]},{"title":"ORM框架之GreenDao3.0使用详解(二)","slug":"ORM框架之GreenDao3.0使用详解(二)","date":"2017-07-12T16:00:00.000Z","updated":"2017-09-28T08:57:24.000Z","comments":true,"path":"2017/07/13/ORM框架之GreenDao3.0使用详解(二)/","link":"","permalink":"http://LeiHolmes.github.io/2017/07/13/ORM框架之GreenDao3.0使用详解(二)/","excerpt":"本文介绍 上一篇讲解了GreenDao3.0如何集成环境与添加各类注解，这一篇我们来看看如何使用GreenDao实现数据库增删改查的功能，还是上一篇公司Company与雇员Employee的例子。","text":"本文介绍 上一篇讲解了GreenDao3.0如何集成环境与添加各类注解，这一篇我们来看看如何使用GreenDao实现数据库增删改查的功能，还是上一篇公司Company与雇员Employee的例子。 数据库初始化 首先初始化数据库与表，可封装一个工具类，这里献上我的：123456789101112131415161718192021222324public class GreenDaoUtil &#123; private static DaoSession daoSession; private static SQLiteDatabase database; /** * 初始化数据库 * 建议放在Application中执行 */ public static void initDataBase(Context context) &#123; //通过DaoMaster的内部类DevOpenHelper，可得到一个SQLiteOpenHelper对象。 DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper (context, \"greendaoutil.db\", null); //数据库名称 database = devOpenHelper.getWritableDatabase(); DaoMaster daoMaster = new DaoMaster(database); daoSession = daoMaster.newSession(); &#125; public static DaoSession getDaoSession() &#123; return daoSession; &#125; public static SQLiteDatabase getDatabase() &#123; return database; &#125;&#125; 然后在Application中调用。1234567public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); GreenDaoUtil.initDataBase(getApplicationContext()); &#125;&#125; 插入 插入公司与雇员的假数据：123456789101112131415161718192021222324//获取实体DaoCompanyDao companyDao = GreenDaoUtil.getDaoSession().getCompanyDao();EmployeeDao employeeDao = GreenDaoUtil.getDaoSession().getEmployeeDao();//插入公司Company company1 = new Company();company1.setId(null);company1.setCompanyName(\"Netease\");company1.setIndustry(\"news\");Company company2 = new Company();company2.setId(null);company2.setCompanyName(\"Tencent\");company2.setIndustry(\"chat\");companyDao.insert(company1);companyDao.insert(company2);//插入不同公司的雇员for (int i = 0; i &lt; 5; i++) &#123; Employee employee = new Employee(null, company1.getId(), \"Sherlock\" + i, 11000 + i * 1000); employeeDao.insert(employee);&#125;for (int i = 0; i &lt; 5; i++) &#123; Employee employee = new Employee(null, company2.getId(), \"Richard\" + i, 8000 + i * 1000); employeeDao.insert(employee);&#125; 注意：设置setId(null)，GreenDao会自动分配自增Id。 查询 由于删除与更新基本都需要先进行查询，所以咱们来看看如何进行查询： QueryBuilder 举例：查询Tencent公司中薪水大于等于10000的职员。123456789//查询Company表中名为Tencent的公司Company company = companyDao.queryBuilder().where(CompanyDao.Properties.CompanyName.eq(\"Tencent\")).unique();//查询Employee表中属于Tencent公司且薪水水大于等于10000的EmployeeList&lt;Employee&gt; employeeList = employeeDao.queryBuilder().where(EmployeeDao.Properties.CompanyId.eq(company.getId()), EmployeeDao.Properties.Salary.ge(10000)).list(); 注意：如果查询调用.unique()的话，需注意本次查询的结果必须唯一，否则会报错。where中为查询条件，支持多条件查询以” , “隔开。 Query 使用Query可进行重复查询，更改查询条件参数即可，还是上面的例子。12345678910111213//查询Company表中名为Tencent的公司Company company = companyDao.queryBuilder().where(CompanyDao.Properties.CompanyName.eq(\"Tencent\")).unique();//查询Employee表中属于Tencent公司且薪水水大于等于10000的EmployeeQuery query = employeeDao.queryBuilder().where(EmployeeDao.Properties.CompanyId.eq(company.getId()), EmployeeDao.Properties.Salary.ge(10000)).build();//修改查询条件参数query.setParameter(0, company.getId());query.setParameter(1, 11000);List&lt;Employee&gt; employeeList = query.list(); load(Long key) 根据主键查询一条记录1Company company = companyDao.load(1l); loadAll() 查询表中所有记录12List&lt;Company&gt; companyList = companyDao.loadAll();List&lt;Employee&gt; employeeList = employeeDao.loadAll(); 原声sql查询 推荐通过QueryBuilder和WhereCondition.StringCondition来实现原声sql查询。123Query query = companyDao.queryBuilder().where( new StringCondition(\"_ID IN \" + \"(SELECT USER_ID FROM USER_MESSAGE WHERE READ_FLAG = 0)\")).build(); 也可使用queryRaw()或queryRawCreate()方法来实现。 多线程查询 如果数据量过大，对于数据库查询的操作是很耗时的，所以需要开启新的线程进行查询。123456789private void queryThread() &#123; final Query query = employeeDao.queryBuilder().build(); new Thread()&#123; @Override public void run() &#123; List list = query.forCurrentThread().list(); &#125; &#125;.start();&#125; 查询条件判断eq,noteq与like查询 eq判断值是否相等，通常用来具体查找，返回一条指定类型数据。 noteq与eq相反，判断值是否不等，通常用来模糊查找，返回指定类型的集合。 like相当于通配符查询，包含查询值的实体都会返回，同样模糊查找，返回指定类型的集合。 &gt;、&lt;、&gt;=、&lt;=查询 分别对应方法： &gt;: gt() &lt;: lt() &gt;=: ge() &lt;=: le() isNull与isNotNull 为空与不为空，判断数据库中有无数据。 排序 对查询结果进行排序，有升序与降序。1234List&lt;Employee&gt; employeeList = employeeDao.queryBuilder().where(EmployeeDao.Properties.CompanyId.eq(company.getId())).orderAsc(EmployeeDao.Properties.Salary).list(); 上例中的.orderAsc(EmployeeDao.Properties.Salary)就是对查询出来的Employee按工资进行升序排序。同理降序为.orderDesc(EmployeeDao.Properties.Salary)。 删除 删除主要有三种方式： deleteBykey(Long key) 根据key进行删除。举例：删除Tencent公司中薪水小于10000的人，需先查询出Employee表中属于Tencent公司且薪水小于10000的Employee实体，再进行删除。123456789101112131415161718192021//查询Company表中名为Tencent的公司Company companyTencent = companyDao.queryBuilder().where(CompanyDao.Properties.CompanyName.eq(\"Tencent\")).unique();if (companyTencent != null) &#123; //查询Employee表中属于Tencent公司且薪水小于10000的Employee List&lt;Employee&gt; employeeList = employeeDao.queryBuilder() .where(EmployeeDao.Properties.CompanyId.eq(companyTencent.getId()), EmployeeDao.Properties.Salary.lt(10000)) .list(); if (employeeList != null) &#123; for (Employee employee : employeeList) &#123; //进行删除 employeeDao.deleteByKey(employee.getId()); &#125; &#125; else &#123; Log.e(\"greendao_test\", \"delete:deleteList为空\"); &#125;&#125; else &#123; Log.e(\"greendao_test\", \"delete:company为空\");&#125; delete(Employee entity) 根据实体进行删除。举例：删除名为Tencent的公司。12345//查询Company表中名为Tencent的公司Company companyTencent = companyDao.queryBuilder().where(CompanyDao.Properties.CompanyName.eq(\"Tencent\")).unique();companyDao.delete(companyTencent); deleteAll() 若需删除表中所有实体，则调用此方法。举例：删除所有雇员。1employeeDao.deleteAll(); 更新 若需对某个已存入数据库实体的属性进行修改，则需进行update操作。举例：修改Netease公司中薪水小于等于13000人的名字1234567891011121314151617181920212223//查询Company表中名为Netease的公司Company companyNetease = companyDao.queryBuilder().where(CompanyDao.Properties.CompanyName.eq(\"Netease\")).unique();if (companyNetease != null) &#123; //查询Employee表中查询Employee表中属于Netease公司且薪水小于等于13000人的Employee List&lt;Employee&gt; employeeList = employeeDao.queryBuilder() .where(EmployeeDao.Properties.CompanyId.eq(companyNetease.getId()), EmployeeDao.Properties.Salary.le(13000)) .list(); if (employeeList != null) &#123; for (Employee employee : employeeList) &#123; //修改属性 employee.setEmployeeName(\"baozi\"); //进行更新 employeeDao.update(employee); &#125; &#125; else &#123; Log.e(\"greendao_test\", \"update:updateList为空\"); &#125;&#125; else &#123; Log.e(\"greendao_test\", \"update:company为空\");&#125; 总结 到此，这一篇关于GreenDao3.0的使用就讲解完毕了，可结合上一篇集成与注解详解一起看。 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者不懂的地方也可以在我Github上GreenDaoDemo项目的Issues中提出，我会及时解答。附上GreenDaoDemo的地址： GreenDaoDemo","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"GreenDao","slug":"GreenDao","permalink":"http://LeiHolmes.github.io/tags/GreenDao/"}]},{"title":"ORM框架之GreenDao3.0集成与注解(一)","slug":"ORM框架之GreenDao3.0集成与注解(一)","date":"2017-07-09T16:00:00.000Z","updated":"2017-09-28T08:57:13.000Z","comments":true,"path":"2017/07/10/ORM框架之GreenDao3.0集成与注解(一)/","link":"","permalink":"http://LeiHolmes.github.io/2017/07/10/ORM框架之GreenDao3.0集成与注解(一)/","excerpt":"GreenDao简介 GreenDao是一个将对象映射到SQLite数据库中的轻量且快速的ORM数据库框架，本文将讲解如何集成GreenDao3.0环境，如何使用GreenDao自动生成代码及注解的使用。","text":"GreenDao简介 GreenDao是一个将对象映射到SQLite数据库中的轻量且快速的ORM数据库框架，本文将讲解如何集成GreenDao3.0环境，如何使用GreenDao自动生成代码及注解的使用。 GreenDao官网 GreenDao GitHub GreenDao3.0优势 GreenDao相较于ORMLite等其他数据库框架有以下优势： 1. 一个精简的库 2. 性能最大化 3. 内存开销最小化 4. 易于使用的 APIs 5. 对 Android 进行高度优化 而GreenDao3.0的版本主要使用注解方式定义实体类，通过gradle插件生成相应的代码。相较于3.0之前的版本集成步骤更为便捷，使用起来也更为简单。本文使用的版本为3.2.0。 集成项目下build.gradle GitHub中提示添加maven仓库，但是AndroidStudio项目已经默认包含了jcenter仓库，而jcenter仓库就是maven仓库的一个分支，因此不需要再添加仓库，直接添加classPath即可。123456789buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.2' classpath 'org.greenrobot:greendao-gradle-plugin:3.2.1' &#125;&#125; app下build.gradle 在app下build.gradle文件中我们需要声明GreenDao插件，及配置GreenDao生成dao路径等信息，声明GreenDao依赖。12345678910111213141516apply plugin: 'org.greenrobot.greendao'......greendao &#123; schemaVersion 1 //数据库版本号 daoPackage 'com.holmeslei.greendaodemo.database' //设置时生成代码的目录 targetGenDir 'src/main/java' //设置DaoMaster、DaoSession、Dao目录 //targetGenDirTest：设置生成单元测试目录 //generateTests：设置自动生成单元测试用例&#125;dependencies &#123; ...... compile 'org.greenrobot:greendao:3.2.0'&#125; 初始化实体编写实体类 集成好使用环境后需要初始化实体，首先编写实体类。这里演示使用公司Company与雇员Employer实体例子。使用@Entity注解。莫急，注解机制在之后小节有详细讲解。123456789@Entitypublic class Company &#123; @Id(autoincrement = true) //自增 private Long id; //主键 private String companyName; //公司名称 private String industry; //行业 @ToMany(referencedJoinProperty = \"companyId\") //设置外键companyId private List&lt;Employee&gt; employeeList; //公司与雇员建立一对多关系&#125; 12345678@Entitypublic class Employee &#123; @Id(autoincrement = true) private Long id; //主键 private long companyId; //指向Company主键 private String employeeName; //雇员姓名 private int salary; //薪水&#125; 生成代码 实体类与注解添加完毕后编译项目，就会为所有带注解的实体生成Dao文件，及DaoMaster与DaoSession。若未在build.gradle中配置过则默认生成目录为build/generated/source。若配置过则生成在配置的目录下。 编译项目 生成代码 注解 3.0之后最大的不同就是使用的注解来配置实体类属性，便捷且灵活。下面来看一下各类注解： 实体类注解123456789101112@Entity( schema = \"myschema\", active = true, nameInDb = \"AWESOME_USERS\", indexes = &#123; @Index(value = \"name DESC\", unique = true) &#125;, createInDb = false)public class Company &#123; ......&#125; @Entity：用于标识当前实体需要GreenDao生成代码。 schema：项目中存在多个Schema时，表明当前实体属于哪个Schema。 active：标记实体是否处于活动状态，活动状态才支持更新删除刷新等操作。 nameInDb：存储在数据库中的表名，不写默认与类名一致。 indexes：定义索引，可跨越多个列。 createInDb：标记创建数据库表，若有多个实体关联此表可设为false避免重复创建，默认为true。 属性注解 @Id :主键Long型，可以通过@Id(autoincrement = true)设置自增长。 @Property：设置一个非默认关系映射所对应的列名，默认是的使用字段名例如@Property (nameInDb=&quot;name&quot;)。 @NotNul：设置数据库表当前列不能为空。 @OrderBy：指定排序。 @Transient：添加此标记之后不会生成数据库表的列。 @Generated：为build之后GreenDao自动生成的注解，为防止重复，每一块代码生成后会加个hash作为标记。 索引注解123456789101112131415@Entitypublic class Company &#123; @Id(autoincrement = true) private Long id; @Index(unique = true) private String industry;&#125; @Entitypublic class Employee &#123; @Id(autoincrement = true) private Long id; @Unique private String employeeName;&#125; @Index：创建索引，通过设置name设置别名，设置unique添加约束。 @Unique：添加唯一约束与(unique = true)作用相同。 关系注解 @ToOne：定义与另一实体一对一的关联。 123456789101112131415@Entitypublic class Company &#123; @Id (autoincrement = true) private Long id; private long customerId; @ToOne(joinProperty = \"employeeId\") private Employee employee;&#125; @Entitypublic class Employee &#123; @Id(autoincrement = true) private Long id; private String employeeName;&#125; @ToMany：定义与多个实体对象一对多的关联，referencedJoinProperty为外键约束。 @JoinProperty：标明目标属性的源属性。 @JoinEntity：建立表连接关系。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//第一种：Employee实体通过外键companyId指向Company实体的主键Id建立一对多关联@Entitypublic class Company &#123; @Id(autoincrement = true) private Long id; private String companyName; private String industry; @ToMany(referencedJoinProperty = \"companyId\") private List&lt;Employee&gt; employeeList;&#125; @Entitypublic class Employee &#123; @Id(autoincrement = true) private Long id; private long companyId; private String employeeName; private int salary;&#125;//第二种：Employee以companyId为外键，与Company非主键不为空的键employeeTag建立一对多关联。@Entitypublic class Company &#123; @Id(autoincrement = true) private Long id; private String companyName; private String industry; @ToMany(joinProperties = &#123; @JoinProperty(name = \"employeeTag\", referencedName = \"companyId\") &#125;) private List&lt;Employee&gt; employeeList;&#125; @Entitypublic class Employee &#123; @Id(autoincrement = true) private Long id; private String employeeName; private int salary; @NotNull private String companyId;&#125; //第三种：通过第三者实体类建立关联，用的较少@Entitypublic class Employee &#123; @Id(autoincrement = true) private Long id; private String employeeName; private int salary; @ToMany @JoinEntity( entity = JoinEmployeeToCompany.class, sourceProperty = \"employeeId\", targetProperty = \"companyId\" ) private List&lt;Company&gt; companyList;&#125; @Entitypublic class JoinEmployeeToCompany &#123; @Id(autoincrement = true) private Long id; private Long employeeId; private Long companyId;&#125; @Entitypublic class Company &#123; @Id(autoincrement = true) private Long id; private String companyName; private String industry; &#125; 总结 到此，这一篇关于GreenDao3.0的集成与注解就讲解完毕了，欢迎参看下一篇关于如何使用GreenDao3.0对数据库进行增删改查。 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者不懂的地方也可以在我Github上GreenDaoDemo项目的Issues中提出，我会及时解答。附上GreenDaoDemo的地址： GreenDaoDemo","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"GreenDao","slug":"GreenDao","permalink":"http://LeiHolmes.github.io/tags/GreenDao/"}]},{"title":"DataBinding数据绑定基本讲解","slug":"DataBinding数据绑定基本讲解","date":"2017-05-14T16:00:00.000Z","updated":"2017-09-28T08:56:44.000Z","comments":true,"path":"2017/05/15/DataBinding数据绑定基本讲解/","link":"","permalink":"http://LeiHolmes.github.io/2017/05/15/DataBinding数据绑定基本讲解/","excerpt":"DataBinding简介 DataBinding是基于MVVM思想实现数据与UI绑定的框架，有了Data Binding，在Android中也可以很方便的实现MVVM。它于2015年7月由Google在Studio1.3上引入，2016年4月在Studio2.0上得到正式支持。DataBinding是一个support库，最低支持到Android2.1（API Level 7+）。","text":"DataBinding简介 DataBinding是基于MVVM思想实现数据与UI绑定的框架，有了Data Binding，在Android中也可以很方便的实现MVVM。它于2015年7月由Google在Studio1.3上引入，2016年4月在Studio2.0上得到正式支持。DataBinding是一个support库，最低支持到Android2.1（API Level 7+）。 在引入DataBinding之前，我们需要敲很多很鸡肋的代码，如 findViewById()、setText()，setVisibility()，setEnabled() 或 setOnClickListener() 等，通过 DataBinding , 我们可以通过声明式布局以精简的代码来绑定应用程序逻辑和布局，这样就不用编写大量的冗余的代码了。这一节我们来讲一讲DataBinding的基本实现之常量绑定、变量绑定与事件绑定。 初始化在build.gradle中添加123456android &#123; dataBinding &#123; enabled = true; &#125; ......&#125; 在xml文件最外层结构添加1234&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\"&gt; ......&lt;/layout&gt; 即是将最外层标签改为&lt;layout&gt;&lt;/layout&gt; 替换原setContentView方法1ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main); 命名规则：这里的ActivityMainBinding命名由来是其layout名称转换为驼峰形式再加上”Binding得到”。例如activity_main-&gt;ActivityMainBinding。 开始绑定常量绑定 在xml中：1234&lt;TextView android:id=\"@+id/text_view1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; 在Activity中：1binding.textView1.setText(\"Helloworld\"); 命名规则：控件id带下划线时，调用时使用其id的驼峰命名形式 。不带下划线时，调用时与id一致。例如id为text_view1，调用时使用binding.textView1。 变量绑定 首先创建一个简单的数据来源类MyBean：123456789101112131415161718192021222324252627package com.sherlock.databindingdemo;public class MyBean &#123; private String name; private int age; public MyBean(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 然后在xml文件layout标签下添加：123456&lt;data&gt; &lt;variable name=\"mybean\" type=\"com.sherlock.databindingdemo.MyBean\" /&gt; &lt;/data&gt;&lt;!--name：提供数据的bean的别名；type：bean的类名--&gt; 在控件中设置变量绑定：123456&lt;TextView android:id=\"@+id/text_view1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginRight=\"10dp\" android:text=\"@&#123;mybean.name&#125;\"/&gt; 在Activity中设置数据：12binding.setMybean(myBean);//binding.setVariable(BR.mybean,myBean); //另一种方法 注意：@{mybean.name}中的name必须为String类型，若要绑定别的类型，比如int类型，可以这样@{String.valueOf(mybean.age)}。 事件绑定 当然我们也可以用DataBinding实现事件绑定，它有两种实现方式。 第一种：首先添加一个事件回调类Presenter，这里演示Click与TextChange事件:123456789public class Presenter &#123; public void onTextChanged(CharSequence s, int start, int before, int count) &#123; myBean.setName(s.toString()); binding.setMybean(myBean); &#125; public void onClick(View view)&#123; Toast.makeText(MainActivity.this, \"点击成功\", Toast.LENGTH_SHORT).show(); &#125;&#125; 注意：使用这种事件绑定方式，Presenter中的方法需和控件监听方法完全一致。 在xml中：1234567891011121314151617&lt;data&gt; &lt;variable name=\"presenter\" type=\"com.sherlock.databindingdemo.MainActivity.Presenter\" /&gt;&lt;/data&gt;&lt;EditText android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:onTextChanged=\"@&#123;presenter.onTextChanged&#125;\" /&gt; &lt;!--或者@&#123;presenter::onTextChanged&#125;--&gt;&lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"@&#123;presenter.onClick&#125;\" /&gt; &lt;!--或者@&#123;presenter::onClick&#125;--&gt; 在Activity中：1binding.setPresenter(new Presenter()); 第二种：也可以设置自定义的监听器Binding，可回传参数，需要使用Lambda表达式： 在xml中：12345&lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"@&#123;() -&gt; presenter.onButtonClick(mybean)&#125;\" /&gt; &lt;!--或者@&#123;(view) -&gt; presenter.onButtonClick(mybean)&#125;--&gt; 在Presenter中：123public void onButtonClick(MyBean myBean)&#123; Toast.makeText(MainActivity.this, myBean.getName(), Toast.LENGTH_SHORT).show();&#125; 注意：使用这种事件绑定，Presenter中的监听方法就不需要与View的监听方法完全一致了，而且可以获取View在事件中回传的数据。 总结 这一节到此DataBinding的常量，变量，事件绑定的用法就讲解完毕了，实际操作起来感觉目前AndroidStudio对DataBinding的支持还不够，排错有点费劲，有时会出现找不到DataBinding的错误，这时应先查看下是否由于自己修改了某个类名，而xml调用时没有修改导致。若没有问题则删除app下的build文件夹重新Rebuild下项目试试。 首次接触DataBinding，可能有写的不对的地方欢迎大神们留言指正，有什么疑惑或者不懂的地方也可以在我Github上DataBindingDemo项目的Issues中提出，我会及时解答。附上DataBindingDemo地址： DataBindingDemo","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"DataBinding","slug":"DataBinding","permalink":"http://LeiHolmes.github.io/tags/DataBinding/"}]},{"title":"Material Design之RecyclerView基本讲解与瀑布流的实现","slug":"Material Design之RecyclerView基本讲解与瀑布流的实现","date":"2017-03-27T16:00:00.000Z","updated":"2017-09-28T08:57:03.000Z","comments":true,"path":"2017/03/28/Material Design之RecyclerView基本讲解与瀑布流的实现/","link":"","permalink":"http://LeiHolmes.github.io/2017/03/28/Material Design之RecyclerView基本讲解与瀑布流的实现/","excerpt":"RecyclerView简介 RecyclerView是一种新的视图组，目标是为任何基于适配器的视图提供相似的渲染方式。它被作为ListView和GridView控件的继承者，具有更优的灵活性与可替代性。在最新的support-v7版本中提供支持。本文将讲解RecyclerView的简单实现，添加删除条目，点击事件添加与瀑布流的实现。","text":"RecyclerView简介 RecyclerView是一种新的视图组，目标是为任何基于适配器的视图提供相似的渲染方式。它被作为ListView和GridView控件的继承者，具有更优的灵活性与可替代性。在最新的support-v7版本中提供支持。本文将讲解RecyclerView的简单实现，添加删除条目，点击事件添加与瀑布流的实现。 相关原理与简单实现添加依赖 在AndroidStudio的build.gradle中添加依赖： dependencies { ... compile &#39;com.android.support:recyclerview-v7:25.3.0&#39; } 在布局中使用 添加完依赖后就可以在布局中使用RecyclerView了： &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/main_recyclerview\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; RecyclerView.Adapter RecyclerView封装了一种新型的适配器，与现在使用的适配器大同小异。它强制用户使用RecyclerView提供的ViewHolder，使用时主要需要重写onCreateViewHolder与onBindViewHolder方法。前者用来展现视图及其持有者，且只有真正需要一个新view时才会被回调，不需要检查是否已经被回收。后者用来绑定数据到View上。 import android.content.Context; import android.support.v7.widget.RecyclerView; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; import java.util.List; public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; { private Context context; private List&lt;String&gt; list; private LayoutInflater inflater; public MyAdapter(Context context, List&lt;String&gt; list) { this.context = context; this.list = list; inflater = LayoutInflater.from(context); } @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = inflater.inflate(R.layout.item_recyclerview, parent, false); MyViewHolder holder = new MyViewHolder(view); return holder; } @Override public void onBindViewHolder(MyViewHolder holder, int position) { holder.textView.setText(list.get(position)); } @Override public int getItemCount() { return list.size(); } class MyViewHolder extends RecyclerView.ViewHolder { TextView textView; public MyViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.item_textview); } } } LayoutManager RecyclerView通过布局管理器LayoutManager控制每一个item如何进行排列摆放，何时展示和隐藏。回收或重用一个View时LayoutManager会向适配器请求新的数据来替换旧的数据，这种机制避免了创建过多的View和频繁的调用findViewById方法，目前其自带的主要有以下三种： - LinearLayoutManager：ListView样式 - GridLayoutManager：GridView样式 - StaggeredGridLayoutManager：瀑布流样式 ItemDecoration RecyclerView并不能像ListView一样直接在xml布局中修改item分割线样式。需要在Activity动态设置，当然更推荐在单个条目布局中设置margin或者padding来实现分割线效果，这里提供一个分割线。 import android.content.Context; import android.content.res.TypedArray; import android.graphics.Canvas; import android.graphics.Rect; import android.graphics.drawable.Drawable; import android.support.v7.widget.LinearLayoutManager; import android.support.v7.widget.RecyclerView; import android.view.View; public class DividerItemDecoration extends RecyclerView.ItemDecoration { private static final int[] ATTRS = new int[]{ android.R.attr.listDivider }; public static final int HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL; public static final int VERTICAL_LIST = LinearLayoutManager.VERTICAL; private Drawable mDivider; private int mOrientation; public DividerItemDecoration(Context context, int orientation) { final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); a.recycle(); setOrientation(orientation); } public void setOrientation(int orientation) { if (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) { throw new IllegalArgumentException(\"invalid orientation\"); } mOrientation = orientation; } @Override public void onDraw(Canvas c, RecyclerView parent) { if (mOrientation == VERTICAL_LIST) { drawVertical(c, parent); } else { drawHorizontal(c, parent); } } public void drawVertical(Canvas c, RecyclerView parent) { final int left = parent.getPaddingLeft(); final int right = parent.getWidth() - parent.getPaddingRight(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int top = child.getBottom() + params.bottomMargin; final int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); } } public void drawHorizontal(Canvas c, RecyclerView parent) { final int top = parent.getPaddingTop(); final int bottom = parent.getHeight() - parent.getPaddingBottom(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int left = child.getRight() + params.rightMargin; final int right = left + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); } } @Override public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) { if (mOrientation == VERTICAL_LIST) { outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); } else { outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); } } } ItemAnimator ItemAnimator会根据适配器上收到的通知来动画显示视图组的修改，比如item的添加与删除。DefaultItemAnimator已经能很好的展现动画效果了。 RecyclerView初始化 若想初始化一个RecyclerView使其进入工作状态，你需要在Activity中做以下的操作： RecyclerView recyclerView = (RecyclerView)findViewById(R.id.recycler_view_main); MyAdapter adapter = new MyAdapter(this, list); //设置RecyclerView保持固定的大小 recyclerView.setHasFixedSize(true); //设置适配器 recyclerView.setAdapter(adapter); //设置RecyclerView ListView样式布局管理 recyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)); //设置RecyclerView的Item分割线 recyclerView.addItemDecoration(new DividerItemDecoration(this, DividerItemDecoration.VERTICAL_LIST)); //设置RecyclerView的动画 recyclerView.setItemAnimator(new DefaultItemAnimator()); //设置RecyclerView GridView样式 //recyclerView.setLayoutManager(new GridLayoutManager(MainActivity.this, 3)); //设置RecyclerView 水平GridView样式 //recyclerView.setLayoutManager(new StaggeredGridLayoutManager(5, StaggeredGridLayoutManager.HORIZONTAL)); //设置RecyclerView 瀑布流样式 //recyclerView.setLayoutManager(new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL)); 点击事件与添加删除Item 美中不足的是RecyclerView并没有提供像ListView一样的Item点击与Item长点击事件，不提供咱们就自己造，通过接口回调来实现。 Adapter中import android.content.Context; import android.support.v7.widget.RecyclerView; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; import java.util.ArrayList; public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; { private Context context; private LayoutInflater inflater; protected ArrayList&lt;String&gt; datas; private onItemClickedListener onItemClickedListener; public MyAdapter(Context context, ArrayList&lt;String&gt; datas) { this.context = context; this.datas = datas; inflater = LayoutInflater.from(context); } public void setOnItemClickedListener(MyAdapter.onItemClickedListener onItemClickedListener) { this.onItemClickedListener = onItemClickedListener; } @Override public void onBindViewHolder(MyViewHolder holder, int position) { holder.textView.setText(datas.get(position)); } @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = inflater.inflate(R.layout.item_recycler_view, parent, false); MyViewHolder myViewHolder = new MyViewHolder(view); return myViewHolder; } @Override public int getItemCount() { return datas.size(); } /** * 添加条目 */ public void addItem(int position) { datas.add(position, \"xulei\"); // notifyDataSetChanged(); notifyItemInserted(position);//调用这个才有动画效果 } /** * 移除条目 */ public void removeItem(int position) { datas.remove(position); notifyItemRemoved(position); } class MyViewHolder extends RecyclerView.ViewHolder { TextView textView; public MyViewHolder(View itemView) { super(itemView); //初始化控件 textView = (TextView) itemView.findViewById(R.id.item_textview); //设置当前条目单击监听 itemView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { if (onItemClickedListener != null) onItemClickedListener.onClick(view, getAdapterPosition());//可立刻获取到当前position // onItemClickedListener.onClick(view, getLayoutPosition());//需等当前视图更新完才能获取到当前position，&lt;16ms。 } }); //设置当前条目长按监听 itemView.setOnLongClickListener(new View.OnLongClickListener() { @Override public boolean onLongClick(View view) { if (onItemClickedListener != null) onItemClickedListener.onLongClick(view, getAdapterPosition()); return false; } }); } } /** * 点击回调的接口 */ interface onItemClickedListener { void onClick(View view, int position); void onLongClick(View view, int position); } } Activity中 在Activity中实例化Adapter之后添加如下代码： adapter.setOnItemClickedListener(new MyAdapter.onItemClickedListener() { @Override public void onClick(View view, int position) { adapter.addItem(position); Toast.makeText(MainActivity.this, \"点击click:\" + position, Toast.LENGTH_SHORT).show(); } @Override public void onLongClick(View view, int position) { adapter.removeItem(position); Toast.makeText(MainActivity.this, \"长按click:\" + position, Toast.LENGTH_SHORT).show(); } }); 瀑布流的实现 想实现瀑布流的样式通过使用RecyclerView也很容易就能实现。 首先在Activity中设置LayoutManager时选择：recyclerView.setLayoutManager(new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL)); 修改Adapter 瀑布流自然是每个条目的高度不同才能出现瀑布的效果（水平布局则是宽度不同），那么只需在每个条目绑定数据时动态改变下其高度即可，贴出瀑布流Adapter代码： import android.content.Context; import android.view.ViewGroup; import java.util.ArrayList; import java.util.List; public class StaggerAdapter extends MyAdapter { private List&lt;Integer&gt; heights; public StaggerAdapter(Context context, ArrayList&lt;String&gt; datas) { super(context, datas); heights = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; datas.size(); i++) { heights.add((int) (100 + Math.random() * 300)); } } @Override public void onBindViewHolder(MyViewHolder holder, int position) { ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams(); layoutParams.height = heights.get(position); // layoutParams.width = heights.get(position); holder.itemView.setLayoutParams(layoutParams); holder.textView.setText(datas.get(position)); } } 总结 通过实践发现RecyclerView相较于ListView与GridView确实强大很多，更加的灵活与方便，提高了开发效率。但也有不足之处，如并未封装点击事件的回调，确实是比较头疼。期待Google的完善。附上GitHub源码：RecyclerViewDemoRecyclerViewDevelop","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://LeiHolmes.github.io/tags/RecyclerView/"}]},{"title":"AlarmManager+Notification实现定时通知提醒功能","slug":"AlarmManager+Notification实现定时通知提醒功能","date":"2016-12-12T16:00:00.000Z","updated":"2017-09-28T08:56:16.000Z","comments":true,"path":"2016/12/13/AlarmManager+Notification实现定时通知提醒功能/","link":"","permalink":"http://LeiHolmes.github.io/2016/12/13/AlarmManager+Notification实现定时通知提醒功能/","excerpt":"AlarmManager简介 AlarmManager实质是一个全局的定时器，是Android中常用的一种系统级别的提示服务，在指定时间或周期性启动其它组件（包括Activity,Service,BroadcastReceiver）。本文将讲解一下如何使用AlarmManager实现定时提醒功能。","text":"AlarmManager简介 AlarmManager实质是一个全局的定时器，是Android中常用的一种系统级别的提示服务，在指定时间或周期性启动其它组件（包括Activity,Service,BroadcastReceiver）。本文将讲解一下如何使用AlarmManager实现定时提醒功能。 闹钟配置周期闹钟12345Intent intent = new Intent();intent.setAction(GlobalValues.TIMER_ACTION_REPEATING);PendingIntent sender = PendingIntent.getBroadcast(context, 0, intent, 0);AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);alarm.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + 5 * 1000, 3 * 1000, sender); 1setRepeating(int type,long startTime,long intervalTime,PendingIntent pi) 该方法用于设置周期性执行的定时服务。type：闹钟类型，startTime：闹钟首次执行时间，intervalTime：闹钟两次执行的间隔时间，pi：闹钟响应动作。1setInexactRepeating(int type,long startTime,long intervalTime,PendingIntent pi) 该方法也用于设置周期定式服务，与上一种类似。不过其两个闹钟执行的间隔时间不是固定的。它相对而言更省电一些，因为系统可能会将几个差不多的闹钟合并为一个来执行，减少设备的唤醒次数。 intervalTime内置变量间隔一天： INTERVAL_DAY间隔半天： INTERVAL_HALF_DAY间隔15分钟： INTERVAL_FIFTEEN_MINUTES间隔半个小时： INTERVAL_HALF_HOUR间隔一个小时： INTERVAL_HOUR 定时闹钟123456789//获得系统提供的AlarmManager服务的对象AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);//Intent设置要启动的组件，这里启动广播Intent myIntent = new Intent();myIntent.setAction(GlobalValues.TIMER_ACTION);//PendingIntent对象设置动作,启动的是Activity还是Service,或广播!PendingIntent sender = PendingIntent.getBroadcast(context, 0, myIntent,0);//注册闹钟alarm.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + 5 * 1000, sender); 1set(int type,long startTime,PendingIntent pi) 该方法用于设置一次性定时服务。type：闹钟类型，startTime：闹钟执行时间，pi：闹钟响应动作。 取消闹钟123456Intent myIntent = new Intent();myIntent.setAction(GlobalValues.TIMER_ACTION);//myIntent.setAction(GlobalValues.TIMER_ACTION_REPEATING);PendingIntent sender = PendingIntent.getBroadcast(context, 0, myIntent,0);AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);alarm.cancel(sender); 设置多个闹钟： 若连续设置多个闹钟，则只有最后一个闹钟会生效，那么这种情况我们怎么处理呢？其实很简单。我们可以给每个闹钟设置唯一的id，传入getBroadcast()第二个参数。在这里我是每设置一个id则自增1存入Shareprefrence里，保证id唯一性。1234 //给每个闹钟设置不同ID防止覆盖int alarmId = SharedPreUtils.getInteger(context, \"alarm_id\", 0);SharedPreUtils.setInteger(context, \"alarm_id\", ++alarmId);PendingIntent sender = PendingIntent.getBroadcast(context, alarmId, myIntent, 0); 在取消闹钟时我们也可以根据这个id关闭不同的闹钟。 参数详解type：闹钟类型ELAPSED_REALTIME： 在指定的延时过后，发送广播，但不唤醒设备（闹钟在睡眠状态下不可用）。如果在系统休眠时闹钟触发，它将不会被传递，直到下一次设备唤醒。ELAPSED_REALTIME_WAKEUP： 在指定的延时过后，发送广播，并唤醒设备（即使关机也会执行operation所对应的组件） 。延时是要把系统启动的时间SystemClock.elapsedRealtime()算进去的。RTC： 指定当系统调用System.currentTimeMillis()方法返回的值与triggerAtTime相等时启动operation所对应的设备（在指定的时刻，发送广播，但不唤醒设备）。如果在系统休眠时闹钟触发，它将不会被传递，直到下一次设备唤醒（闹钟在睡眠状态下不可用）。RTC_WAKEUP： 指定当系统调用System.currentTimeMillis()方法返回的值与triggerAtTime相等时启动operation所对应的设备（在指定的时刻，发送广播，并唤醒设备）。即使系统关机也会执行operation所对应的组件。POWER_OFF_WAKEUP： 表示闹钟在手机关机状态下也能正常进行提示功能，所以是5个状态中用的最多的状态之一，该状态下闹钟也是用绝对时间，状态值为4；不过本状态好像受SDK版本影响，某些版本并不支持。 long intervalTime：执行时间 闹钟的第一次执行时间，以毫秒为单位，可以自定义时间，不过一般使用当前时间。需要注意的是，本属性与第一个属性（type）密切相关，如果第一个参数对应的闹钟使用的是相对时间（ELAPSED_REALTIME和ELAPSED_REALTIME_WAKEUP），那么本属性就得使用相对时间（相对于系统启动时间来说），比如当前时间就表示为：SystemClock.elapsedRealtime();如果第一个参数对应的闹钟使用的是绝对时间（RTC、RTC_WAKEUP、POWER_OFF_WAKEUP），那么本属性就得使用绝对时间，比如当前时间就表示为：System.currentTimeMillis() long startTime：间隔时间 对于周期定时方式来说，存在本属性，表示两次闹钟执行的间隔时间，也是以毫秒为单位。 PendingIntent pi：执行动作 是闹钟的执行动作，比如发送一个广播、给出提示等等。PendingIntent是Intent的封装类。需要注意的是，如果是通过启动服务来实现闹钟提示的话，PendingIntent对象的获取就应该采用Pending.getService(Context c,int i,Intent intent,int j)方法；如果是通过广播来实现闹钟提示的话，PendingIntent对象的获取就应该采用PendingIntent.getBroadcast(Context c,int i,Intent intent,int j)方法；如果是采用Activity的方式来实现闹钟提示的话，PendingIntent对象的获取就应该采用PendingIntent.getActivity(Context c,int i,Intent intent,int j)方法。如果这三种方法错用了的话，虽然不会报错，但是看不到闹钟提示效果。。 广播配置新建闹钟BroadCastReceiver：1234567891011121314151617181920212223242526272829public class AlarmReceiver extends BroadcastReceiver &#123; private NotificationManager m_notificationMgr = null; private static final int NOTIFICATION_FLAG = 3; @Override public void onReceive(Context context, Intent intent) &#123; m_notificationMgr = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVIC if (intent.getAction().equals(GlobalValues.TIMER_ACTION_REPEATING)) &#123; Log.e(\"alarm_receiver\", \"周期闹钟\"); &#125; else if (intent.getAction().equals(GlobalValues.TIMER_ACTION)) &#123; Log.e(\"alarm_receiver\", \"定时闹钟\"); Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.logo); Intent intent1 = new Intent(context, WriteDiaryActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent1, 0); Notification notify = new Notification.Builder(context) .setSmallIcon(R.drawable.logo) // 设置状态栏中的小图片，尺寸一般建议在24×24 .setLargeIcon(bitmap) // 这里也可以设置大图标 .setTicker(\"亲情日历\") // 设置显示的提示文字 .setContentTitle(\"亲情日历\") // 设置显示的标题 .setContentText(\"您有日记提醒哦\") // 消息的详细内容 .setContentIntent(pendingIntent) // 关联PendingIntent .setNumber(1) // 在TextView的右方显示的数字，可以在外部定义一个变量，点击累加setNumber(count),这时显示的和 .getNotification(); // 需要注意build()是在API level16及之后增加的，在API11中可以使用getNotificatin()来 notify.flags |= Notification.FLAG_AUTO_CANCEL; NotificationManager manager = (NotificationManager) context.getSystemService(Context.NOTIF manager.notify(NOTIFICATION_FLAG, notify); bitmap.recycle(); //回收bitmap &#125; &#125;&#125; 注册BroadCastReceiver： 最后别忘了在清单里注册广播。1234567&lt;!--闹钟接收广播--&gt;&lt;receiver android:name=\".util.service.AlarmReceiver\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.e_eduspace.TIMER_ACTION_REPEATING\" /&gt; &lt;action android:name=\"com.e_eduspace.TIMER_ACTION\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 附件常量：123456public class GlobalValues &#123; // 周期性的闹钟 public final static String TIMER_ACTION_REPEATING = \"com.e_eduspace.TIMER_ACTION_REPEATING\"; // 定时闹钟 public final static String TIMER_ACTION = \"com.e_eduspace.TIMER_ACTION\";&#125; 工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.e_eduspace.familycalendar.util;import android.app.AlarmManager;import android.app.PendingIntent;import android.content.Context;import android.content.Intent;import com.prolificinteractive.materialcalendarview.CalendarDay;/** * 闹钟定时工具类 * * @author xulei * @time 2016/12/13 10:03 */public class AlarmTimer &#123; /** * 设置周期性闹钟 * * @param context * @param firstTime * @param cycTime * @param action * @param AlarmManagerType 闹钟的类型，常用的有5个值：AlarmManager.ELAPSED_REALTIME、 * AlarmManager.ELAPSED_REALTIME_WAKEUP、AlarmManager.RTC、 * AlarmManager.RTC_WAKEUP、AlarmManager.POWER_OFF_WAKEUP */ public static void setRepeatingAlarmTimer(Context context, long firstTime, long cycTime, String action, int AlarmManagerType) &#123; Intent myIntent = new Intent(); myIntent.setAction(action); PendingIntent sender = PendingIntent.getBroadcast(context, 0, myIntent, 0); AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE); alarm.setRepeating(AlarmManagerType, firstTime, cycTime, sender); //param1：闹钟类型，param1：闹钟首次执行时间，param1：闹钟两次执行的间隔时间，param1：闹钟响应动作。 &#125; /** * 设置定时闹钟 * * @param context * @param cycTime * @param action * @param AlarmManagerType 闹钟的类型，常用的有5个值：AlarmManager.ELAPSED_REALTIME、 * AlarmManager.ELAPSED_REALTIME_WAKEUP、AlarmManager.RTC、 * AlarmManager.RTC_WAKEUP、AlarmManager.POWER_OFF_WAKEUP */ public static void setAlarmTimer(Context context, long cycTime, String action, int AlarmManagerType, CalendarDay date) &#123; Intent myIntent = new Intent(); //传递定时日期 myIntent.putExtra(\"date\", date); myIntent.setAction(action); //给每个闹钟设置不同ID防止覆盖 int alarmId = SharedPreUtils.getInteger(context, \"alarm_id\", 0); SharedPreUtils.setInteger(context, \"alarm_id\", ++alarmId); PendingIntent sender = PendingIntent.getBroadcast(context, alarmId, myIntent, 0); AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE); alarm.set(AlarmManagerType, cycTime, sender); &#125; /** * 取消闹钟 * * @param context * @param action */ public static void cancelAlarmTimer(Context context, String action) &#123; Intent myIntent = new Intent(); myIntent.setAction(action); PendingIntent sender = PendingIntent.getBroadcast(context, 0, myIntent,0); AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE); alarm.cancel(sender); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"AlarmManager","slug":"AlarmManager","permalink":"http://LeiHolmes.github.io/tags/AlarmManager/"}]},{"title":"网络请求框架之Retrofit2.0基本讲解","slug":"网络请求框架之Retrofit2.0基本讲解","date":"2016-04-28T16:00:00.000Z","updated":"2017-09-28T08:56:06.000Z","comments":true,"path":"2016/04/29/网络请求框架之Retrofit2.0基本讲解/","link":"","permalink":"http://LeiHolmes.github.io/2016/04/29/网络请求框架之Retrofit2.0基本讲解/","excerpt":"Retrofit2.0简介 Retrofit是一套RESTful架构的Android(Java)客户端实现，基于注解，提供JSON to POJO(Plain Ordinary Java Object,简单Java对象)，POJO to JSON，网络请求(POST，GET,PUT，DELETE等)封装。用官方自己的介绍就是: A type-safe REST client for Android and Java 现已更新到2.0的版本，与1.0版本的使用上还是不小的差别，我也是第一次用，这里主要和大家研究研究2.0版本简单使用。也可参详官方示例。","text":"Retrofit2.0简介 Retrofit是一套RESTful架构的Android(Java)客户端实现，基于注解，提供JSON to POJO(Plain Ordinary Java Object,简单Java对象)，POJO to JSON，网络请求(POST，GET,PUT，DELETE等)封装。用官方自己的介绍就是: A type-safe REST client for Android and Java 现已更新到2.0的版本，与1.0版本的使用上还是不小的差别，我也是第一次用，这里主要和大家研究研究2.0版本简单使用。也可参详官方示例。 准备工作添加权限 首先添加网络请求权限1&lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; 添加依赖 Retrofit2.0版本后只支持okhttp请求，也已经封装好了，就不需要添加okhttp的依赖了。1234dependencies &#123; compile 'com.squareup.retrofit2:retrofit:2.0.2' compile 'com.squareup.retrofit2:converter-gson:2.0.0-beta3'&#125; 简单使用 接下来瞧一瞧Retrofit初始化以及如何请求数据。 初始化Retrofit对象12345public static final String BASE_URL = \"https://api.github.com/\";Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .build(); BASE_URL就是你请求的Server地址。1.addConverterFactory(GsonConverterFactory.create()) Retrofit2.0不提供返回JSON数据的默认解析方式，需要手动指定，支持Jackson等多种解析方式。需要哪种就添加相应的依赖，这里添加的是Retrofit提供的converter-gson依赖。有点不爽的就是不支持FastJson解析，有需要的话可以自己写一个FastjsonConverterFactory继承Converter.Factory实现。 虽然Retrofit2.0后只支持okhttp请求，但你也可以自定义一个okhttp再配置进Retrofit。1234567891011121314OkHttpClient client = new OkHttpClient();client.interceptors().add(new Interceptor() &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Response response = chain.proceed(chain.request()); // Do anything with response here return response; &#125;Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .client(client) .addConverterFactory(GsonConverterFactory.create()) .build();&#125;); 定义请求接口 实现转换HTTP API为Java接口，Retrofit提供了5种内置的注解：GET、POST、PUT、DELETE和HEAD，在注解中指定的资源的相对URL。1234public interface NetWorkService &#123; @GET(\"users/basil2style\") Call&lt;DataBean&gt; getData();&#125; 使用替换块和参数进行动态更新,替换块是{ and }包围的字母数字组成的字符串，相应的参数必须使用相同的字符串被@Path进行注释。12345@GET(\"repos/&#123;params1&#125;/&#123;params2&#125;/contributors\")Call&lt;List&lt;DataBean2&gt;&gt; getData( @Path(\"params1\") String params1, @Path(\"params2\") String params2,); 当我们调用getData()这个方法的时候，Retrofit会创建这个URL。如果我们传入Square和Retrofit字符串，分别作为owner和repo参数。我们就会得到这个URL：https://api.github.com/repos/square/retrofit/contributors 添加查询参数12@GET(\"repos/square/&#123;retrofit&#125;/contributors\")Call&lt;List&lt;DataBean2&gt;&gt; groupData(@Path(\"retrofit\") String retrofit, @Query(\"sort\") String sort); 当我们调用getData()方法时，传入一个查询参数字符串”ok”,这样我们就能得到URL：https://api.github.com/repos/square/retrofit/contributors?sort=ok 当然如果查询参数过多，我们也可以使用Map进行组合再传进来。12@GET(\"repos/square/&#123;retrofit&#125;/contributors\")Call&lt;List&lt;DataBean2&gt;&gt; getData(@Path(\"repos\") String repos, @QueryMap Map&lt;String, String&gt; parameters); 请求数据 Retrifot支持同步和异步的请求方式，先使用Retrofit类生成接口NetWorkService的实现。1NetWorkService service = retrofit.create(NetWorkService.class); 同步请求12Call&lt;DataBean&gt; call = service.getData(Square,Retrofit);DataBean bean = call.execute().body(); 注意同步请求不可在主线程执行，你懂得。且call只能执行execute()方法一次，若要再次请求可通过Call&lt;DataBean&gt; call = call.clone()来再复制一个Call对象。 异步请求1234567891011call.enqueue(new Callback&lt;DataBean&gt;() &#123; @Override public void onResponse(Call&lt;DataBean&gt; call, Response&lt;DataBean&gt; response) &#123; Toast.makeText(MainActivity.this, \"请求成功\", Toast.LENGTH_SHORT).show(); DataBean bean = response.body(); tvMain.setText(bean.toString()); &#125; @Override public void onFailure(Call&lt;DataBean&gt; call, Throwable t) &#123; &#125;&#125;); 当我们执行的同步或异步加入队列后，可以随时使用call.cancel()方法取消请求。 注意 注解中参数的写法与BASE_URL的拼接一定要注意，请看以下写法。 错误示例1 BASE_URL：https://api.github.com/repos/square Get注解： @GET(“/basil2style”) 结果URL： https://api.github.com/basil2style 错误示例2 BASE_URL：https://api.github.com/repos/square Get注解： @GET(“basil2style”) 结果URL： https://api.github.com/repos/basil2style 推荐写法 BASE_URL：https://api.github.com/repos/square/ Get注解： @GET(“basil2style”) 结果URL： https://api.github.com/repos/square/basil2style 总结 Retrofit2.0的基本实现讲解完毕，Retrofit+Okhttp+Gson可以算是目前来说相当快的超级网络请求框架了。相比较于Volley都快不少，亲测结果很爽。小伙伴们赶紧整起来吧！ 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者不懂的地方也可以在我Github上Retrofit2Demo项目的Issues中提出，我会及时解答。附上GreenDaoDemo的地址： Retrofit2Demo","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"http://LeiHolmes.github.io/tags/Retrofit/"}]},{"title":"如何使用神器Stetho调试Volley","slug":"如何使用神器Stetho调试Volley","date":"2016-04-18T16:00:00.000Z","updated":"2017-09-28T08:55:57.000Z","comments":true,"path":"2016/04/19/如何使用神器Stetho调试Volley/","link":"","permalink":"http://LeiHolmes.github.io/2016/04/19/如何使用神器Stetho调试Volley/","excerpt":"Stetho简介 Stetho 是 Facebook 开源的一个 Android 调试工具。是一个 Chrome Developer Tools 的扩展，可用来检测应用的网络、数据库、WebKit 等方面的功能。开发者也可通过它的 dumpapp 工具提供强大的命令行接口来访问应用内部。无需root查看sqlite文件、sharedpreference文件等等。更多详细介绍可以进入Stetho官网。","text":"Stetho简介 Stetho 是 Facebook 开源的一个 Android 调试工具。是一个 Chrome Developer Tools 的扩展，可用来检测应用的网络、数据库、WebKit 等方面的功能。开发者也可通过它的 dumpapp 工具提供强大的命令行接口来访问应用内部。无需root查看sqlite文件、sharedpreference文件等等。更多详细介绍可以进入Stetho官网。 Stetho结合OkHttp使用添加依赖1234// Gradle dependency on Stetho dependencies &#123; compile 'com.facebook.stetho:stetho:1.1.1' &#125; Stetho初始化配置在App的Application中完成初始化。123456789101112public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); Stetho.initialize( Stetho.newInitializerBuilder(this) .enableDumpapp( Stetho.defaultDumperPluginsProvider(this)) .enableWebKitInspector( Stetho.defaultInspectorModulesProvider(this)) .build()); &#125;&#125; 官网中使用OkHttp为实例，使用如下12OkHttpClient client = new OkHttpClient();client.networkInterceptors().add(new StethoInterceptor()); 然后就可以运行App进行调试，基本上可以满足调试需求了。 Stetho结合Volley使用官网中Stetho是结合OkHttp的使用，如果项目中使用Volley做为网络请求框架，可以做如下修改。还是使用OkHttp做为Volley中HttpStack的实现，我们知道，Volley中网络请求在Android2.3及以上基于HttpURLConnection，2.3以下基于HttpClient实现，通过增加HttpStack的具体实现即可。这里使用Bryan Stern分享的代码。（网页可能被墙，可以通过VPN访问。需要VPN的可以点击这里） 添加依赖123compile 'com.facebook.stetho:stetho:1.1.1'compile 'com.facebook.stetho:stetho-okhttp:1.1.1'compile 'com.squareup.okhttp:okhttp:2.3.0' Stetho初始化配置123OkHttpClient client = new OkHttpClient();client.networkInterceptors().add(new StethoInterceptor());mRequestQueue = Volley.newRequestQueue(getApplicationContext(), new OkHttpStack(client)); 好了，基本上这样就能使用Stetho神器调试你的App了，感觉到强大了么~。 补充：使用中遇到的坑 Stetho inspect窗口空白 如果出现调试窗口空白，先升级下Chrome吧。升级最新版后再试一下（我被这个坑了）。 Stetho inspect窗口还是空白 如果Chrome是最新版，无论如何刷新都是空白，那么恭喜你你可能被墙了~用VPN试试吧 可以戳这里哦 我的测试代码和效果图如下：自定义Application类：12345678910111213141516171819202122232425262728293031public class MyAppliation extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); context = getApplicationContext(); instance = this; Stetho.initialize( Stetho.newInitializerBuilder(this) .enableDumpapp(Stetho.defaultDumperPluginsProvider(this)) .enableWebKitInspector(Stetho.defaultInspectorModulesProvider(this)) .build()); &#125; /** * @return The Volley Request queue */ public RequestQueue getRequestQueue() &#123; // lazy initialize the request queue, the queue instance will be // created when it is accessed for the first time synchronized (App.class) &#123; if (mRequestQueue == null) &#123; OkHttpClient client = new OkHttpClient(); client.networkInterceptors().add(new StethoInterceptor()); mRequestQueue = Volley.newRequestQueue(getApplicationContext(), new OkHttpStack(client)); &#125; &#125; return mRequestQueue; &#125;&#125; Activity类代码： 123456789101112131415161718192021222324252627282930public class MainActivity extends Activity &#123; private TextView tv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout_main); tv = (TextView)findViewById(R.id.tv); RequestQueue queue = App.getInstance().getRequestQueue(); String url = \"https://publicobject.com/helloworld.txt\"; StringRequest request = new StringRequest(Request.Method.GET, url, new Response.Listener&lt;String&gt;() &#123; @Override public void onResponse(String s) &#123; LogUtil.d(s); tv.setText(s); &#125; &#125;, new com.android.volley.Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError volleyError) &#123; LogUtil.e(volleyError.toString()); &#125; &#125;); queue.add(request); SharedPrfUtil.setInt(\"uid\",669); SharedPrfUtil.setString(\"username\",\"dongye\"); &#125;&#125; 实现效果如下图： Stetho调试效果图 调试程序列表 调试网络请求 读取数据存储","categories":[{"name":"Android","slug":"Android","permalink":"http://LeiHolmes.github.io/categories/Android/"}],"tags":[{"name":"Stetho","slug":"Stetho","permalink":"http://LeiHolmes.github.io/tags/Stetho/"}]}]}