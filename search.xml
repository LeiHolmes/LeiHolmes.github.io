<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java面试技术点总结]]></title>
    <url>%2F2017%2F12%2F25%2FJava%E9%9D%A2%E8%AF%95%E6%8A%80%E6%9C%AF%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言 前段时间换工作准备期间，总结了下在Android面试中易问的一些Java基础知识与面试题，不太全，大家查缺补漏吧。开始Review！ 面向对象Java面向对象编程思想 将属性与功能封装起来，通过归类与抽象将相同或相似的部分抽出，不同的部分分离，将复杂业务逻辑切分成相互独立的部分，降低开发的难度。 面向对象是解决了系统的可维护性，可扩展性和可重用性主要通过以下四大特性来实现： 抽象：核心思想！把相同的或相似的对象归为一类的这个过程就是抽象。抽象只关心对象中的主要问题，主要矛盾及相同的部分。它只在乎问题是什么，能够完成什么，而不在乎怎么去完成，交给他的实现类去解决。 封装：将某些属性包装在一起，再以全新的形式呈现出来。其中隐藏属性，方法或实现的细节称之为封装。 继承：重用现有的父类来生成新子类的一种特征，子类可通过继承父类来获取父类的属性与方法。 多态：同一函数在不同的类中有不同的实现，使类变得更灵活，更便于扩充。父类引用指向子类对象。 设计模式单例模式5种： 懒汉式 饿汉式 同步线程锁懒汉式 双重线程锁懒汉式 最优单例 简单工厂模式 由一个工厂类，根据传入参数的不同，动态创建不同的产品，这些产品都继承自一个父类或接口的实例。得益于Java的多态特性。 集合List集合：有序，可重复 ArrayList：底层是动态数组顺序表数据结构，存储地址是连续的，所以查询速度快。但增删时需要移动其他元素的顺序，所以增删速度慢，线程不同步。 LinkedList：底层是双向链表数据结构，同时也实现了Deque双端队列接口，链表节点存储地址不连续。每个存储地址之间通过指正关联，查询时需要指针遍历所有节点，所以查询速度慢。而增删只需断开某元素前后的链接进行增加与删除即可，所以增删速度快，线程不同步。 Vector：类似ArrayList，线程同步，效率低。 Set集合：无序，不可重复 HashSet：底层数组，哈希表数据结构，线程不同步。 TreeSet：二叉树数据结构，可实现Comparable或Comparator接口来排序，线程不同步。 Map集合：键值对，键不可重复，值可以重复 HashMap：哈希表数据结构，可存入null键，null值，线程不同步。 HashTable：哈希表数据结构，不可存入null键，null值，线程同步。 TreeMap：二叉树数据结构，可进行排序，线程不同步 网络编程TCP/IP层级 应用层：向用户提供一些常用应用程序，例如电子邮件，文件传输访问等。包含常用协议HTTP（超文本传输协议：实现互联网中WWW服务）、DNS（域名解析：域名到IP地址间的转换） 传输层：提供应用程序之前的传输通道。主要传输协议为TCP（面向连接传输控制协议，三次握手，安全可靠性高，适用于传输大量数据，但速度慢）与UDP（面向无连接用户数据报协议，无需握手同步，安全可靠性低，适用于传输小量数据，但速度快，例如QQ）。 网络层：核心层，根据IP协议将分组装入IP数据报并发往目标网络或主机。主要传输协议为IP协议（用于源地址与目的地址间的传送数据报）与ICMP协议（传送IP控制信息） 网络接口层：最底层，接收IP数据报，并通过网络发送 执行顺序静态变量，静态代码块，本地变量执行顺序 父类代码：123456789101112131415161718192021222324252627282930public class FatherTest &#123; static &#123; System.out.println("--父类的静态代码块--"); &#125; private String name; &#123; System.out.println("--父类的非静态代码块--"); &#125; public FatherTest() &#123; System.out.println("--父类的无参构造函数--"); &#125; public FatherTest(String name) &#123; this.name = name; System.out.println("--父类的有参构造函数--" + this.name); &#125; public void show() &#123; System.out.println("--父类的show()方法--"); &#125; public static void main(String[] args) &#123; System.out.println("--父类的主程序--"); FatherTest fatherTest = new FatherTest("父亲的名字"); fatherTest.show(); &#125;&#125; 父类输出：12345--父类的静态代码块----父类的主程序----父类的非静态代码块----父类的有参构造函数--父亲的名字--父类的show()方法-- 带继承关系的执行顺序** 子类代码：12345678910111213141516171819202122232425262728293031323334public class SonTest extends FatherTest &#123; static &#123; System.out.println("--子类的静态代码块--"); &#125; private String name; &#123; System.out.println("--子类的非静态代码块--"); &#125; public SonTest() &#123; //默认super()调父类无参构造 System.out.println("--子类的无参构造函数--"); &#125; public SonTest(String name) &#123; //默认super()调父类无参构造 this.name = name; System.out.println("--子类的有参构造函数--" + this.name); &#125; @Override public void show() &#123; //此处若不调用super.show()则只走子类重写的show()方法 System.out.println("--子类Override父类的show()方法--"); &#125; public static void main(String[] args) &#123; System.out.println("--子类的主程序--"); SonTest sonTest = new SonTest("儿子的名字"); sonTest.show(); &#125;&#125; 子类输出12345678--父类的静态代码块----子类的静态代码块----子类的主程序----父类的非静态代码块----父类的无参构造函数----子类的非静态代码块----子类的有参构造函数--儿子的名字--子类Override父类的show()方法-- 计算Math的一些计算 Math.round()：四舍五入，+0.5后向下取整（Math.round(11.5)=12，Math.round(-11.5)=-11），float返回int，double返回long Math.rint()：四舍五入，遇0.5则取偶数（Math.rint(11.4)=11.0，Math.rint(11.5)=12，Math.rint(10.5)=10） Math.floor()：不大于它的最大整数（Math.floor(11.5)=11，Math.floor(-11.5)=-12） Math.ceil()：不小于他的最小整数（Math.ceil(11.5)=12，Math.ceil(-11.5)=-11） Math.abs()：绝对值（Math.abs(11.5)=11.5，Math.abs(-11.5)=11.5） Math.max()：最大值（Math.max(-11.5, -11.4)=-11.4） Math.min()：最小值（Math.min(-11.5, -11.4)=-11.5） Math.random()：0.0-1.0之间的随机数 Math.pow(x, y)：x的y次幂 Math.sqrt()：开方 常量池计算 Java的8种基本类型(Byte, Short, Integer, Long, Character, Boolean, Float, Double), 除Float和Double以外, 其它六种都实现了常量池, 但是它们只在大于等于-128并且小于等于127时才使用常量池. 来看代码演示：123456789101112131415161718192021222324252627282930313233public static void main(String[] args) &#123; Integer a = 127; Integer b = 127; System.out.println("等于127:"); System.out.println(a == b); System.out.println("*****************"); a = 128; b = 128; System.out.println("等于128:"); System.out.println(a == b); System.out.println("*****************"); a = -128; b = -128; System.out.println("等于-128:"); System.out.println(a == b); System.out.println("*****************"); a = -129; b = -129; System.out.println("等于-129:"); System.out.println(a == b); System.out.println("*****************"); // 测试Boolean System.out.println("测试Boolean"); Boolean c = true; Boolean d = true; System.out.println(c == d); d = new Boolean(true); System.out.println(c == d); &#125; 输出结果：123456789101112131415等于127:true*****************等于128:false*****************等于-128:true*****************等于-129:false*****************测试Booleantruefalse 结论：当我们给Integer赋值时，实际上调用了Integer.valueOf(int)方法，查看源码，其实现如下：123456public static Integer valueOf(int i) &#123; if(i &gt;= -128 &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + 128]; else return new Integer(i); &#125; 而IntegerCache实现如下：123456789101112131415161718192021222324252627private static class IntegerCache &#123; static final int high; static final Integer cache[]; static &#123; final int low = -128; // high value may be configured by property int h = 127; if (integerCacheHighPropValue != null) &#123; // Use Long.decode here to avoid invoking methods that // require Integer's autoboxing cache to be initialized int i = Long.decode(integerCacheHighPropValue).intValue(); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - -low); &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; private IntegerCache() &#123;&#125; &#125; 注意：cache数组是静态的。 面试题LinkedList工作原理与实现 LinkedList是以双向链表实现，链表无容量限制（但是双向链表本身需要消耗额外的链表指针空间来操作），其内部主要成员为 first 和 last 两个 Node 节点，在每次修改列表时用来指引当前双向链表的首尾部位，所以 LinkedList 不仅仅实现了 List 接口，还实现了 Deque 双端队列接口（该接口是 Queue 队列的子接口），故 LinkedList 自动具备双端队列的特性，当我们使用下标方式调用列表的 get(index)、set(index, e) 方法时需要遍历链表将指针移动到位进行访问（会判断 index 是否大于链表长度的一半决定是首部遍历还是尾部遍历，访问的复杂度为 O(N/2)），无法像 ArrayList 那样进行随机访问。(如果i&gt;数组大小的一半，会从末尾移起)，只有在链表两头的操作（譬如 add()、addFirst()、removeLast() 或用在 iterator() 上的 remove() 操作）才不需要进行遍历寻找定位。 使用LinkedList模拟一个堆栈或队列的数据结构 123456789101112131415161718192021public class Queue &#123; private LinkedList link; public Queue() &#123; link = new LinkedList(); &#125; public void push(Object obj) &#123; link.addLast(obj); &#125; public Object pop() &#123; //堆栈先进后出，队列先进先出 return link.removeFirst(); //队列 //return link.removeLast(); //堆栈 &#125; public boolean isEmpty() &#123; return link.isEmpty(); &#125;&#125; ConcurrentModificationException异常 计算下面代码的输出结果：1234567891011List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("di"); String str = new String("da"); list.add(str); list.add("paint"); for(String temp : list)&#123; if(temp == "di" || temp == "da")&#123; list.remove(temp); &#125; &#125;System.out.print(list.toString()); 解答：会抛出ConcurrentModificationException异常，List不可在进行遍历时添加或移除其中的元素。 源码解析：ArrayList的父类AbstractList中有一个modCount成员变量来记录对List的修改次数，还有一个expectedModCount记录对ArrayList修改次数的期望值，modCount是它的初始值。遍历开始时modCount与expectedModCount都为0，而当我们在遍历中对List进行了add或remove操作后modCount会增加1，expectedModCount不变。而List在通过next()方法取下一次值时会先检查modCount与expectedModCount是否相等，不等则会抛出ConcurrentModificationException异常。 单线程中解决方案：使用Iterator遍历集合，调用Iterator的remove方法移除元素，其内部有expectedModCount = modCount的操作。 多线程中解决方案：多线程中使用上述方法也会抛出此异常，可在使用iterator迭代的时候使用synchronized或者Lock进行同步，或使用CopyOnWriteArrayList替换ArrayList。 通过代码输出365的二进制 简单版 12345678910111213public static void main(String[] args) &#123; int a = 365;//定义一个变量并赋给他一个十进制的值 int remainder;//定义一个变量用于存储余数 int sum = 0;//定义一个变量用于存放和 int k = 1;//定义一个变量控制位数 while(a != 0)&#123; remainder = a % 2;//对目标数字求余 a /= 2;//对目标数字求商 sum = sum + remainder * k;//求和 k *= 10;//改变位数 &#125; System.out.println("10进制的365转换为2进制结果为：" + sum );&#125; 负数版 123456789101112131415161718192021222324252627public static void main(String[] args) &#123; int n = -10; String result = ""; boolean minus = false; //如果该数字为负数，那么进行该负数+1之后的绝对值的二进制码的对应位取反，然后将它保存在result结果中 if(n &lt; 0)&#123; minus = true; n = Math.abs(n + 1); &#125; while(true)&#123; int remainder = (!minus &amp;&amp; n % 2 == 0) || (minus &amp;&amp; n % 2 == 1) ? 0 : 1; //将余数保存在结果中 result = remainder + result; n /= 2; if(n == 0)&#123; break; &#125; &#125; //判断是否为负数，如果是负数，那么前面所有位补1 if(minus)&#123; n = result.length(); for(int i = 1; i &lt;= 32 - n; i++)&#123; result = 1 + result; &#125; &#125; System.out.println(result);&#125; 总结 目前Java面试技术点总结的还不太全，我会持续更新，也欢迎码友们指出文中写的不对的地方，或者有遗漏的知识点也可以联系我，咱们一起来维护，方便你我他。最后祝各位求职顺利，入职满意的公司。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java Review</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxBinding系列之RxAdapterView(四)]]></title>
    <url>%2F2017%2F11%2F14%2FRxBinding%E7%B3%BB%E5%88%97%E4%B9%8BRxAdapterView(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[前言 本篇一起来学习RxBinding中的RxAdapterView，J大神将Android中AdapterView(ListView、GridView等)的一些事件及动作加以RxJava的观察者模式并封装了起来就形成了RxAdapterView，使用起来相当便捷。 本篇以ListView为例子。 布局 主布局中就需要一个ListView即可。123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.leiholmes.rxbindingdemo.ui.RxAdapterViewActivity"&gt; &lt;ListView android:id="@+id/lv_list" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/RelativeLayout&gt; ActivityView注入 使用ButterKnife获取ListView实例。12@BindView(R.id.lv_list)ListView lvList; 初始化假数据与适配器12345678910//假数据list = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 100; i++) &#123; list.add("LeiHolmes:" + i);&#125;//adapter适配器ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1);adapter.addAll(list);lvList.setAdapter(adapter); itemClicks条目点击事件 RxAdapterView.itemClicks(AdapterView view)，内部封装了OnItemClickListener条目点击监听。1234addDisposable(RxAdapterView.itemClicks(lvList) .throttleFirst(2, TimeUnit.SECONDS) .subscribe(integer -&gt; Toast.makeText(RxAdapterViewActivity.this, "点击了第" + integer + "条：" + list.get(integer), Toast.LENGTH_SHORT).show())); 需要详细点击信息可使用RxAdapterView.itemClickEvents(AdapterView view)，它返回的类型是AdapterViewItemClickEvent，内部包含clickedView、position、id等信息。 itemLongClicks条目长按事件 RxAdapterView.itemLongClicks(AdapterView view)，内部封装了OnItemLongClickListener条目长按监听。1234addDisposable(RxAdapterView.itemLongClicks(lvList) .throttleFirst(2, TimeUnit.SECONDS) .subscribe(integer -&gt; Toast.makeText(RxAdapterViewActivity.this, "长按了第" + integer + "条：" + list.get(integer), Toast.LENGTH_SHORT).show())); 需要详细长按信息可使用RxAdapterView.itemLongClickEvents(AdapterView view)，它返回的类型是AdapterViewItemLongClickEvent，内部包含clickedView、position、id等信息。 itemSelections条目选中事件 RxAdapterView.itemSelections(AdapterView view)，内部封装了OnItemSelectedListener条目选中监听。当ItemView中有选中效果View时起作用。12addDisposable(RxAdapterView.itemSelections(lvList) .subscribe(integer -&gt; Log.e("rx_binding_test", "itemSelections：" + integer))); 需要详细选中信息可使用RxAdapterView.selectionEvents(AdapterView view)，它返回的类型是AdapterViewSelectionEvent。 View操作 RxAdapterView中也封装了AdapterView中例如setSelection()等常用的操作，使用方式如下：123addDisposable(RxAdapterView.itemClicks(lvList) .throttleFirst(2, TimeUnit.SECONDS) .subscribe(integer -&gt; RxAdapterView.selection(lvList).accept(0))); 本文疑问addDisposable()方法什么鬼？飞机到本系列第一篇有讲解：RxBinding系列之RxView(一) Lambda表达式什么鬼？飞机到我写的Lambda表达式教程：Lambda表达式基本语法与应用 总结 到本篇为止，RxBingding中常用的View就介绍完毕了。RxBingding中还有很多内容未介绍，感兴趣的码友可去J大神的GitHub中系统的学习一下。 JakeWharton/RxBinding 进阶中的码猿一枚，写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxBindingDemo项目Issues中提出，我会及时回复。 附上Demo的地址： RxBindingDemo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxBinding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxBinding系列之RxCompoundButton(三)]]></title>
    <url>%2F2017%2F11%2F13%2FRxBinding%E7%B3%BB%E5%88%97%E4%B9%8BRxCompoundButton(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[前言 本篇将通过一个实际场景来学习RxBinding中的RxCompoundButton，J大神将Android中CompoundButton的一些事件及动作加以RxJava的观察者模式并封装了起来就形成了RxCompoundButton，使用起来也很简单。 场景：注册时需用户点击同意用户协议选中框才可点击注册按钮。 布局 布局中更需要一个注册Button和一个用户协议选中框CheckBox。1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:padding="15dp" tools:context="com.leiholmes.rxbindingdemo.ui.RxCompoundButtonActivity"&gt; &lt;Button android:id="@+id/btn_login" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@color/colorGray" android:text="注册" /&gt; &lt;CheckBox android:id="@+id/cb_contract" android:layout_width="wrap_content" android:layout_marginTop="10dp" android:layout_height="wrap_content" android:text="用户协议" /&gt;&lt;/LinearLayout&gt; ActivityView注入 使用ButterKnife获取Button与CheckBox实例。1234@BindView(R.id.btn_login)Button btnLogin;@BindView(R.id.cb_contract)CheckBox cbContract; checkedChanges选中状态改变事件 RxCompoundButton.checkedChanges(CompoundButton view)，内部封装了OnCheckedChangeListener选中状态改变监听。1234567891011121314//默认注册按钮不可点击btnLogin.setEnabled(false);addDisposable(RxCompoundButton.checkedChanges(cbContract) .subscribe(aBoolean -&gt; &#123; RxView.enabled(btnLogin).accept(aBoolean); btnLogin.setBackgroundResource(aBoolean ? R.color.colorPrimary : R.color.colorGray); RxTextView.color(btnLogin).accept(aBoolean ? Color.parseColor("#ffffff") : Color.parseColor("#000000")); &#125;));addDisposable(RxView.clicks(btnLogin) //防抖2s .throttleFirst(2, TimeUnit.SECONDS) .subscribe(o -&gt; Toast.makeText(RxCompoundButtonActivity.this, "注册成功", Toast.LENGTH_SHORT).show())); 默认注册按钮不可点击，当CheckBox被选中后则可点击注册，并修改注册按钮的样式。 View操作 RxCompoundButton中也封装了CompoundButton中例如setchecked()、toggle()等常用的操作，使用方式如下：12345addDisposable(RxView.clicks(btnLogin) .subscribe(o -&gt; &#123; RxCompoundButton.checked(cbContract).accept(true); RxCompoundButton.toggle(cbContract).accept(null); &#125;)); 运行效果 最后看一下运行效果Gif。 本文疑问addDisposable()方法什么鬼？飞机到本系列第一篇有讲解：RxBinding系列之RxView(一) Lambda表达式什么鬼？飞机到我写的Lambda表达式教程：Lambda表达式基本语法与应用 总结 通过实际场景来学习新知识掌握起来肯定比死啃理论快，建议码友们都上手试试。 进阶中的码猿一枚，写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxBindingDemo项目Issues中提出，我会及时回复。 附上Demo的地址： RxBindingDemo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxBinding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxBinding系列之RxTextView(二)]]></title>
    <url>%2F2017%2F11%2F12%2FRxBinding%E7%B3%BB%E5%88%97%E4%B9%8BRxTextView(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[前言 本篇一起来学习RxBinding中的RxTextView，J大神将Android中TextView的一些事件及动作加以RxJava的观察者模式并封装了起来就形成了RxTextView，使用起来也很简单。 textChange文本改变事件textChanges RxTextView.textChanges(TextView view)，内部封装了TextWatcher文本改变监听。1234567addDisposable(RxTextView.textChanges(etRxTextView).subscribe(new Consumer&lt;CharSequence&gt;() &#123; @Override public void accept(CharSequence charSequence) throws Exception &#123; Log.e("rx_binding_test", "textChanges:文本改变了:" + charSequence.toString()); &#125;&#125;)); textChangeEvents RxTextView.textChangeEvents(TextView view)，内部同样封装了TextWatcher文本改变监听。不同的是其返回数据的类型为TextViewTextChangeEvent，内部包含详细的文本改变数据。为了简化代码，以下实例将使用Lambda表达式的形式。123456addDisposable(RxTextView.textChangeEvents(etRxTextView) .subscribe(textViewTextChangeEvent -&gt; &#123; Log.e("rx_binding_test", "textChanges:文本改变了:" + "before:" + textViewTextChangeEvent.before() + ",start:" + textViewTextChangeEvent.start() + ",text:" + textViewTextChangeEvent.text() + ",count:" + textViewTextChangeEvent.count()); &#125;)); 实际场景 在实际项目开发中经常会遇到搜索文本框需根据用户实时输入的文本进行检索，或去数据库查询，或去服务器请求检索。如果文本每改变一次都去检索的话会导致重复大量查数据库或请求服务器，很影响内存。来看下使用RxBinding如何解决这个问题。12345678910addDisposable(RxTextView.textChanges(etRxTextView) //限流时间500ms .debounce(500, TimeUnit.MILLISECONDS) .observeOn(AndroidSchedulers.mainThread()) //CharSequence转换为String .map(CharSequence::toString) .subscribe(s -&gt; &#123; //这里可以查询数据库或请求服务器查询 Log.e("rx_binding_test", "textChanges:文本改变了:" + s); &#125;)); 正是由于RxBinding使用的是RxJava形式，所以RxJava中的操作符我们都可以使用。利用debounce操作符进行限流，就能避免因为用户输入速度过快导致多次请求服务器了。还可以利用map操作符将CharSequence转换为String再返回。Look，解决这个问题是不是So easy！ editorAction回车点击事件editorActions RxTextView.editorActions(TextView view)，内部封装了OnEditorActionListener软键盘回车点击监听。1234addDisposable(RxTextView.editorActions(etRxTextView) .subscribe(integer -&gt; &#123; Log.e("rx_binding_test", "editorActions:输入完毕，点击回车:"); &#125;)); editorActionEvents RxTextView.editorActionEvents(TextView view)，内部同样封装了OnEditorActionListener软键盘回车点击监听。不同的是它的返回类型为TextViewEditorActionEvent，包含actionId，keyEvent等信息。12345678addDisposable(RxTextView.editorActionEvents(etRxTextView) .subscribe(textViewEditorActionEvent -&gt; &#123; KeyEvent keyEvent = textViewEditorActionEvent.keyEvent(); //判断up状态 if (keyEvent.getKeyCode() == KeyEvent.KEYCODE_ENTER &amp;&amp; keyEvent.getAction() == KeyEvent.ACTION_UP) &#123; Log.e("rx_binding_test", "editorActionEvents:输入完毕，点击回车:" + textViewEditorActionEvent.keyEvent()); &#125; &#125;)); 注意：KeyEvent包含down和up事件，所以会出现回调两次的问题。根据KeyEvent加入一种判断即可避免此问题。 此外，RxTextView中还有beforeTextChangeEvents与afterTextChangeEvents，使用起来都差不多就不一一介绍了。 View操作 RxTextView中还封装了一些常用的例如setText()、setHint()、setTextColor()等TextView的操作。使用起来也很简单，如下：123456addDisposable(RxTextView.editorActions(etRxTextView) .subscribe(integer -&gt; &#123; RxTextView.text(etRxTextView).accept("LeiHolmes"); RxTextView.hint(etRxTextView).accept("请输入姓名"); RxTextView.color(etRxTextView).accept(Color.parseColor("#00ff00")); &#125;)); 本文疑问addDisposable()方法什么鬼？飞机到本系列第一篇有讲解：RxBinding系列之RxView(一) Lambda表达式什么鬼？飞机到我写的Lambda表达式教程：Lambda表达式基本语法与应用 总结 RxTextView中的内容不多，所以本篇篇幅较短，不要说我水啊，哈哈哈，我是觉得一种一种讲起来比较细致，建议码友们都上手敲一敲试一试啊。 进阶中的码猿一枚，写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxBindingDemo项目Issues中提出，我会及时回复。 附上Demo的地址： RxBindingDemo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxBinding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxBinding系列之RxView(一)]]></title>
    <url>%2F2017%2F11%2F09%2FRxBinding%E7%B3%BB%E5%88%97%E4%B9%8BRxView(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[前言 自从用上RxJava后彻底迷上Rx系列响应式编程，从本篇开始一起来学习一下Rx套餐之一的RxBinding。RxBinding是什么？它是一组开源库，来自大神Jake Wharton之手，可将Android中各类UI控件的动作事件转换为RxJava中的数据流。也就是说使用RxBinding，我们就可以以RxJava的形式来处理UI事件。本篇主要讲解其中RxView的相关View事件如何绑定。 RxBinding中主要包含RxView、RxTextView、RxAdapterView、RxCompoundButton等等。由于全写一起篇幅太长，我就一篇讲解一种了。本系列主要讲解以上常用的4种，详细内容可飞机到： Jake Wharton的RxBinding 依赖 本系列围绕我自己编写的RxBindingDemo来进行讲解，项目中主要使用ButterKnife做View注入，RxBinding做事件绑定。RxBindingDemo代码在文末有给地址。 注意：RxBinding包中包含RxJava的内容，所以就无需再添加RxJava的依赖了。123456dependencies &#123; ...... compile 'com.jakewharton.rxbinding2:rxbinding:2.0.0' compile 'com.jakewharton:butterknife:8.8.1' annotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1'&#125; BaseActivity 相信学习过RxJava的码友一定记得，使用RxJava实例化的Disposable需在不用时及时销毁。 由于每个Activity中都写一套add与clear的方法会造成代码冗余，所以我将它们封装到BaseActivity中方便统一对Disposable进行管理，以及ButterKnife的统一绑定与解绑。 献上代码：12345678910111213141516171819202122232425262728293031323334353637383940414243public abstract class BaseActivity extends AppCompatActivity &#123; public CompositeDisposable mCompositeDisposable; private Unbinder mUnbinder; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(getLayoutId()); mUnbinder = ButterKnife.bind(this); mCompositeDisposable = new CompositeDisposable(); onViewCreated(savedInstanceState); &#125; /** * 添加订阅 */ public void addDisposable(Disposable mDisposable) &#123; if (mCompositeDisposable == null) &#123; mCompositeDisposable = new CompositeDisposable(); &#125; mCompositeDisposable.add(mDisposable); &#125; /** * 取消所有订阅 */ public void clearDisposable() &#123; if (mCompositeDisposable != null) &#123; mCompositeDisposable.clear(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); clearDisposable(); mUnbinder.unbind(); &#125; protected abstract int getLayoutId(); protected abstract void onViewCreated(Bundle savedInstanceState);&#125; click点击事件clicks RxView.clicks(View view)，通过源码可发现其内部封装了View.OnClickListener点击监听，调用clicks方法返回一个Observable对象，每当点击这个View的时候，该Observable对象就会发射一个事件，随即调用onNext()方法，Observable对应的观察者就可以通过onNext()回调响应此次点击事件。使用RxBinding还可做到点击防抖的效果。来看代码：12345addDisposable(RxView.clicks(btnClick) .throttleFirst(2, TimeUnit.SECONDS) .subscribe(o -&gt; &#123; Log.e("rx_binding_test", "clicks:点击了按钮：两秒内防抖"); &#125;)); throttleFirst(long windowDuration, TimeUnit unit)，设置一定时间内只响应首次(throttleFirst)或者末次(throttleLast)的点击事件。windowDuration为防抖时间，unit为时间单位。调用这个方法便可防止短时间内对View的重复点击，本例中设置的防抖时间为2s。从代码看来是不是方便又简洁呢，以往实现防抖还得添加各种标记，忒麻烦。 longClicks RxView.longClicks(View view)，内部封装了View.OnLongClickListener长按监听，原理同上。1234addDisposable(RxView.longClicks(btnClick) .subscribe(o -&gt; &#123; Log.e("rx_binding_test", "longClicks:长点击了按钮"); &#125;)); draw绘制事件 RxView.draws(View view)，内部封装了OnDrawListener绘制监听。12345678910111213//点击btnDraw调用viewCanvas的绘制addDisposable(RxView.clicks(btnDraw) .throttleFirst(2, TimeUnit.SECONDS) .subscribe(o -&gt; &#123; //此处可模拟让viewCanvas绘制 //viewCanvas.getViewTreeObserver().dispatchOnDraw(); &#125;)); //当viewCanvas绘制时触发addDisposable(RxView.draws(viewCanvas) .subscribe(o -&gt; &#123; Log.e("rx_binding_test", "draws:viewCanvas绘制了"); &#125;)); drag拖拽事件 RxView.drags(View view)，内部封装了OnDragListener拖拽监听。12345//当btnDraw被拖拽时触发addDisposable(RxView.drags(btnDraw) .subscribe(o -&gt; &#123; Log.e("rx_binding_test", "drags:btnDraw被拖拽了"); &#125;)); layoutChange布局改变事件 RxView.layoutChanges(View view)，内部封装了OnLayoutChangeListener布局改变监听。123456789101112//点击btnChange改变btn_layout的布局,防抖2saddDisposable(RxView.clicks(btnChange) .throttleFirst(2, TimeUnit.SECONDS) .subscribe(o -&gt; btnLayout.layout(btnLayout.getLeft() - 20, btnLayout.getTop(), btnLayout.getRight() - 20, btnLayout.getBottom()) )); //btn_layout布局改变时触发addDisposable(RxView.layoutChanges(btnLayout) .subscribe(o -&gt; &#123; Log.e("rx_binding_test", "layoutChanges:btnLayout布局改变了"); &#125;)); scrollChange滑动事件 RxView.scrollChangeEvents(View view)，内部封装了OnScrollChangeListener滑动监听。12345678910111213141516//点击btnScroll模拟让btnScrollLayout滑动addDisposable(RxView.clicks(btnScroll) .throttleFirst(2, TimeUnit.SECONDS) .subscribe(o -&gt; &#123; x += 10; if (x == 100) &#123; x = 0; &#125; btnScrollLayout.scrollTo(x, 0); &#125;)); //btnScrollLayout滑动时触发addDisposable(RxView.scrollChangeEvents(btnScrollLayout) .subscribe(event -&gt; &#123; Log.e("rx_binding_test", "scrollChangeEvents:btnScrollLayout滑动了:" + event.toString()); &#125;)); View操作 RxView中还封装了一些常用的例如setVisibility()、setClickable()等View操作。使用起来也很简单，如下：1234567addDisposable(RxView.clicks(btnClick) .throttleFirst(2, TimeUnit.SECONDS) .subscribe(o -&gt; &#123; RxView.visibility(btnClick).accept(true); RxView.clickable(btnClick).accept(true); RxView.enabled(btnClick).accept(true); &#125;)); 这种操作方法单独使用是需要进行try-catch的，但还记得RxJava2系列中我们学习到，RxJava2的Action与Function的回调方法中都默认throws Exception，RxBinding也是如此。所以在观察者中调用就无需try-catch了。 更多的操作可在RxView的源码中查到，基本上View中有的，J大神都编写了，膜拜大神。 取消订阅 最后别忘了在Activity销毁时对创建的Disposable取消订阅。Demo中的Act都以BaseActivity为基类，所以就无需再调用取消订阅了，BaseActivity已经将这些工作做好了。 总结 RxBinding使用起来非常简单，RxView中还有attaches、detaches，focusChanges，globalLayouts，hovers，touches等等就不一一演示了，码友们可自行尝试。 进阶中的码猿一枚，写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxBindingDemo项目Issues中提出，我会及时回复。 附上Demo的地址： RxBindingDemo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxBinding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2系列实践之倒计时功能(三)]]></title>
    <url>%2F2017%2F11%2F07%2FRxJava2%E7%B3%BB%E5%88%97%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%80%92%E8%AE%A1%E6%97%B6%E5%8A%9F%E8%83%BD(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[前言 通过本系列前两篇的学习，相信各位码友已经基本掌握RxJava2怎么使用了，本篇我们一起来通过一个小例子实践一下，也可以加深印象。来看看如何使用RxJava2的intervalRange操作符实现倒计时功能。 依赖 首先添加依赖，Demo中使用了ButterKnife注入，各版本以当前最新的为准。1234567dependencies &#123; ...... compile 'io.reactivex.rxjava2:rxjava:2.1.3' compile 'io.reactivex.rxjava2:rxandroid:2.0.1' compile 'com.jakewharton:butterknife:8.7.0' annotationProcessor 'com.jakewharton:butterknife-compiler:8.7.0'&#125; intervalRange操作符 别着急上代码，开始前我们先来了解下intervalRange操作符（了解过的可以忽略哈）。 intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit) start：起始数值 count：发射数量 initialDelay：延迟执行时间 period：发射周期时间 unit：时间单位 一句话简介就是延迟initialDelay个unit单位后，以period为周期，依次发射count个以start为初始值并递增的数字。 布局 布局中放一个Button用来演示点击获取验证码，并开启倒计时重新获取的功能。12345678910111213&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:padding="15dp" tools:context="com.holmeslei.rxjava2demo.ui.CountDownActivity"&gt; &lt;Button android:id="@+id/btn_get_code" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="获取验证码" /&gt;&lt;/RelativeLayout&gt; Activity 由于业务逻辑简单，所以就不整什么复杂的框架了，功能都在Activity中实现。 第一步，使用ButterKnife依赖注入获取Button的实例及设置其点击监听方法。 第二步，点击Button后首先将其设置为不可点击，然后初始化全局变量Disposable。 第三步，使用Flowable的intervalRange操作符，从0开始每隔1s发射一个自增的数字，持续11次，延迟0s执行。这样就设定好了10秒的倒计时，可根据实际需要修改时长。 由于需要刷新UI，所以设定观察者执行在Android的UI线程。 在doOnNext的回调中更新Button的显示UI，达到读秒的效果。 在doOnComplete的完成回调中重新将Button设置为可点击，然后设置显示UI。 最后调用后subscribe()订阅，这样一个完整的异步事件流就完成了。 别忘了在Activity销毁时将全局Disposable取消订阅销毁掉。使用RxJava将无用的Disposable及时销毁是一个很好的习惯，否则后期就得忙着处理各种OOM异常啦。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class CountDownActivity extends AppCompatActivity &#123; @BindView(R.id.btn_get_code) Button btnGetCode; private Disposable mdDisposable; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_count_down); ButterKnife.bind(this); &#125; @OnClick(R.id.btn_get_code) public void onViewClicked() &#123; //点击后置为不可点击状态 btnGetCode.setEnabled(false); //从0开始发射11个数字为：0-10依次输出，延时0s执行，每1s发射一次。 mdDisposable = Flowable.intervalRange(0, 11, 0, 1, TimeUnit.SECONDS) .observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; btnGetCode.setText("重新获取(" + (10 - aLong) + ")"); &#125; &#125;) .doOnComplete(new Action() &#123; @Override public void run() throws Exception &#123; //倒计时完毕置为可点击状态 btnGetCode.setEnabled(true); btnGetCode.setText("获取验证码"); &#125; &#125;) .subscribe(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (mdDisposable != null) &#123; mdDisposable.dispose(); &#125; &#125;&#125; 运行效果 最后看一下运行效果Gif。 总结 本篇文章利用RxJava2演示了一个倒计时的小栗子，更多的用法还待各位码友去探索与发现哈。 进阶中的码猿一枚，写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJava2Demo项目Issues中提出，我会及时回复。 附上RxJava2Demo的地址： RxJava2Demo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxJava2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2系列之相较RxJava1的更新之处(二)]]></title>
    <url>%2F2017%2F11%2F05%2FRxJava2%E7%B3%BB%E5%88%97%E4%B9%8B%E7%9B%B8%E8%BE%83RxJava1%E7%9A%84%E6%9B%B4%E6%96%B0%E4%B9%8B%E5%A4%84(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[前言 通过本系列上一篇文章，我们了解了RxJava1中由于被观察者发送事件的速度远快于观察者处理事件的速度导致的背压问题，由此而生出背压策略。虽然RxJava1中有一些操作符支持背压策略，也有一些其他方法，但效果并不太理想。这个问题到了RxJava2中得到了更好地解决。本篇一起来看相较于RxJava1，RxJava2从观察者模式到语法以及线程调度都做了哪些更新。 依赖 首先当然是添加RxJava2与RxAndroid2的依赖啦，以当前最新版本为准。虽然RxAndroid中包含RxJava的内容，但尝试了一下，只引入RxAndroid还是会报错，所以两依赖都加上了。12345dependencies &#123; ...... compile 'io.reactivex.rxjava2:rxjava:2.1.3' compile 'io.reactivex.rxjava2:rxandroid:2.0.1'&#125; 注意：RxJava2与RxJava1的依赖不可共存 观察者模式更新 RxJava2中除了保留了RxJava1中Observable–&gt;Observer观察者模式以外，还新增了一种观察者模式Flowable–&gt;Subscriber。目的为何相信大家已经知道了，新观察者模式可完美支持背压策略。 不了解背压策略的码友欢迎阅读上一篇文章： RxJava2系列之背压策略(一)) 由结构图可见，RxJava2将RxJava1中支持背压与不支持背压的操作符分开了，支持背压的归入Flowable观察者模式中，不支持背压的归入Observable观察者模式中。 来看一个使用range操作符的Flowable示例：123456789101112131415161718192021222324252627Flowable.range(1, 4).subscribe(new Subscriber&lt;Integer&gt;() &#123; Subscription subscription; @Override public void onSubscribe(Subscription s) &#123; Log.e("rx2_test", "onSubscribe"); subscription = s; //这里可进行一些初始化操作 subscription.request(1); &#125; @Override public void onNext(Integer integer) &#123; Log.e("rx2_test", "onNext：" + integer); subscription.request(1); &#125; @Override public void onError(Throwable t) &#123; Log.e("rx2_test", "onError：" + t.getMessage()); &#125; @Override public void onComplete() &#123; Log.e("rx2_test", "onComplete"); &#125;&#125;); 输出结果：123456rx2_test: onSubscriberx2_test: onNext：1rx2_test: onNext：2rx2_test: onNext：3rx2_test: onNext：4rx2_test: onComplete 由示例可以看出Flowable是支持背压策略的，整个数据流是由Subscriber动态去请求，然后Flowable再响应发射事件。订阅之后首先回调onSubscribe()方法，相当于onStart()方法，建议在其中先进行一些初始化的操作然后再调用request(n)请求数据。示例中的Subscription可用于请求数据或在发射过程中满足某些条件时进行取消订阅的操作。 再来看一个使用create操作符的Flowable示例：123456789Flowable.create((FlowableOnSubscribe&lt;Integer&gt;) e -&gt; &#123; e.onNext(1); e.onNext(2); e.onNext(3); e.onNext(4); e.onComplete(); &#125;, BackpressureStrategy.BUFFER) .subscribe(new MySubscription()); 输出结果：123456rx2_test: onSubscriberx2_test: onNext：1rx2_test: onNext：2rx2_test: onNext：3rx2_test: onNext：4rx2_test: onComplete Flowable也可使用create操作符来创建，但需指定背压策略BackpressureStrategy.BUFFER。 除此之外还有几种观察者模式： Single/SingleObserver：订阅后只能接收到一次 Completable/CompletableObserver：只能接收到完成(onComplete)和错误(onError)回调。 Maybe/MaybeObserver：只能接收到一次true或false的数据 这几种观察者模式主要用来判断单一状态，不用来发送大量数据。实际使用频率不高就不一一赘述了。 语法更新 语法更新方面，大部分操作符的用法都未改动，有改动的是RxJava1中ActionN，FuncN等等的包名类名。 Null 经落木语码友的提醒，首先需要注意一个细节变动：RxJava2中不再支持传入null，否则会抛出NullPointerException。 RxJava1中：12//可直接传入nullObservable.just(null); RxJava2中:12//直接传入null会抛出NullPointerExceptionObservable.just(null); 12345//操作符返回null会走onError()回调Observable.just(1) .map(integer -&gt; null) .subscribe(o -&gt; Log.e("test_rxjava", "onNext:" + o.toString()), throwable -&gt; Log.e("test_rxjava", "onError:" + throwable.getMessage())); Action更新 更新内容见图： 用法示例：1234567Flowable.just(1, 2, 3, 4, 5) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.e("rx2_test", "actionChange：" + integer); &#125; &#125;); Func更新 更新内容见图： 用法示例：12345678910111213Flowable.just(1, 2, 3, 4, 5) .map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(@NonNull Integer integer) throws Exception &#123; return "xulei" + integer; &#125; &#125;) .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.e("rx2_test", "funcChange：" + s); &#125; &#125;); 注意：在Rxjava2中，Action与Function的回调方法中都默认throws Exception，可以不进行try-catch的操作。 Subscription更新 Subscription改名为Disposable。由于RxJava2中已经存在了org.reactivestreams.subscription这个类，为了避免名字冲突将原先的rx.Subscription改名为io.reactivex.disposables.Disposable。 CompositeSubscription也改名为CompositeDisposable。 注意：Disposable必须单次使用，用完就要销毁。 需要强调的是，当一个Activity中有多个RxJava异步事件流也就是Disposable时，需要根据事务周期及时进行销毁，否则会导致内存慢慢的，慢慢的……Bang！！！你懂得。那怎么进行集体销毁呢？一起来看下RxJava2中如何实现。1234567891011121314151617181920protected CompositeDisposable mCompositeDisposable;/** * 添加RxJava订阅 */protected void addDisposable(Disposable disposable) &#123; if (mCompositeDisposable == null) &#123; mCompositeDisposable = new CompositeDisposable(); &#125; mCompositeDisposable.add(subscription);&#125;/** * 取消RxJava订阅 */protected void clearDisposable() &#123; if (mCompositeDisposable != null) &#123; mCompositeDisposable.clear(); &#125;&#125; 创建一个CompositeDisposable对象(替代RxJava1中CompositeSubscription)，在实例化RxJava2中的Disposable时可调用其add(Disposable d)将Disposable加入其中。等到Activity销毁或者不需要时便可调用其clear()方法对其中的Disposable进行统一取消订阅并销毁的操作。 使用示例：12345678910111213@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(......); addDisposable(Flowable.just(1, 2, 3, 4, 5) .subscribe((integer -&gt; Log.e("rx2_test", "" + integer))));&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); clearDisposable()&#125; 建议：addSubscribe(Disposable disposable)与clearDisposable()可放入BaseActivity或者MVP架构中的BasePresenter中，便于统一管理，使代码更加简洁。 新增doOnCancel等 RxJava2中除了保留了RxJava1中doOnComplete()，doOnError()，doOnNext()等状态回调之外，还增加了doOnCancel，doOnDispose，unsubscribeOn这几个状态回调，以doOnCancel为例：1234567891011121314Flowable.range(1, 4) .doOnCancel(new Action() &#123; @Override public void run() throws Exception &#123; Log.e("rx2_test", "回调doOnCancel"); &#125; &#125;) .take(2) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.e("rx2_test", "doOnCancel：" + integer); &#125; &#125;); 输出结果：123rx2_test: doOnCancel：1rx2_test: doOnCancel：2rx2_test: 回调doOnCancel 由于.take(2)操作符只截取了前两个事件，之后的事件未被发送，就会回调doOnCancel中的run()方法。 线程调度更新 线程调度这里改动也不大，主要有以下三点： 移除Schedulers.immediate。 移除Schedulers.test。 io.reactivex.Scheduler抽象类支持直接调度自定义线程任务。 总结 本文主要讲解了RxJava2中常用点的更新，更多细节的调整各位码友可以参考官网文档。了解了理论还需勤加练习才能真正掌握RxJava2，下一篇我们将通过一个实际例子来实践一下RxJava2，敬请期待。 进阶中的码猿一枚，写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJava2Demo项目Issues中提出，我会及时回复。 附上RxJava2Demo的地址： RxJava2Demo 注意：本文中插入的图片均为本人原创绘制，引用请标注来源，谢谢。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxJava2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2系列之背压策略(一)]]></title>
    <url>%2F2017%2F10%2F29%2FRxJava2%E7%B3%BB%E5%88%97%E4%B9%8B%E8%83%8C%E5%8E%8B%E7%AD%96%E7%95%A5(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[前言 通过前7篇RxJava的文章，我们对RxJava1.x版本的内容进行了学习与实践。目前RxJava已经更新到2.x了，有小伙伴问我为什么不直接上RxJava2的教程？RxJava2是在1的基础上进行了更新与优化，有很多相通之处，初学者的话建议还是先从RxJava1的基础理论一步步学习。 本系列主要通过与RxJava1比较来学习RxJava2都有哪些改变。而RxJava2中最大的优化之处就在于它解决了RxJava1中未能有效解决的背压(Backpressure)问题。本篇我们就来看看什么是背压，以及RxJava1中是如何解决这个问题。 背压问题 先来个定义：背压问题是指在RxJava观察者模式的异步场景中，由于被观察者生产事件的速度远远快于观察者消费事件的速度，从而导致生产的事件堆积，最后致使内存溢出，程序崩溃。 再上个场景：工厂生产面包，消费者吃面包。工厂生产面包速度慢了，消费者处于等待状态，来一个吃一个，这没什么影响。而如果工厂生产面包的速度过快，导致消费者来不及吃，面包就会累积的越来越多，最后就会过期浪费。 来看代码演示这个问题：123456789101112//被观察者每过1ms发射一个事件Observable.interval(1, TimeUnit.MILLISECONDS) .observeOn(Schedulers.newThread()) .subscribe((aLong) -&gt; &#123; //观察者每过800ms处理一个事件 try &#123; Thread.sleep(800); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.e("rx_test", "back_pressure：" + aLong); &#125;); 以上代码中被观察者发射事件的速度是观察者处理速度的800倍，执行后就会抛出Caused by: rx.exceptions.MissingBackpressureException的异常。背压问题的出现需要两个条件： 观察者与被观察者需处于不同线程。 被观察者产生事件的速度需远快与观察者消费事件的速度。 由于观察者与被观察者处于不同线程，所以RxJava内部使用队列来存储事件，Android中默认队列缓存buffersize为16，所以当事件累计超过16个时就会抛出MissingBackpressureException的异常。解决这种问题就需要对被观察者进行流速控制了，而背压正是应对这种问题的一种策略。 背压策略 背压策略的解决思路便是响应式拉取。与RxJava观察者模型相反，响应式拉取是观察者主动去被观察者那里拉取事件，而被观察者则是被动等待通知再发射事件。 观察者需要多少事件就从被观察者那里拉取，而不是被动接收。这样实际上就实现了控制被观察者的流速，达到了背压策略的目的。 自绘结构图： 再来看一下代码示例：1234567891011121314151617181920212223242526272829303132//range操作符支持背压策略，发送事件的速度可被控制Observable.range(1, 10000) .observeOn(Schedulers.newThread()) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onStart() &#123; //一定要在onStart中通知被观察者先发送一个事件 request(1); &#125; @Override public void onCompleted() &#123; Log.e("rx_test", "reactivePull：onCompleted"); &#125; @Override public void onError(Throwable e) &#123; Log.e("rx_test", "reactivePull：onError：" + e.getMessage()); &#125; @Override public void onNext(Integer n) &#123; try &#123; Thread.sleep(1000); Log.e("rx_test", "reactivePull：onNext：" + n); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //处理完毕之后，再通知被观察者发送下一个事件 request(1); &#125; &#125;); 上述代码示例中，被观察者使用了range操作符发射10000次从1开始自增的数字，在观察者中首先于onStart()中使用request(1)向被观察者请求了第一个事件，之后在onNext()中每延时1000ms后输出日志，处理完事件后再调用request(1)请求一个新的事件。 输出结果：12345678910reactivePull：onNext：1...1s后...reactivePull：onNext：2...1s后...reactivePull：onNext：3...1s后...reactivePull：onNext：4...1s后...reactivePull：onNext：5...... 由输出结果可看出，每过1秒输出了一个数字，是不是实现了背压限流策略呢？需要多少事件就在观察者中使用request(n)主动拉取。不过RxJava1.x版本中并不是所有操作符都支持request(n)的响应式拉取，例如第一个例子中的interval操作符就不支持背压策略。而这个问题到了RxJava2.x中就得到了完美解决，且看下一篇。 其他解决方法 RxJava1中不支持背压策略的操作符如何解决背压问题呢？ 过滤限流 通过使用限流操作符将被观察者产生的大部分事件过滤抛弃掉来达到限流的目的，间接降低事件发射的速度。 sample：在一段时间内,只处理最后一个数据 throttleFirst：在一段时间内,只处理第一个数据 debounce：发送一个数据,开始计时,到了规定时间内,若没有再发送数据,则开始处理数据,反之重新开始计时。 这里以sample操作符为例子：12345//使用sample过滤操作符，每隔300ms取里时间点最近的事件发送Observable.interval(1, TimeUnit.MILLISECONDS) .observeOn(Schedulers.newThread()) .sample(300, TimeUnit.MILLISECONDS) .subscribe((aLong) -&gt; Log.e("rx_test", "controlByFilter：sample：" + aLong)); 输出结果：12345678910controlByFilter：sample：280controlByFilter：sample：577controlByFilter：sample：878controlByFilter：sample：1178controlByFilter：sample：1478controlByFilter：sample：1779controlByFilter：sample：2078controlByFilter：sample：2378controlByFilter：sample：2673...... 这种方式虽然实现了限流，但却是以抛弃大部分事件为代价的，在实际场景中并不可取，大家了解就好。 打包缓存 在被观察者发射事件过快，观察者来不及处理的情况下，可以使用缓存类的操作符将其中一部分打包缓存起来，再一点一点的处理其中的事件。 buffer：将多个事件打包放入一个List中，再一起发射。 window：将多个事件打包放入一个Observable中，再一起发射。 这里以buffer操作符为例：123456789101112//使用buffer过滤操作符，将100ms内的事件打包为list发送Observable.interval(1, TimeUnit.MILLISECONDS) .observeOn(Schedulers.newThread()) .buffer(100, TimeUnit.MILLISECONDS) .subscribe((longs) -&gt; &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.e("rx_test", "controlByCache：buffer：" + longs.size()); &#125;); 输出结果：123456789101112controlByCache：buffer：79controlByCache：buffer：1001controlByCache：buffer：1002controlByCache：buffer：1000controlByCache：buffer：1001controlByCache：buffer：1001controlByCache：buffer：1001controlByCache：buffer：1001controlByCache：buffer：1001controlByCache：buffer：1000controlByCache：buffer：1002controlByCache：buffer：1001 背压操作符 RxJava1.x中，还有两种效果优于以上两种的操作符，可使不支持背压策略的操作符支持背压策略。 onBackpressureDrop：将observable发送的事件抛弃掉，直到subscriber再次调用request(n)方法的时候，就发送给它这之后的n个事件。 onBackpressurebuffer：把observable发送出来的事件做缓存，当request(n)方法被调用的时候，给下层流发送一个item(如果给这个缓存区设置了大小，那么超过了这个大小就会抛出异常)。 以onBackpressureDrop为例：1234567891011121314151617181920212223242526272829303132Observable.interval(1, TimeUnit.MILLISECONDS) .onBackpressureDrop() .observeOn(Schedulers.newThread()) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onStart() &#123; super.onStart(); Log.e("rx_test", "controlBySpecialOperator：" + "onStart"); request(1); &#125; @Override public void onCompleted() &#123; Log.e("rx_test", "controlBySpecialOperator：" + "onCompleted"); &#125; @Override public void onError(Throwable e) &#123; Log.e("rx_test", "controlBySpecialOperator：" + "onError"); &#125; @Override public void onNext(Long aLong) &#123; Log.e("rx_test", "controlBySpecialOperator：onNext：" + aLong); try &#123; Thread.sleep(500); request(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); 输出结果：123456789101112131415161718192021222324252627controlBySpecialOperator：onStartcontrolBySpecialOperator：onNext：0controlBySpecialOperator：onNext：1controlBySpecialOperator：onNext：2controlBySpecialOperator：onNext：3controlBySpecialOperator：onNext：4controlBySpecialOperator：onNext：5controlBySpecialOperator：onNext：6controlBySpecialOperator：onNext：7controlBySpecialOperator：onNext：8controlBySpecialOperator：onNext：9controlBySpecialOperator：onNext：10controlBySpecialOperator：onNext：11controlBySpecialOperator：onNext：12controlBySpecialOperator：onNext：13controlBySpecialOperator：onNext：14controlBySpecialOperator：onNext：15controlBySpecialOperator：onNext：8014controlBySpecialOperator：onNext：8015controlBySpecialOperator：onNext：8016controlBySpecialOperator：onNext：8017controlBySpecialOperator：onNext：8018controlBySpecialOperator：onNext：8019controlBySpecialOperator：onNext：8020controlBySpecialOperator：onNext：8021controlBySpecialOperator：onNext：8022...... 首先输出了0-15的数据，是因为observeOn操作符内部有一个长度为16的缓存区，它会首先请求16个事件缓存起来再输出。使用onBackpressureDrop可使不支持背压的操作符也可响应观察者的request(n)。 注意：需调用.onBackpressureDrop()方法。 总结 以上就是本篇关于RxJava1中存在的背压问题，背压策略的使用方法以及其他解决方法的讲解。背压在实际开发中遇到的不多，除非是大量数据，所以各位码友了解一下就好。本篇旨在为引入正式的Rxjava2做一个铺垫，敬请期待下一篇。 进阶中的码猿一枚，写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。 附上RxJavaDemo的地址： RxJavaDemo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxJava2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava终章之实践出真知(七)]]></title>
    <url>%2F2017%2F10%2F20%2FRxJava%E7%BB%88%E7%AB%A0%E4%B9%8B%E5%AE%9E%E8%B7%B5%E5%87%BA%E7%9C%9F%E7%9F%A5(%E4%B8%83)%2F</url>
    <content type="text"><![CDATA[前言 到本阶段，相信各位码友对RxJava的原理及操作符的使用方法已经基本掌握了。只是了解理论知识对于咱们程序猴来说当然远远不够，理论运用到实践才能出真知。一起来律动指尖到实际场景中看看怎么运用RxJava。本篇我们演示一下如何运用RxJava从手机中获取已安装的第三方应用并通过RecyclerView展示出来。 准备工作项目下build.gradle123456789buildscript &#123; ...... dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.2' //ButterKnife支持 classpath 'com.jakewharton:butterknife-gradle-plugin:8.7.0' &#125;&#125;...... app下build.gradle12345678910111213141516171819202122232425262728293031apply plugin: 'com.android.application'apply plugin: 'com.jakewharton.butterknife'android &#123; ...... defaultConfig &#123; ...... //Lambda支持 jackOptions &#123; enabled true &#125; &#125; //Lambda支持 compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125; ......&#125;dependencies &#123; ...... //RxJava支持 compile 'io.reactivex:rxjava:1.0.14' compile 'io.reactivex:rxandroid:1.0.1' //RecyclerView支持 compile 'com.android.support:recyclerview-v7:25.3.1' //ButterKnife支持 compile 'com.jakewharton:butterknife:8.7.0' annotationProcessor 'com.jakewharton:butterknife-compiler:8.7.0'&#125; 布局主布局 主布局没啥好说的，就是一个RecyclerView。123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.holmeslei.rxjavademo.ui.PracticeActivity&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/rv_app_list" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/RelativeLayout&gt; RecyclerView的Item布局 RecyclerView单个条目布局，我们需要一个ImageView及一个TextView用来展示每个应用的图标及名称。123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="80dp" android:paddingLeft="20dp"&gt; &lt;ImageView android:id="@+id/item_iv_head" android:layout_width="50dp" android:layout_height="50dp" android:layout_centerVertical="true" android:scaleType="fitXY" android:src="@mipmap/ic_launcher" /&gt; &lt;TextView android:id="@+id/item_iv_app_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerVertical="true" android:layout_marginLeft="30dp" android:layout_toRightOf="@+id/item_iv_head" android:text="微信" android:textColor="#555555" android:textSize="18sp" /&gt; &lt;/RelativeLayout&gt;&lt;/RelativeLayout&gt; Java代码实体类12345678910111213141516171819202122232425262728public class AppInfo &#123; private String appName; //应用名称 private Drawable appIcon; //应用图标 public String getAppName() &#123; return appName; &#125; public void setAppName(String appName) &#123; this.appName = appName; &#125; public Drawable getAppIcon() &#123; return appIcon; &#125; public void setAppIcon(Drawable appIcon) &#123; this.appIcon = appIcon; &#125; @Override public String toString() &#123; return "AppInfo&#123;" + "appName='" + appName + '\'' + ", appIcon=" + appIcon + '&#125;'; &#125;&#125; RecyclerView适配器12345678910111213141516171819202122232425262728293031323334353637383940public class AppInfoListAdapter extends RecyclerView.Adapter&lt;AppInfoListAdapter.MyViewHolder&gt; &#123; private Context context; private List&lt;AppInfo&gt; appInfoList; public AppInfoListAdapter(Context context, List&lt;AppInfo&gt; appInfoList) &#123; this.context = context; this.appInfoList = appInfoList; &#125; @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(context).inflate(R.layout.item_app_list, parent, false); return new MyViewHolder(view); &#125; @Override public void onBindViewHolder(MyViewHolder holder, int position) &#123; //设置应用图标 holder.ivHead.setImageDrawable(appInfoList.get(position).getAppIcon()); //设置应用名称 holder.tvAppName.setText(appInfoList.get(position).getAppName()); &#125; @Override public int getItemCount() &#123; return appInfoList.size(); &#125; class MyViewHolder extends RecyclerView.ViewHolder &#123; @BindView(R.id.item_iv_head) ImageView ivHead; @BindView(R.id.item_iv_app_name) TextView tvAppName; MyViewHolder(View itemView) &#123; super(itemView); ButterKnife.bind(this, itemView); &#125; &#125;&#125; Activity 核心来了，我们重点看initData()方法。分析一下需求，要获取手机中已安装的第三方应用并展示出来，主要分以下几步： 1. 从系统中获取所有应用列表数据的集合List&lt;ApplicationInfo&gt;。 2. 这个集合是已安装的所有应用集合，我们只需要其中的第三方应用，所以要使用到RxJava的filter操作符进行过滤。 3. 由于ApplicationInfo不满足我们的需求，需要将其转换为我们自定义的实体类AppInfo，所以要使用到RxJava的map操作符进行转换。 4. 由于获取应用集合，过滤，转换的过程可能是耗时的，我们需要指定Observable运行在io线程。 5. 由于获取到满足条件的数据后我们还需刷新UI进行展示，所以还需要指定Observer运行在Android的UI线程。 6. 最后还需要输出错误日志，及完成之后的刷新UI，所以需要重写RxJava错误状态及完成状态的回调方法。 了解的整个实现流程，接下来上代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class PracticeActivity extends AppCompatActivity &#123; @BindView(R.id.rv_app_list) RecyclerView rvAppList; private AppInfoListAdapter adapter; private List&lt;AppInfo&gt; appInfoList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_practice); ButterKnife.bind(this); initRecyclerView(); initData(); &#125; /** * 初始化RecyclerView */ private void initRecyclerView() &#123; LinearLayoutManager manager = new LinearLayoutManager(this); rvAppList.setLayoutManager(manager); adapter = new AppInfoListAdapter(this, appInfoList); rvAppList.setAdapter(adapter); &#125; /** * 初始化数据 */ private void initData() &#123; final PackageManager pm = getPackageManager(); //获取所有应用信息集合 List&lt;ApplicationInfo&gt; infoList = pm.getInstalledApplications(PackageManager.GET_UNINSTALLED_PACKAGES); Observable.from(infoList) //过滤出已安装的第三方应用 .filter(new Func1&lt;ApplicationInfo, Boolean&gt;() &#123; @Override public Boolean call(ApplicationInfo applicationInfo) &#123; return (applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) &lt;= 0; &#125; &#125;) //转换为自定义的AppInfo类 .map(new Func1&lt;ApplicationInfo, AppInfo&gt;() &#123; @Override public AppInfo call(ApplicationInfo applicationInfo) &#123; AppInfo appInfo = new AppInfo(); appInfo.setAppIcon(applicationInfo.loadIcon(pm)); appInfo.setAppName(applicationInfo.loadLabel(pm).toString()); return appInfo; &#125; &#125;) //Observable被观察者执行在io线程 .subscribeOn(Schedulers.io()) //Observer观察者执行在AndroidUI线程 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;AppInfo&gt;() &#123; @Override public void onCompleted() &#123; //更新列表UI adapter.notifyDataSetChanged(); &#125; @Override public void onError(Throwable e) &#123; //显示错误信息 Toast.makeText(PracticeActivity.this, e.getMessage(), Toast.LENGTH_LONG).show(); &#125; @Override public void onNext(AppInfo appInfo) &#123; //添加第三方应用数据到集合 appInfoList.add(appInfo); &#125; &#125;);&#125; Lambda简化 还记得我在RxJava系列第一篇中提到过吗？RxJava可结合Lambda表达式达到简化代码的作用，来看一下简化之后的代码：12345678910111213141516171819202122/** * 初始化数据 */ private void initData() &#123; final PackageManager pm = getPackageManager(); List&lt;ApplicationInfo&gt; infoList = pm.getInstalledApplications(PackageManager.GET_UNINSTALLED_PACKAGES); Observable.from(infoList) .filter(applicationInfo -&gt; (applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) &lt;= 0) .map(applicationInfo -&gt; &#123; AppInfo appInfo = new AppInfo(); appInfo.setAppIcon(applicationInfo.loadIcon(pm)); appInfo.setAppName(applicationInfo.loadLabel(pm).toString()); return appInfo; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe( appInfo -&gt; appInfoList.add(appInfo), throwable -&gt; Toast.makeText(PracticeActivity.this, throwable.getMessage(), Toast.LENGTH_LONG).show(), () -&gt; adapter.notifyDataSetChanged() );&#125; 是不是看起来清爽简洁呢？不太了解Lambda表达式的码友可跳转到我的另一篇讲解Lambda表达式的文章： Lambda表达式基本语法与应用 运行效果 总结 到此，RxJava系列从理论到运用再到实践，整个过程我们通过了7篇文章来学习。然而RxJava的知识远远不止这些，这就需要各位码友去探索发掘了。本系列只是达到入门RxJava的程度，且是基于RxJava1.0版本进行讲解的。目前RxJava已经更新到了2.0+，与1.0版本也有不小的改动与优化的地方。后期我会专门对RxJava2.x有何改动开一篇文章进行讲解，敬请期待。 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。 附上RxJavaDemo的地址： RxJavaDemo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符之组合操作符(六)]]></title>
    <url>%2F2017%2F10%2F18%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B%E7%BB%84%E5%90%88%E6%93%8D%E4%BD%9C%E7%AC%A6(%E5%85%AD)%2F</url>
    <content type="text"><![CDATA[前言 上一篇文章我们学习了过滤类操作符，本篇我们将一起来学习RxJava组合类操作符。组合操作符主要是用来同时处理多个Observable，将他们进行组合创建出新的满足我们需求的Observable，一起来看下都有哪些。 组合操作符Merge merge操作符，将两个Observable要发射的观测序列合并为一个序列进行发射。按照两个序列每个元素的发射时间先后进行排序，同一时间点发射的元素则是无序的。1234567891011121314151617181920//将一个发送字母的Observable与发送数字的Observable合并发射final String[] words = new String[]&#123;"A", "B", "C", "D", "E", "F", "G", "H", "I"&#125;;//字母Observable，每200ms发射一次Observable&lt;String&gt; wordSequence = Observable.interval(200, TimeUnit.MILLISECONDS) .map(new Func1&lt;Long, String&gt;() &#123; @Override public String call(Long position) &#123; return words[position.intValue()]; &#125; &#125;) .take(words.length);//数字Observable，每500ms发射一次Observable&lt;Long&gt; numberSequence = Observable.interval(500, TimeUnit.MILLISECONDS).take(4);Observable.merge(wordSequence, numberSequence) .subscribe(new Action1&lt;Serializable&gt;() &#123; @Override public void call(Serializable serializable) &#123; Log.e("rx_test", "merge：" + serializable.toString()); &#125; &#125;); 输出结果：12345678910111213merge：Amerge：Bmerge：0merge：Cmerge：Dmerge：Emerge：1merge：Fmerge：Gmerge：2merge：Hmerge：Imerge：3 原理图： merge操作符还有一种入参merge(Observable[]),可传入含有多个Observable的集合，merge操作符也可将这多个Observable的序列合并后发射。 MergeDelayError mergeDelayError操作符，与merge功能类似，都是用来合并Observable的。不同之处在于mergeDelayError操作符在合并过程中发生异常的话不会立即停止合并，而会在所有元素合并发射完毕之后再发射异常。但发生异常的那个Observable就不会发射数据了。1234567891011121314151617181920212223242526272829303132//字母Observable，每200ms发射一次，模拟过程中产生一个异常Observable&lt;String&gt; wordSequence = Observable.interval(200, TimeUnit.MILLISECONDS) .map(new Func1&lt;Long, String&gt;() &#123; @Override public String call(Long position) &#123; Long cache = position; if (cache == 3) &#123; cache = cache / 0; &#125; return words[position.intValue()]; &#125; &#125;) .take(words.length);//数字Observable，每500ms发射一次Observable&lt;Long&gt; numberSequence = Observable.interval(500, TimeUnit.MILLISECONDS).take(4);Observable.mergeDelayError(wordSequence, numberSequence) .subscribe(new Action1&lt;Serializable&gt;() &#123; @Override public void call(Serializable serializable) &#123; Log.e("rx_test", "mergeDelayError：" + serializable.toString()); &#125; &#125;, new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable throwable) &#123; Log.e("rx_test", "mergeDelayError：" + throwable.getMessage()); &#125; &#125;, new Action0() &#123; @Override public void call() &#123; Log.e("rx_test", "mergeDelayError：onComplete"); &#125; &#125;); 输出结果：12345678mergeDelayError：AmergeDelayError：BmergeDelayError：0mergeDelayError：CmergeDelayError：1mergeDelayError：2mergeDelayError：3mergeDelayError：divide by zero 由输出结果可看出，wordSequence在发射到C时抛出了一个异常，停止发射其剩下的数据，但合并没有停止。合并完成之后这个异常才被发射了出来。 原理图： Concat concat操作符，将多个Obserbavle发射的数据进行合并后发射，类似于merge操作符。但concat操作符是将Observable依次发射，是有序的。12345678910Observable&lt;String&gt; wordSequence = Observable.just("A", "B", "C", "D", "E");Observable&lt;Integer&gt; numberSequence = Observable.just(1, 2, 3, 4, 5);Observable&lt;String&gt; nameSequence = Observable.just("Sherlock", "Holmes", "Xu", "Lei");Observable.concat(wordSequence, numberSequence, nameSequence) .subscribe(new Action1&lt;Serializable&gt;() &#123; @Override public void call(Serializable serializable) &#123; Log.e("rx_test", "concat：" + serializable.toString()); &#125; &#125;); 输出结果：1234567891011121314concat：Aconcat：Bconcat：Cconcat：Dconcat：Econcat：1concat：2concat：3concat：4concat：5concat：Sherloconcat：Holmesconcat：Xuconcat：Lei 原理图： Zip zip(Observable, Observable, Func2)操作符，根据Func2中的call()方法规则合并两个Observable的数据项并发射。 注意：若其中一个Observable数据发送结束或出现异常后，另一个Observable也会停止发射数据。12345678910111213Observable&lt;String&gt; wordSequence = Observable.just("A", "B", "C", "D", "E");Observable&lt;Integer&gt; numberSequence = Observable.just(1, 2, 3, 4, 5, 6);Observable.zip(wordSequence, numberSequence, new Func2&lt;String, Integer, String&gt;() &#123; @Override public String call(String s, Integer integer) &#123; return s + integer; &#125;&#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e("rx_test", "zip：" + s); &#125;&#125;); 输出结果：12345zip：A1zip：B2zip：C3zip：D4zip：E5 由输出结果可看出numberSequence观测序列最后的6并没有发射出来，由于wordSequence观测序列已发射完所有数据，所以组合序列也停止发射数据了。 原理图： StartWith startWith操作符，用于在源Observable发射的数据前，插入指定的数据并发射。12345678Observable.just(4, 5, 6, 7) .startWith(1, 2, 3) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.e("rx_test", "startWith：" + integer); &#125; &#125;); 输出结果：1234567startWith：1startWith：2startWith：3startWith：4startWith：5startWith：6startWith：7 原理图： startWith还有两种入参： startWith(Iterable)：可在源Observable发射的数据前插入Iterable数据并发射。 startWith(Observable)：可在源Observable发射的数据前插入另一Observable发射的数据并发射。 SwitchOnNext switchOnNext操作符，用来将一个发射多个小Observable的源Observable转化为一个Observable，然后发射多个小Observable所发射的数据。若小Observable正在发射数据时，源Observable又发射了新的小Observable，则前一个小Observable还未发射的数据会被抛弃，直接发射新的小Observable所发射的数据，上例子。1234567891011121314151617181920212223//每隔500ms产生一个ObservableObservable&lt;Observable&lt;Long&gt;&gt; observable = Observable.interval(500, TimeUnit.MILLISECONDS) .map(new Func1&lt;Long, Observable&lt;Long&gt;&gt;() &#123; @Override public Observable&lt;Long&gt; call(Long aLong) &#123; //每隔200毫秒产生一组数据（0,10,20,30,40) return Observable.interval(200, TimeUnit.MILLISECONDS) .map(new Func1&lt;Long, Long&gt;() &#123; @Override public Long call(Long aLong) &#123; return aLong * 10; &#125; &#125;).take(5); &#125; &#125;).take(2); Observable.switchOnNext(observable) .subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; Log.e("rx_test", "switchOnNext：" + aLong); &#125; &#125;); 输出结果：1234567switchOnNext：0switchOnNext：10switchOnNext：0switchOnNext：10switchOnNext：20switchOnNext：30switchOnNext：40 由输出结果发现第一个小Observable打印到10则停止了发射数据，说明其发射到10时，新的小Observable被创建了出来，第一个小Observable则被中断发射，开始发射新的小Observable的数据。 原理图： CombineLatest combineLatest操作符，用于将两个Observale最近发射的数据以Func2函数的规则进行组合并发射。12345678910111213141516171819202122232425//引用merge的例子final String[] words = new String[]&#123;"A", "B", "C", "D", "E", "F", "G", "H", "I"&#125;;Observable&lt;String&gt; wordSequence = Observable.interval(300, TimeUnit.MILLISECONDS) .map(new Func1&lt;Long, String&gt;() &#123; @Override public String call(Long position) &#123; return words[position.intValue()]; &#125; &#125;) .take(words.length);Observable&lt;Long&gt; numberSequence = Observable.interval(500, TimeUnit.MILLISECONDS) .take(5);Observable.combineLatest(wordSequence, numberSequence, new Func2&lt;String, Long, String&gt;() &#123; @Override public String call(String s, Long aLong) &#123; return s + aLong; &#125; &#125;) .subscribe(new Action1&lt;Serializable&gt;() &#123; @Override public void call(Serializable serializable) &#123; Log.e("rx_test", "combineLatest：" + serializable.toString()); &#125; &#125;); 输出结果：12345678910111213combineLatest：A0combineLatest：B0combineLatest：C0combineLatest：C1combineLatest：D1combineLatest：E1combineLatest：E2combineLatest：F2combineLatest：F3combineLatest：G3combineLatest：H3combineLatest：H4combineLatest：I4 如果将wordSequence与numberSequence的入参顺序互换，输出结果也会不同：12345678910111213combineLatest：0AcombineLatest：0BcombineLatest：0CcombineLatest：1CcombineLatest：1DcombineLatest：2DcombineLatest：2EcombineLatest：2FcombineLatest：3FcombineLatest：3GcombineLatest：3HcombineLatest：4HcombineLatest：4I wordSequence每300ms发射一个字符，numberSequence每500ms发射一个数字。可能有些码友不知道这个输出结果怎么来的，这个操作符确实不太好理解。我们来看一下这个原理图就很清楚了。 原理图： Join join(Observable, Func1, Func1, Func2)操作符，类似于combineLatest操作符，用于将ObservableA与ObservableB发射的数据进行排列组合。但join操作符可以控制Observable发射的每个数据的生命周期，在每个发射数据的生命周期内，可与另一个Observable发射的数据按照一定规则进行合并，来看下join的几个入参。 Observable：需要与源Observable进行组合的目标Observable。 Func1：接收从源Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了源Obsrvable发射出来的数据的有效期； Func1：接收目标Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了目标Obsrvable发射出来的数据的有效期； Func2：接收从源Observable和目标Observable发射出来的数据，并将这两个数据按自定的规则组合后返回。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//产生字母的序列,周期为1000msString[] words = new String[]&#123;"A", "B", "C", "D", "E", "F", "G", "H"&#125;;Observable&lt;String&gt; observableA = Observable.interval(1000, TimeUnit.MILLISECONDS) .map(new Func1&lt;Long, String&gt;() &#123; @Override public String call(Long aLong) &#123; return words[aLong.intValue()]; &#125; &#125;).take(8);//产0,1,2,3,4,5,6,7的序列,延时500ms发射,周期为1000msObservable&lt;Long&gt; observableB = Observable.interval(500, 1000, TimeUnit.MILLISECONDS) .map(new Func1&lt;Long, Long&gt;() &#123; @Override public Long call(Long aLong) &#123; return aLong; &#125; &#125;).take(words.length);//joinobservableA.join(observableB, new Func1&lt;String, Observable&lt;Long&gt;&gt;() &#123; @Override public Observable&lt;Long&gt; call(String s) &#123; //ObservableA发射的数据有效期为600ms return Observable.timer(600, TimeUnit.MILLISECONDS); &#125; &#125;, new Func1&lt;Long, Observable&lt;Long&gt;&gt;() &#123; @Override public Observable&lt;Long&gt; call(Long aLong) &#123; //ObservableB发射的数据有效期为600ms return Observable.timer(600, TimeUnit.MILLISECONDS); &#125; &#125;, new Func2&lt;String, Long, String&gt;() &#123; @Override public String call(String s, Long aLong) &#123; return s + aLong; &#125; &#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e("rx_test", "join：" + s); &#125;&#125;); join操作符的组合方式类似于数学上的排列组合规则，以ObservableA为基准源Observable，按照其自身周期发射数据，且每个发射出来的数据都有其有效期。而ObservableB每发射出来一个数据，都与A发射出来的并且还在有效期内的数据按Func2函数中的规则进行组合，B发射出来的数据也有其有效期。最后再将结果发射给观察者进行处理。 输出结果：123456789101112131415join：A0join：A1join：B1join：B2join：C2join：C3join：D3join：D4join：E4join：E5join：F5join：F6join：G6join：G7join：H7 原理图： GroupJoin groupJoin操作符，类似于join操作符，区别在于第四个参数Func2的传入函数不同，对join之后的结果包装了一层小的Observable，便于用户再次进行一些过滤转换等操作再发射给Observable。1234567891011121314151617181920212223242526272829303132333435observableA.groupJoin(observableB, new Func1&lt;String, Observable&lt;Long&gt;&gt;() &#123; @Override public Observable&lt;Long&gt; call(String s) &#123; return Observable.timer(600, TimeUnit.MILLISECONDS); &#125; &#125;, new Func1&lt;Long, Observable&lt;Long&gt;&gt;() &#123; @Override public Observable&lt;Long&gt; call(Long aLong) &#123; return Observable.timer(600, TimeUnit.MILLISECONDS); &#125; &#125;, new Func2&lt;String, Observable&lt;Long&gt;, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call(final String s, Observable&lt;Long&gt; longObservable) &#123; return longObservable.map(new Func1&lt;Long, String&gt;() &#123; @Override public String call(Long aLong) &#123; return s + aLong; &#125; &#125;); &#125; &#125;) .subscribe(new Action1&lt;Observable&lt;String&gt;&gt;() &#123; @Override public void call(Observable&lt;String&gt; stringObservable) &#123; stringObservable.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e("rx_test", "groupJoin：" + s); &#125; &#125;); &#125; &#125;); 输出结果：123456789101112131415groupJoin：A0groupJoin：A1groupJoin：B1groupJoin：B2groupJoin：C2groupJoin：C3groupJoin：D3groupJoin：D4groupJoin：E4groupJoin：E5groupJoin：F5groupJoin：F6groupJoin：G6groupJoin：G7groupJoin：H7 原理图： 总结 到此，本篇关于RxJava的常用组合类操作符就讲解完毕了。通过以上四篇文章对RxJava四类操作符的学习，相信大家已经基本掌握RxJava如何使用了。实践是检验真理的唯一标准，下一篇我们来一起上项目看看实践中如何使用RxJava。 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。 附上RxJavaDemo的地址： RxJavaDemo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符之过滤操作符(五)]]></title>
    <url>%2F2017%2F10%2F16%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E7%AC%A6(%E4%BA%94)%2F</url>
    <content type="text"><![CDATA[前言 上一篇文章我们学习了转换类操作符，本篇我们将一起来学习RxJava过滤类操作符。过滤操作符主要是用来对事件数据进行过滤与筛选，只返回满足条件的数据，一起来看下都有哪些。 过滤操作符Filter filter操作符，按照一定的约束条件过滤序列中我们不想要的数据，只返回满足条件的数据给观察者。1234567891011121314151617181920//结合flatmap，过滤出各小区中房源大小大于120平的房子Observable.from(communities) .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.getHouses()); &#125; &#125;) .filter(new Func1&lt;House, Boolean&gt;() &#123; @Override public Boolean call(House house) &#123; return house.getSize() &gt; 120f; &#125; &#125;) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; Log.e("rx_test", "filter：大于120平的房子：" + house.getCommunityName() + "小区，大小：" + house.getSize()); &#125; &#125;); 由代码可见，我们需要new一个Func1对象给filter()，Func1&lt;House, Boolean&gt;()中第一个是由观测序列传入数据的类型，第二个是返回是否过滤的Boolean对象。满足filter()的条件则返回true，否则返回false。并将返回为true的数据发射给观察者。 输出结果：1234567filter：大于120平的房子：东方花园小区，大小：144.8filter：大于120平的房子：东方花园小区，大小：144.8filter：大于120平的房子：马德里春天小区，大小：123.4filter：大于120平的房子：马德里春天小区，大小：123.4filter：大于120平的房子：帝豪家园小区，大小：188.7filter：大于120平的房子：帝豪家园小区，大小：188.7filter：大于120平的房子：帝豪家园小区，大小：188.7 原理图： 实际项目开发中，filter操作符可用来过滤数据集合中的null值，方便实用。 Take take(int count)操作符，可用来截取观测序列中前count个元素并发射。123456789//take：获取前两个小区名Observable.from(communities) .take(2) .subscribe(new Action1&lt;Community&gt;() &#123; @Override public void call(Community community) &#123; Log.e("rx_test", "take：前两个小区：" + community.getCommunityName()); &#125; &#125;); 输出结果：12take：前两个小区：东方花园take：前两个小区：马德里春天 原理图： TakeLast takeLast(int count)操作符，顾名思义，截取观测序列中后count个元素并发射。123456789//takeLast：获取后两个小区名Observable.from(communities) .takeLast(2) .subscribe(new Action1&lt;Community&gt;() &#123; @Override public void call(Community community) &#123; Log.e("rx_test", "takeLast：后两个小区：" + community.getCommunityName()); &#125; &#125;); 输出结果：12takeLast：后两个小区：马德里春天takeLast：后两个小区：帝豪家园 原理图： TakeUntil takeUntil操作符有两种类型的入参。 1.takeUntil(Observable) 订阅并开始发射原始Observable，同时监视我们提供的第二个Observable。如果第二个Observable发射了一项数据或者发射了一个终止通知，takeUntil()返回的Observable会停止发射原始Observable并终止。123456789101112131415161718192021//observableA每300ms发射一个Long型自增数据//observableB每800ms发射一个Long型自增数据Observable&lt;Long&gt; observableA = Observable.interval(300, TimeUnit.MILLISECONDS);Observable&lt;Long&gt; observableB = Observable.interval(800, TimeUnit.MILLISECONDS);observableA.takeUntil(observableB) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; Log.e("rx_test", "takeUntil(Observable)：" + "onCompleted"); &#125; @Override public void onError(Throwable e) &#123; Log.e("rx_test", "takeUntil(Observable)：onError：" + e.getMessage()); &#125; @Override public void onNext(Long aLong) &#123; Log.e("rx_test", "takeUntil(Observable)：onNext：" + aLong); &#125; &#125;); 输出结果：123takeUntil(Observable)：onNext：0takeUntil(Observable)：onNext：1takeUntil(Observable)：onCompleted 由输出结果可看出，订阅之后，observableA依次发射0，1之后就发射onCompleted标记停止了。这是由于observableA每300ms发射一次，当发射完1后，时间已过去600ms，到800ms时observableB开始发射数据，takeUntil起作用则中断了observableA的发射。 原理图： 2.takeUntil(Func1) 通过传入的Func1中的call()方法判断是否中止发射数据。1234567891011121314151617181920//takeUntil：与flatmap结合过滤直到房价大于500时中断当前小Observable发射HouseObservable.from(communities) .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.getHouses()); &#125; &#125;) .takeUntil(new Func1&lt;House, Boolean&gt;() &#123; @Override public Boolean call(House house) &#123; return house.getPrice() &gt; 500; &#125; &#125;) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; Log.e("rx_test", "takeUntil：大于500时中断发射：" + house.getCommunityName() + "小区，房价：" + house.getPrice()); &#125; &#125;); 输出结果：12takeUntil(Func1)：大于500时中断发射：东方花园小区，房价：200takeUntil(Func1)：大于500时中断发射：东方花园小区，房价：520 原理图： TakeWhile takeWhile操作符，类似于takeUntil(Func1)，不过takeWhile()是当Observable发射的数据不满足条件时中止Observable的发射。1234567891011121314//takeWhile：当发射的数据等于3时中止发射Observable.just(1, 2, 3, 4, 5) .takeWhile(new Func1&lt;Integer, Boolean&gt;() &#123; @Override public Boolean call(Integer integer) &#123; return integer != 3; &#125; &#125;) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.e("rx_test", "takeWhile：" + integer); &#125; &#125;); 输出结果：12takeWhile：1takeWhile：2 原理图： Skip skip(int count)操作符，忽略发射观测序列的前count项数据。123456789//忽略前两个小区数据Observable.from(communities) .skip(2) .subscribe(new Action1&lt;Community&gt;() &#123; @Override public void call(Community community) &#123; Log.e("rx_test", "skip：忽略前两个小区：" + community.getCommunityName()); &#125; &#125;); 输出结果：1skip：忽略前两个小区：帝豪家园 原理图： SkipLast skipLast(int count)操作符，忽略发射观测序列的后count项数据。123456789//忽略后两个小区数据Observable.from(communities) .skipLast(2) .subscribe(new Action1&lt;Community&gt;() &#123; @Override public void call(Community community) &#123; Log.e("rx_test", "skip：忽略后两个小区：" + community.getCommunityName()); &#125; &#125;); 输出结果：1忽略后两个小区：东方花园 原理图： SkipUntil skipUntil操作符，与takeUntil()相反。订阅并开始发射原始Observable，同时监视我们提供的第二个Observable。如果第二个Observable发射了一项数据或者发射了一个终止通知，skipUntil()返回的Observable才会开始发射数据，忽略之前的数据项。 原理图： SkipWhile skipWhile操作符，与takeWhile相反，当Observable发射的数据不满足条件时才开始发射数据，忽略之前的数据项。 原理图： Debounce debounce操作符有两种类型的入参。 1.debounce(long, TimeUnit) 过滤由Observable发射的速率过快的数据，起到限流的作用。第一个参数为限流时间，第二个参数为时间单位。123456789101112131415161718192021222324252627282930Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; try &#123; for (int i = 1; i &lt; 10; i++) &#123; subscriber.onNext(i); Thread.sleep(i * 100); //分别延时100，200，300，400，500......900ms发射数据 &#125; subscriber.onCompleted(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;).subscribeOn(Schedulers.newThread()) .debounce(400, TimeUnit.MILLISECONDS) .subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; Log.e("rx_test", "debounce：" + "onCompleted"); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Integer integer) &#123; Log.e("rx_test", "debounce：" + integer); &#125; &#125;); 输出结果：123456debounce：5debounce：6debounce：7debounce：8debounce：9debounce：onCompleted 由输出结果可以看出由于设定限流时间为500ms，所以1-4并没有被发射而是被过滤了。 注意：如果源Observable产生的最后一个结果在限流时间内内调用了onCompleted，那么通过debounce操作符也会把这个结果提交给订阅者。 原理图： 2.debounce(Func1) 根据Func1的call方法中的函数来过滤。Func1中的中的call方法返回了一个临时的Observable，如果原始的Observable在发射一个新的数据时，上一个数据根据Func1的call方法生成的临时Observable还没结束，那么上一个数据就会被过滤掉。 原理图： Distinct 1.distinct() 只允许还没有发射过的数据通过，达到去除序列中重复项的作用。123456789//去除重复数字Observable.just(1, 2, 2, 3, 4, 5, 6, 6, 6, 7) .distinct() .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.e("rx_test", "distinct：去重：" + integer); &#125; &#125;); 输出结果：1234567distinct：去重：1distinct：去重：2distinct：去重：3distinct：去重：4distinct：去重：5distinct：去重：6distinct：去重：7 由输出结果可见有重复的2和6都被过滤了。 原理图： 2.distinct(Func1) 根据Func1中的call方法进行去重，call方法会根据Observable发射的值生成一个Key，然后比较这个key来判断两个数据是否相同，如果判定为重复则会和distinct()一样过滤掉重复的数据项。1234567891011121314151617181920//根据某属性去重，去除各小区大小相同的房源Observable.from(communities) .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.getHouses()); &#125; &#125;) .distinct(new Func1&lt;House, Float&gt;() &#123; @Override public Float call(House house) &#123; return house.getSize(); &#125; &#125;) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; Log.e("rx_test", "distinct(Func1)：去重：" + house.getCommunityName() + "小区，大小：" + house.getSize()); &#125; &#125;); 输出结果：123456distinct(Func1)：去重：东方花园小区，大小：105.6distinct(Func1)：去重：东方花园小区，大小：144.8distinct(Func1)：去重：马德里春天小区，大小：88.6distinct(Func1)：去重：马德里春天小区，大小：123.4distinct(Func1)：去重：帝豪家园小区，大小：188.7distinct(Func1)：去重：帝豪家园小区，大小：56.4 DistinctUntilChanged 1.distinctUntilChanged() 通过当前数据项与前一项是否相同来进行去重。123456789//向前去重复数据Observable.just(1, 2, 2, 3, 4, 2, 3, 5, 5) .distinctUntilChanged() .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.e("rx_test", "distinctUntilChanged：向前去重：" + integer); &#125; &#125;); 输出结果：1234567distinctUntilChanged：向前去重：1distinctUntilChanged：向前去重：2distinctUntilChanged：向前去重：3distinctUntilChanged：向前去重：4distinctUntilChanged：向前去重：2distinctUntilChanged：向前去重：3distinctUntilChanged：向前去重：5 原理图： 2.distinctUntilChanged(Func1) 与distinct(Func1)类似，根据Func1中call方法产生一个key来判断相邻两个数据项是否相同。1234567891011121314151617181920//根据某属性向前去重，去除各小区名相同的房源Observable.from(communities) .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.getHouses()) .distinctUntilChanged(new Func1&lt;House, String&gt;() &#123; @Override public String call(House house) &#123; return house.getCommunityName(); &#125; &#125;); &#125; &#125;) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; Log.e("rx_test", "distinctUntilChanged(Func1)：向前去重：" + house.getCommunityName() + "小区，大小：" + house.getSize()); &#125; &#125;); 输出结果：123distinctUntilChanged(Func1)：向前去重：东方花园小区，大小：105.6distinctUntilChanged(Func1)：向前去重：马德里春天小区，大小：88.6distinctUntilChanged(Func1)：向前去重：帝豪家园小区，大小：188.7 ElementAt elementAt(int index)操作符，获取观测序列中第index项索引，并作为唯一数据发射给观察者，index索引从0开始。12345678Observable.from(communities) .elementAt(1) .subscribe(new Action1&lt;Community&gt;() &#123; @Override public void call(Community community) &#123; Log.e("rx_test", "elementAt：第二个小区：" + community.getCommunityName()); &#125; &#125;); 输出结果：1elementAt：第二个小区：马德里春天 原理图： First 1.first() 只发射观测序列中的第一个数据项。12345678Observable.from(communities) .first() .subscribe(new Action1&lt;Community&gt;() &#123; @Override public void call(Community community) &#123; Log.e("rx_test", "first：" + community.getCommunityName()); &#125; &#125;); 输出结果：1first：东方花园 原理图： 2.first(Func1) 根据Func1中call方法的条件，发射符合条件的第一个数据项。1234567891011121314//过滤出第一个小区名为马德里春天的小区Observable.from(communities) .first(new Func1&lt;Community, Boolean&gt;() &#123; @Override public Boolean call(Community community) &#123; return "马德里春天".equals(community.getCommunityName()); &#125; &#125;) .subscribe(new Action1&lt;Community&gt;() &#123; @Override public void call(Community community) &#123; Log.e("rx_test", "first(Func1)：" + community.getCommunityName()); &#125; &#125;); 输出结果：1first(Func1)：马德里春天 Last 1.last() 只发射观测序列中的最后一个数据项。123456789//发送最后一个数据项Observable.from(communities) .last() .subscribe(new Action1&lt;Community&gt;() &#123; @Override public void call(Community community) &#123; Log.e("rx_test", "last：" + community.getCommunityName()); &#125; &#125;); 输出结果：1last：帝豪家园 原理图： 2.last(Func1) 根据Func1中call方法的条件，发射符合条件的最后一个数据项。1234567891011121314151617181920//发送符合条件的最后一个数据项：过滤最后一个小区名为马德里春天的房源Observable.from(communities) .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.getHouses()); &#125; &#125;) .last(new Func1&lt;House, Boolean&gt;() &#123; @Override public Boolean call(House house) &#123; return "马德里春天".equals(house.getCommunityName()); &#125; &#125;) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; Log.e("rx_test", "last：" + house.getCommunityName() + "小区，大小：" + house.getSize()); &#125; &#125;); 输出结果：1last：马德里春天小区，大小：88.6 总结 到此，本篇关于RxJava的常用过滤类操作符就讲解完毕了，下一篇我们将一起研究RxJava的四类操作符中的组合操作符都有哪些以及如何使用。 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。 附上RxJavaDemo的地址： RxJavaDemo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符之转换操作符(四)]]></title>
    <url>%2F2017%2F10%2F12%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[前言 上一篇文章我们学习了创建类操作符，本篇我们将一起来学习RxJava转换类操作符。所谓转换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。下面来看下转换类操作符都有哪些及其使用场景。 初始化数据 还是使用系列第一篇的小区与房源的例子。先初始化假数据以便实践操作符时使用。12345678910111213//小区实体public class Community &#123; private String communityName; //小区名称 private List&lt;House&gt; houses; //房源集合&#125;//房源实体public class House &#123; private float size; //大小 private int floor; //楼层 private int price; //总价 private String decoration; //装修程度 private String communityName; //小区名称&#125; 12345678910111213141516171819202122232425262728293031323334private List&lt;Community&gt; communities;private void initData() &#123; communities = new ArrayList&lt;&gt;(); List&lt;House&gt; houses1 = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; if (i % 2 == 0) &#123; houses1.add(new House(105.6f, i, 200, "简单装修", "东方花园")); &#125; else &#123; houses1.add(new House(144.8f, i, 520, "豪华装修", "东方花园")); &#125; &#125; communities.add(new Community("东方花园", houses1)); List&lt;House&gt; houses2 = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; if (i % 2 == 0) &#123; houses2.add(new House(88.6f, i, 166, "中等装修", "马德里春天")); &#125; else &#123; houses2.add(new House(123.4f, i, 321, "精致装修", "马德里春天")); &#125; &#125; communities.add(new Community("马德里春天", houses2)); List&lt;House&gt; houses3 = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; if (i % 2 == 0) &#123; houses3.add(new House(188.7f, i, 724, "豪华装修", "帝豪家园")); &#125; else &#123; houses3.add(new House(56.4f, i, 101, "普通装修", "帝豪家园")); &#125; &#125; communities.add(new Community("帝豪家园", houses3));&#125; 转换操作符Map map操作符，接收一个指定的Func1类型对象，然后将其应用到每一个由Observable发射的值上，进而将发射的值转换为我们期望的值。来看一下原理图与实例： 1234567891011121314151617181920212223242526272829//将一组Integer转换成StringObservable.just(1, 2, 3, 4, 5) .map(new Func1&lt;Integer, String&gt;() &#123; @Override public String call(Integer integer) &#123; return "This is " + integer; &#125; &#125;) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e("rx_test", s); &#125; &#125;); //将Community集合转换为每一个Community并获取其nameObservable.from(communities) .map(new Func1&lt;Community, String&gt;() &#123; @Override public String call(Community community) &#123; return community.getCommunityName(); &#125; &#125;) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String communityName) &#123; Log.e("rx_test", "小区名称为：" + communityName); &#125; &#125;); 输出结果：12345678This is 1This is 2This is 3This is 4This is 5小区名称为：东方花园小区名称为：马德里春天小区名称为：帝豪家园 由输出结果可看出，map操作符可用来进行数据的类型转换，拼接或者对集合进行遍历等1对1的转换。第一个例子中，Func1&lt;Integer, String&gt;()第一个参数是发射数据当前的类型，第二个参数是转换之后的数据类型。Action1&lt;String&gt;中参数也为发射数据转换之后的数据类型。 注意数据类型需对应准确，不要弄错了。 FlatMap flatMap操作符，也是用来转换的，但与map操作符不同之处是，flatMap()返回的是Observable对象，且这个Observable对象并不是被直接发送到了 Subscriber的回调方法中。 这么说可能不易理解，我们来看小区与房的例子，现在有3个小区，如果我们想打印出这3个小区中所有房源的信息，通过RxJava要如何做到？按照之前学习的我们或许会这么实现：12345678910Observable.from(communities) .subscribe(new Action1&lt;Community&gt;() &#123; @Override public void call(Community community) &#123; for (House house : community.getHouses()) &#123; Log.e("rx_test", "flatMap：小区名称：" + house.getCommunityName() + "，价格：" + house.getPrice() + "，楼层：" + house.getFloor()); &#125; &#125; &#125;); 按照这种实现方法我们只可获取到每个小区这一层，想要获取小区中的房源还需进行一层for循环遍历，这就违背了RxJava的原则了。那么来看下flatMap()如何实现：1234567891011121314Observable.from(communities) .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.getHouses()); &#125; &#125;) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; Log.e("rx_test", "flatMap：小区名称：" + house.getCommunityName() + "，价格：" + house.getPrice() + "，楼层：" + house.getFloor()); &#125; &#125;); 这样的代码是不是看起来舒心多了，再来看下flatMap()是如何实现的。 首先from()接收到小区集合communities后为其创建了一个Observable，依次将每个小区传递给flatMap()，flatMap()在每次接收到小区后会将其中包含的房源集合拿出来又创建了一个房源Observable，并激活这个房源Observable让其开始发射事件，之后返回给小区集合的Observable，最后小区集合的Observable再将这些事件统一交给Subscriber的回调方法去处理。 整个过程有两级Observable在运作，相当于将小区集合Observable这个初始对象铺平之后再通过统一路径分发下去，铺平这个工作就是flatMap所做的。 输出结果：123456789101112131415flatMap：小区名称：东方花园，价格：200，楼层：0flatMap：小区名称：东方花园，价格：520，楼层：1flatMap：小区名称：东方花园，价格：200，楼层：2flatMap：小区名称：东方花园，价格：520，楼层：3flatMap：小区名称：东方花园，价格：200，楼层：4flatMap：小区名称：马德里春天，价格：166，楼层：0flatMap：小区名称：马德里春天，价格：321，楼层：1flatMap：小区名称：马德里春天，价格：166，楼层：2flatMap：小区名称：马德里春天，价格：321，楼层：3flatMap：小区名称：马德里春天，价格：166，楼层：4flatMap：小区名称：帝豪家园，价格：724，楼层：0flatMap：小区名称：帝豪家园，价格：101，楼层：1flatMap：小区名称：帝豪家园，价格：724，楼层：2flatMap：小区名称：帝豪家园，价格：101，楼层：3flatMap：小区名称：帝豪家园，价格：724，楼层：4 由输出结果可看出这3个小区的所有房源信息都被依次打印了出来，但flatMap()有一个问题就是当数据量过大时可能会出现输出数据顺序交错的问题。 官方原理图： ConcatMap concatMap操作符，与flatMap()功能类似。不同之处是concatMap()采用连接方式而不是合并方式，所以其发射的数据是严格按照顺序的，这就解决了flatMap()有可能发生数据交错的问题。 原理图： FlatMapIterable flatMapIterable操作符，也与flatMap()相似，不同之处在于flatMapIterable转化多个Observable是使用Iterable作为源数据的。12345678910111213Observable.from(communities) .flatMapIterable(new Func1&lt;Community, Iterable&lt;House&gt;&gt;() &#123; @Override public Iterable&lt;House&gt; call(Community community) &#123; return community.getHouses(); &#125; &#125;).subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; Log.e("rx_test", "flatMap：小区名称：" + house.getCommunityName() + "，价格：" + house.getPrice() + "，楼层：" + house.getFloor()); &#125;&#125;); SwitchMap switchMap转换操作符，也与flatMap()相似，每当源Observable发射新数据项(Observable)时，它将取消订阅并停止监视之前那个数据项产生Observable，并开始监视当前发射的这一个。1234567891011121314Observable.from(communities) .switchMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.getHouses()); &#125; &#125;) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; Log.e("rx_test", "flatMap：小区名称：" + house.getCommunityName() + "，价格：" + house.getPrice() + "，楼层：" + house.getFloor()); &#125; &#125;); 如之前的例子，当数据量很大时，某一时刻，第一个小区所生成的小房源Observable正在发射数据，这时第二个小区所生成的小房源Observable被激活，则第一个小区的小Observable就会被取消订阅，其还未发射的数据也不在发射了。第二个小区小Observable开始发射数据，之后都同理。 原理图： Scan scan操作符，对一个序列的数据应用一个函数，并将这个函数的结果发射出去作为下个数据应用函数时的第一个参数使用。1234567891011121314//例如：先输出1，再将1+2=3作为下个数据发出，3+3=6再作为下个数据发出，以此类推。Observable.just(1, 2, 3, 4, 5) .scan(new Func2&lt;Integer, Integer, Integer&gt;() &#123; @Override public Integer call(Integer integer, Integer integer2) &#123; return integer + integer2; &#125; &#125;) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.e("rx_test", "scan：" + integer); &#125; &#125;); 输出结果：12345scan：1scan：3scan：6scan：10scan：15 原理图： GroupBy groupBy操作符，将原始Observable发射的数据按照key来拆分成一些小的Observable，然后这些小的Observable分别发射其所包含的的数据。通俗的说就是按照某个字段将数据进行分类再发射。 来看一个例子：有几个小区的多套房源数据，现在需要将其按照小区名称进行分类并输出。1234567891011121314151617181920212223242526List&lt;House&gt; houseList = new ArrayList&lt;&gt;();houseList.add(new House(105.6f, 1, 200, "简单装修", "东方花园"));houseList.add(new House(144.8f, 3, 300, "豪华装修", "马德里春天"));houseList.add(new House(88.6f, 2, 170, "简单装修", "东方花园"));houseList.add(new House(123.4f, 1, 250, "简单装修", "帝豪家园"));houseList.add(new House(144.8f, 6, 350, "豪华装修", "马德里春天"));houseList.add(new House(105.6f, 4, 210, "普通装修", "东方花园"));houseList.add(new House(188.7f, 3, 400, "精致装修", "帝豪家园"));houseList.add(new House(88.6f, 2, 180, "普通装修", "东方花园"));//根据小区名称进行分类Observable&lt;GroupedObservable&lt;String, House&gt;&gt; groupByCommunityNameObservable = Observable .from(houseList) .groupBy(new Func1&lt;House, String&gt;() &#123; @Override public String call(House house) &#123; //提供分类规则的key return house.getCommunityName(); &#125; &#125;);Observable.concat(groupByCommunityNameObservable) //concat组合操作符，将多个Observable有序组合并发送，后期会详细讲解 .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; Log.e("rx_test", "groupBy：" + "小区：" + house.getCommunityName() + "，价格：" + house.getPrice()); &#125; &#125;); 创建一个新的Observable：groupByCommunityNameObservable，它将会发送一个带有GroupedObservable的序列（也就是指发送的数据项的类型为GroupedObservable）。GroupedObservable是一个特殊的Observable，它基于一个分组的key，在这个例子中的key就是小区名。 输出结果：12345678groupBy：小区：东方花园，价格：200groupBy：小区：东方花园，价格：170groupBy：小区：东方花园，价格：210groupBy：小区：东方花园，价格：180groupBy：小区：马德里春天，价格：300groupBy：小区：马德里春天，价格：350groupBy：小区：帝豪家园，价格：250groupBy：小区：帝豪家园，价格：400 原理图： 总结 到此，本篇关于RxJava的常用转换类操作符就讲解完毕了，下一篇我们将一起研究RxJava的四类操作符中的过滤操作符都有哪些以及如何使用。 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。 附上RxJavaDemo的地址： RxJavaDemo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava操作符之创建操作符(三)]]></title>
    <url>%2F2017%2F10%2F11%2FRxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%AC%A6(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[前言 通过前两篇文章对于RxJava概念，原理及使用的学习，想必各位码友已经基本掌握RxJava的逻辑与功能了，那么从这篇文章开始我们来研究RxJava的各类操作符。 什么是操作符？通过之前的学习，我们发现Observable负责发送事件，Observer负责接收事件，而这个过程中想要对事件数据做出修改就需要交给操作符来负责啦。主流RxJava中操作符主要分为三类：转换操作符，过滤操作符，组合操作符。而我个人将用来创建Observable的操作符归为了一个新类型。本篇我们就来看看常用的创建操作符都有哪些以及如何使用。 创建操作符Create 上一篇文章的例子中我们已经实践了create操作符如何使用了，这里我们介绍一种便捷的创建Observer的方式。1234567891011121314Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; for (int i = 0; i &lt; 5; i++) &#123; subscriber.onNext("xulei" + i); &#125; subscriber.onCompleted(); &#125;&#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e("rx_test", "create:" + s); &#125;&#125;); subscribe()的入参使用Action1代替原来的Observer，只需重写一个call()方法，等同于原Observer中onNext()方法。如果需要onComplete与onError状态，还可以如下：12345678910111213141516.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e("rx_test", "create:" + s); &#125;&#125;, new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable throwable) &#123; Log.e("rx_test", "onError:" + throwable.getMessage()); &#125;&#125;, new Action0() &#123; @Override public void call() &#123; Log.e("rx_test", "onCompleted"); &#125;&#125;); 使用new ActionX代替new Observer，代码是不是看起来更加灵活与简洁呢。 Just just操作符可将某个或某些对象转化为Observable对象，并将其发射出去。参数可为一个或多个数字，字符串。也可为集合，数组，Iterate对象等。12345678910111213141516171819Observable.just(1, 2, 3, 4, 5, 6).subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.e("rx_test", "just:数字：" + integer); //数字或者字符串都是单个发射多次 &#125;&#125;);List&lt;String&gt; stringList = new ArrayList&lt;&gt;();stringList.add("Hello");stringList.add("Ha");stringList.add("RxJava");Observable.just(stringList).subscribe(new Action1&lt;List&lt;String&gt;&gt;() &#123; @Override public void call(List&lt;String&gt; strings) &#123; Log.e("rx_test", "just:集合：" + strings.toString()); //集合或数组是直接发射集合整体，不会拆分 &#125;&#125;); 输出结果：1234567just:数字：1just:数字：2just:数字：3just:数字：4just:数字：5just:数字：6just:集合：[Hello, Ha, RxJava] From from操作符可将某个对象转化为Observable对象，并且将其发射出去。不同于just，他接收集合或数组，并可将集合数组遍历之后拆分发送。12345678910List&lt;String&gt; stringList = new ArrayList&lt;&gt;();stringList.add("Hello");stringList.add("Ha");stringList.add("RxJava");Observable.from(stringList).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e("rx_test", "from：" + s); &#125;&#125;); 输出结果：123from：Hellofrom：Hafrom：RxJava Range range(int start, int count)操作符，根据初始值start，与数量count，发射count次以start为基数依次增加的值。123456Observable.range(4, 5).subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.e("rx_test", "range：" + integer); &#125;&#125;); 输出结果：12345range：4range：5range：6range：7range：8 Defer defer操作符功能类似于just操作符，不同之处在于defer只有在调用subscribe()方法进行订阅时才创建Observable，而just操作符在初始化Observable就已经创建了，且只创建一个Observable实例。这里我们通过与just对比进行实践。123456789101112131415161718192021222324Action1&lt;String&gt; action1 = new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e("rx_test", s); &#125;&#125;;//deferObservable&lt;String&gt; deferObservable = Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call() &#123; Object o = new Object(); return Observable.just("defer：hashCode：" + o.hashCode()); &#125;&#125;);deferObservable.subscribe(action1);deferObservable.subscribe(action1);deferObservable.subscribe(action1);//justObservable&lt;String&gt; justObservable = Observable.just("just：hashCode：" + new Object().hashCode());justObservable.subscribe(action1);justObservable.subscribe(action1);justObservable.subscribe(action1); 输出结果：123456defer：hashCode：112449879defer：hashCode：118897732defer：hashCode：191664429just：hashCode：121878114just：hashCode：121878114just：hashCode：121878114 由输出结果我们可以看出defer每次输出的Observable哈西值是不同的，说明其每subscribe订阅一次都会创建一个新的Observable，从而可保证Observable中的数据都是最新的。而just只有初始化的时候创建一次Observable。 Interval interval创建操作符，创建一个Observabel并每隔一段时间周期发射一个由0开始增加的数字。 注意：此Observabel是运行在新的线程，所以更新UI需要在主线程中订阅12345678910//每隔100ms发射一个数字,从0自增Observable.interval(100, TimeUnit.MILLISECONDS) //单位为毫秒 .observeOn(AndroidSchedulers.mainThread()) .take(5) //取前5次事件发射，take为过滤操作符，后期会详细讲 .subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; Log.e("rx_test", "interval：" + aLong); &#125; &#125;); 输出结果：12345678910100ms后...interval：0100ms后...interval：1100ms后...interval：2100ms后...interval：3100ms后...interval：4 Timer timer操作符，创建一个Observable并隔一段时间后发射一个特殊的值，仅发射一次。 注意：此Observabel是运行在新的线程，所以更新UI需要在主线程中订阅123456789//隔1s后发射一个数字Observable.timer(1, TimeUnit.SECONDS) //单位为秒 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; Log.e("rx_test", "timer：" + aLong); &#125; &#125;); 输出结果：121秒后...timer：0 Delay delay操作符，可用于延迟一定时长再发送事件。123456789//延迟2秒后发射事件Observable.just(1, 2, 3) .delay(2, TimeUnit.SECONDS) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.e("rx_test", "delay：" + integer); &#125; &#125;); 输出结果：12342秒后...delay：1delay：2delay：3 Repeat repeat(long count)操作符，将Observable重复发射count次。12345678//重复发射5次“Sherlock”Observable.just("Sherlock").repeat(5) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.e("rx_test", "repeat：" + s); &#125; &#125;); 输出结果：12345repeat：Sherlockrepeat：Sherlockrepeat：Sherlockrepeat：Sherlockrepeat：Sherlock 以上就是常用的一些创建操作符，类似但不常用的还有empty、never、error等等就不一一介绍了，有兴趣的码友可以自行百度。 线程调度Scheduler RxJava就是用来处理异步任务的，所以就牵扯到生产事件所在线程，处理事件所在线程的问题，下面来看一下RxJava提供的线程调度Scheduler都有哪些。 有了Scheduler，RxJava当然也提供了方法来使用它们。 .subscribeOn()指定被观察者Observable的执行线程。 .observeOn()指定观察者Observer的执行线程。 如第一篇文章中的例子：1234567891011121314151617181920212223//获取要查询的小区集合Observable.from(getCommunitiesFromServer()) .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.getHouses()); &#125; &#125;) .filter(new Func1&lt;House, Boolean&gt;() &#123; @Override public Boolean call(House house) &#123; return house.getPrice() &lt; 200; &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; //显示查询出来的房源信息 ShowSearchedHousesMessage(); &#125; &#125;); 其中.subscribeOn(Schedulers.io())指定了Observable在io线程运行，通常用来执行从服务器获取数据，数据库加载等耗时操作。.observeOn(AndroidSchedulers.mainThread())指定了Observer在Android环境下的UI线程运行，通常用来获取到数据后进行UI刷新的操作。可根据实际需求选择不同线程类型。 总结 到此，本篇关于RxJava的创建类操作符以及线程调度就讲解完毕了，下一篇我们将一起研究RxJava的四类操作符中的转换操作符都有哪些以及如何使用。 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。 附上RxJavaDemo的地址： RxJavaDemo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava基本原理与使用(二)]]></title>
    <url>%2F2017%2F09%2F28%2FRxJava%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[前言 上一篇我们了解了RxJava的介绍以及通过一个例子学习了RxJava的展现形式，相信大家现在已经对RxJava有一个初步的印象与概念了。本篇我们将更深入的学习RxJava的基本原理以及如何使用RxJava。 观察者模式 上一篇有提到RxJava的核心便是扩展的观察者模式，我们先来学习一下观察者模式。 事件：小明按下遥控器开关，空调启动并开始吹风了。按下制冷按键，空调吹出的风变为凉风。再按下3档风速按键，空调吹的风变大了。 在这个事件中，空调作为观察者，遥控器作为被观察者，空调通过红外线检测遥控器传来的信号并作出响应。 通过上图我们可以很清晰的看出遥控器作为事件的生产方主动发起事件，是事件的起点，而空调作为事件的处理方被动接收事件做出响应，是事件的终点。而在事件传递的过程中可对事件进行过滤，转换，合并等操作，就像例子中制冷与加大风速的效果。 这个概念是RxJava中的核心，它是基于观察者模式来组建自己的程序逻辑，遥控器就相当于RxJava的被观察者Observable，空调相当于观察者Observer，而对事件处理的一些操作相当于各类操作符。不同的是RxJava中观察者需要对被观察者进行订阅，这样当被观察者发出事件时，观察者才会接收到事件进行处理。若未进行订阅，被观察者是不会发出任何事件的。 使用 了解了观察者模式，接下来动起指尖尝试下怎么使用RxJava。 创建被观察者Observable 第一步：创建被观察者Observable：12345678910Observable&lt;Object&gt; observable = Observable.create(new Observable.OnSubscribe&lt;Object&gt;() &#123; @Override public void call(Subscriber&lt;? super Object&gt; subscriber) &#123; //被观察者的数据操作更新 for (int i = 0; i &lt; 5; i++) subscriber.onNext("xulei" + i); &#125; subscriber.onCompleted(); &#125;&#125;); 通过Observable.create()方法创建并返回一个Observable对象，create()方法需要一个OnSubsribe对象作为参数传入并执行call()方法。此OnSubsribe对象继承自Action1。 而在call()方法中可通过subscriber.onNext()进行事件的发送，subscriber.onCompleted()标记为事件发送完毕。subscriber.onError()标记为事件发送过程出现异常。 除create()方法创建Observable方式外，还可以使用just()与from()等方式，这个在之后的创建操作符文章中会有讲解。 创建观察者Observer 第二步：创建观察者Observer：1234567891011121314Observer observer = new Observer() &#123; @Override public void onCompleted() &#123; //标记事件发送完毕的回调 Log.e("rx_test", "onCompleted"); &#125; @Override public void onError(Throwable e) &#123; //事件发送过程出现异常的回调 Log.e("rx_test", "onError"); &#125; @Override public void onNext(Object o) &#123; //接收到发送事件的回调 Log.e("rx_test", "onNext:" + o.toString()); &#125;&#125;; 在以往普通的观察者模式中，观察者通常只提供一个update()的方法，而RxJava扩展的观察者模式中的观察者提供onNext(Object o)，onCompleted()，onError(Throwable e)三个方法，分别对应被观察者call()方法中重写的subscriber.onNext()，subscriber.onCompleted()，subscriber.onError()方法。而onNext()方法就对应普通观察者模式中的update()方法。 RxJava扩展的观察模式弥补了普通观察者模式的不足： 1. 当事件发送完毕可以调用onCompleted()方法进行标示。 2. 当事件发送过程中出现异常会自动触发onError()方法，也可进行手动调用。 3. Observable支持链式编程，从而避免了回调嵌套的问题，也简化了代码。 订阅 最后一步：被观察者Observable订阅观察者Observer。 这里不同于普通观察者模式，上一篇我们讲了在RxJava扩展观察者模式中，如果没有观察者，被观察者是不会发出任何事件的。所以这里是被观察者订阅观察者。1observable.subscribe(observer); 订阅很简单，一行代码搞定。调用Observable的subscribe()方法，传入观察者对象作为参数，这样被观察者与观察者就进行了绑定。 简写 RxJava可以使用链式编程：1234567891011121314151617181920212223Observable.create(new Observable.OnSubscribe&lt;Object&gt;() &#123; @Override public void call(Subscriber&lt;? super Object&gt; subscriber) &#123; //被观察者的数据操作更新 for (int i = 0; i &lt; 5; i++) &#123; subscriber.onNext("xulei" + i); &#125; subscriber.onCompleted(); &#125;&#125;).subscribe(new Observer&lt;Object&gt;() &#123; @Override public void onCompleted() &#123; Log.e("rx_test", "onCompleted"); &#125; @Override public void onError(Throwable e) &#123; Log.e("rx_test", "onError"); &#125; @Override public void onNext(Object o) &#123; Log.e("rx_test", "onNext:" + o.toString()); &#125;&#125;); 逻辑梳理 到此一个RxJava的简单调用就实现了，相信不少码友看完之后还是很懵13，那我们再来梳理一下整个流程。首先使用Observable.create()创建了一个Observable，并在create()方法中传入了一个OnSubscribe对象作为参数，重写OnSubscribe中的call()方法，当Observable进行订阅后就会自动触发call()方法发送事件。 注意：call()方法中的subscriber参数其实就是我们在调用subscribe()进行订阅时时传入的观察者Observer。所以当在call()方法中调用的5次onNext()方法与1次onCompleted()方法后，观察者Observer中输出的日志为：123456onNext:xulei0onNext:xulei1onNext:xulei2onNext:xulei3onNext:xulei4onCompleted 有的码友看到这里会对call()方法中的subscriber参数就是订阅时传入的Observer有些不解，那么我们一起来看源码。 先看下call()方法中的参数Subscriber：123public abstract class Subscriber&lt;T&gt; implements Observer&lt;T&gt;, Subscription &#123; ......&#125; 可以看出Subscriber是Observer的抽象实现类，与Observer一个类型。再来看订阅时调用的subscribe(observer)方法：1234567891011121314151617181920212223public final Subscription subscribe(final Observer&lt;? super T&gt; observer) &#123; //无视 if (observer instanceof Subscriber) &#123; return subscribe((Subscriber&lt;? super T&gt;)observer); &#125; return subscribe(new Subscriber&lt;T&gt;() &#123; @Override public void onCompleted() &#123; observer.onCompleted(); &#125; @Override public void onError(Throwable e) &#123; observer.onError(e); &#125; @Override public void onNext(T t) &#123; observer.onNext(t); &#125; &#125;);&#125; 这里将传入的Observer对象通过代理转换为Subscriber对象作为参数传入并调用重载方法subscribe()，我们再来看这个subscribe()方法的代码：123public final Subscription subscribe(Subscriber&lt;? super T&gt; subscriber) &#123; return Observable.subscribe(subscriber, this);&#125; 这里继续调用重载方法subscribe()，将由Observer转换为的subscriber对象与当前Observable对象作为参数传入，继续往下追踪源码：123456789101112private static &lt;T&gt; Subscription subscribe(Subscriber&lt;? super T&gt; subscriber, Observable&lt;T&gt; observable) &#123; ...... subscriber.onStart(); ...... try &#123; hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber); return hook.onSubscribeReturn(subscriber); &#125; catch (Throwable e) &#123; ...... return Subscriptions.unsubscribed(); &#125;&#125; 精简一下代码发现，subscriber.onStart()用来通知被观察者准备开始发送事件了。重点看hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);我们发现hook.onSubscribeStart(observable, observable.onSubscribe)方法返回的是其第二个参数observable.onSubscribe，这个参数正是新建Observable时create()方法中传入的OnSubscribe对象。接着又通过这个onSubscribe调用call(subscriber)方法，将subscriber作为参数传入，码友们有没有发现，这个subscriber传来传去究其根源，正是一开始由订阅方法subscribe(observer)传入的observer通过代理转换为的那个subscriber。 这样前后逻辑就连接上了，通过阅读源码我们才能发现为何创建Observable时call()方法中的subscriber参数其实就是订阅时传入的Observer。 总结 到此，本篇关于RxJava的基本原理与使用就讲解完毕了，下一篇我们将一起研究RxJava的四类操作符中的创建操作符都有哪些以及如何使用。 这里感谢下张磊大神撰写的RxJava系列的帮助： RxJava系列2(基本概念及使用介绍) 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。 附上RxJavaDemo的地址： RxJavaDemo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava简介与入门(一)]]></title>
    <url>%2F2017%2F09%2F21%2FRxJava%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%85%A5%E9%97%A8(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[前言 最近在学习RxJava的过程中,越发感受到这个框架的强大，对于提升开发效率，降低维护成本有很大的作用。有必要强行安利一波，一起来看看RxJava简介，基本概念，原理与使用，本篇主要介绍RxJava的简介。 响应式编程ReactiveX RxJava是ReactiveX中使用Java语言实现的版本，那什么是ReactiveX呢？ReactiveX就是一种新兴的编程模式–响应式编程，定义为一种基于异步数据流概念的编程模式，可分解为”观察者模式+迭代器模式+函数式编程”。 扩展的观察者模式 有关观察者模式的概念不懂得童鞋可自行google，这里就不再赘述。RxJava扩展了观察者模式，通过使用可观察的对象序列流来表述一系列事件，订阅者进行占点观察并对序列流做出反应（或持久化或输出显示等等）；借鉴迭代器模式，对多个对象序列进行迭代输出，订阅者可以依次处理不同的对象序列；使用函数式编程思想，简化繁琐的逻辑代码。 而RxJava的核心便是被观察者Observables与观察者Observer，由Observables发出一系列的事件，Observer通过subscribe()方法进行订阅接收事件并进行处理，类似观察者模式，不同之处在于，若没有观察者，被观察者是不会发出任何事件的。 所以说，RxJava本质上是一个异步操作库，是一个能让你用极其简洁的逻辑去处理繁琐复杂任务的异步事件库。 例子 概念理解起来未免晦涩难懂，我们来看一个例子： 有这样一个需求：开发一个类似房天下的App，某功能需要检索出某一片区所有住宅小区中购房总价&lt;200W的房源并展示出来。先看原始实现方式： 12345678910111213141516171819202122 new Thread(new Runnable() &#123; @Override public void run() &#123; //获取要查询的小区集合 List&lt;Community&gt; communities = getCommunities(); for (Community community : communities) &#123; //获取小区中的房源集合 List&lt;House&gt; houses = community.getHouses(); for (House house : houses) &#123; if (house.getPrice() &lt; 200) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; //显示查询出来的房源信息 ShowSearchedHousesMessage(); &#125; &#125;); &#125; &#125; &#125; &#125;&#125;).start(); RxJava实现方式：123456789101112131415161718192021222324//获取要查询的小区集合List&lt;Community&gt; communities = getCommunities();Observable.from(communities) .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123; @Override public Observable&lt;House&gt; call(Community community) &#123; return Observable.from(community.getHouses()); &#125; &#125;) .filter(new Func1&lt;House, Boolean&gt;() &#123; @Override public Boolean call(House house) &#123; return house.getPrice() &lt; 200; &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;House&gt;() &#123; @Override public void call(House house) &#123; //显示查询出来的房源信息 ShowSearchedHousesMessage(); &#125; &#125;); RxJava的实现方式看上去更复杂了，但是它的逻辑很清晰简洁，修改起来很方便，后期维护起来也能提高工作效率。再来看下配合Lambda表达式：12345678//获取要查询的小区集合List&lt;Community&gt; communities = getCommunities();Observable.from(communities) .flatMap(community -&gt; Observable.from(community.getHouses()) .filter(house -&gt; house.getPrice() &lt; 200) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(house -&gt; ShowSearchedHousesMessage()); 搭配上Lambda表达式，代码的简洁度是不是更上一层楼呢？不懂Lambda表达式的童鞋可以跳转到我写的另一篇讲解Lambda表达式的文章： Android开发之Lambda表达式基本语法与应用 总结 到此，本篇关于RxJava的简介就介绍完毕了，本篇的目的主要是给大家引入一个RxJava的概念，以便后期更轻松的理解RxJava的原理与运作。下一篇我们再来一起详细研究RxJava的原理及如何使用。 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者建议也可以在我Github上RxJavaDemo项目Issues中提出，我会及时回复。附上RxJavaDemo的地址： RxJavaDemo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lambda表达式基本语法与应用]]></title>
    <url>%2F2017%2F07%2F24%2FLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Lambda简介 Lambda表达式是Java8中提供的一种新的特性，它支持Java也能进行简单的“函数式编程”，即Lambda允许你通过表达式来代替功能接口，即可使用更少的代码来实现同样的功能。 用官方的解释就是： A lambda expression is a block of code with parameters.(Lambda表达式是一个带有参数的表达式) 添加支持 首先Java版本需要为1.8，然后在build.gradle中添加：1234567891011121314android &#123; …… defaultConfig &#123; …… jackOptions&#123; enabled true &#125; &#125; compileOptions &#123; //升级Android Studio的Language level为1.8 sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125; 语法完整示例1234(int x, int y) -&gt; &#123; Log.i("TAG", "x:" + x + " y:" + y); return x + y;&#125; 这是一个完整的Lambda表达式的写法，通常由三部分组成： 1. (int x, int y)：Lambda表达式的参数部分，包括参数类型与参数名 2. “-&gt;”：箭头goes to，指向代码块 3. 代码块：用”{}”包裹的代码 忽略参数类型 在大多数情况下，参数的类型系统可根据上下文推断出来。这种情况参数类型就可以忽略不写。1234(x, y) -&gt; &#123; Log.i("TAG", "x:" + x + " y:" + y); return x + y;&#125; 忽略：”()” 当只有一个参数时，”()”可以忽略不写。1234x -&gt; &#123; Log.i("TAG", "x:" + x); return x;&#125; 当没有参数时，”()”不可忽略。1234() -&gt; &#123; Log.i("TAG", "无参数"); return 0;&#125; 忽略：”{}” 当代码块只包含一条语句时可忽略”{}”不写。1(x, y) -&gt; return x + y; 忽略return 而return关键字也是可以忽略不写的。1(x, y) -&gt; x + y; 精简到最后只需要一行代码就可以搞定，是不是很方便。 应用无参数+语句/代码块 常规写法：123456new Thread(new Runnable() &#123; @Override public void run() &#123; Log.i("TAG", "测试无参数+语句/代码块"); &#125;&#125;).start(); Lambda写法：1new Thread(() -&gt; Log.i("TAG", "测试无参数+语句/代码块")).start(); 适用于匿名内部类中方法无参数的情况 有参数+语句 常规写法：123456findViewById(R.id.button).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.i("TAG", "测试有参数+语句"); &#125;&#125;); Lambda写法：1findViewById(R.id.button).setOnClickListener(v -&gt; Log.i("TAG", "测试有参数+语句")); 适用于匿名内部类中方法只有一个参数的情况 有参数+代码块 常规写法：12345678CheckBox checkBox = (CheckBox) findViewById(R.id.checkBox);checkBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; Log.i("TAG", "测试有参数+代码块1"); Log.i("TAG", "测试有参数+代码块2"); &#125;&#125;); Lambda写法：1234checkBox.setOnCheckedChangeListener((buttonView, isChecked) -&gt; &#123; Log.i("TAG", "测试有参数+代码块1"); Log.i("TAG", "测试有参数+代码块2");&#125;); 适用于匿名内部类中方法不止一个参数且执行语句不止一行的情况 总结 Lambda表达式的应用场景很多，例如可与RxJava，Retrofit等进行完美配合，更多的就等待各位码友去实践发掘了。而到此，本篇关于Lambda表达式的详解与应用就讲解完毕了。技术渣一枚，有写的不对的地方欢迎大神们留言指正。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORM框架之GreenDao3.0使用详解(二)]]></title>
    <url>%2F2017%2F07%2F13%2FORM%E6%A1%86%E6%9E%B6%E4%B9%8BGreenDao3.0%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[本文介绍 上一篇讲解了GreenDao3.0如何集成环境与添加各类注解，这一篇我们来看看如何使用GreenDao实现数据库增删改查的功能，还是上一篇公司Company与雇员Employee的例子。 数据库初始化 首先初始化数据库与表，可封装一个工具类，这里献上我的：123456789101112131415161718192021222324public class GreenDaoUtil &#123; private static DaoSession daoSession; private static SQLiteDatabase database; /** * 初始化数据库 * 建议放在Application中执行 */ public static void initDataBase(Context context) &#123; //通过DaoMaster的内部类DevOpenHelper，可得到一个SQLiteOpenHelper对象。 DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper (context, "greendaoutil.db", null); //数据库名称 database = devOpenHelper.getWritableDatabase(); DaoMaster daoMaster = new DaoMaster(database); daoSession = daoMaster.newSession(); &#125; public static DaoSession getDaoSession() &#123; return daoSession; &#125; public static SQLiteDatabase getDatabase() &#123; return database; &#125;&#125; 然后在Application中调用。1234567public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); GreenDaoUtil.initDataBase(getApplicationContext()); &#125;&#125; 插入 插入公司与雇员的假数据：123456789101112131415161718192021222324//获取实体DaoCompanyDao companyDao = GreenDaoUtil.getDaoSession().getCompanyDao();EmployeeDao employeeDao = GreenDaoUtil.getDaoSession().getEmployeeDao();//插入公司Company company1 = new Company();company1.setId(null);company1.setCompanyName("Netease");company1.setIndustry("news");Company company2 = new Company();company2.setId(null);company2.setCompanyName("Tencent");company2.setIndustry("chat");companyDao.insert(company1);companyDao.insert(company2);//插入不同公司的雇员for (int i = 0; i &lt; 5; i++) &#123; Employee employee = new Employee(null, company1.getId(), "Sherlock" + i, 11000 + i * 1000); employeeDao.insert(employee);&#125;for (int i = 0; i &lt; 5; i++) &#123; Employee employee = new Employee(null, company2.getId(), "Richard" + i, 8000 + i * 1000); employeeDao.insert(employee);&#125; 注意：设置setId(null)，GreenDao会自动分配自增Id。 查询 由于删除与更新基本都需要先进行查询，所以咱们来看看如何进行查询： QueryBuilder 举例：查询Tencent公司中薪水大于等于10000的职员。123456789//查询Company表中名为Tencent的公司Company company = companyDao.queryBuilder().where(CompanyDao.Properties.CompanyName.eq("Tencent")).unique();//查询Employee表中属于Tencent公司且薪水水大于等于10000的EmployeeList&lt;Employee&gt; employeeList = employeeDao.queryBuilder().where(EmployeeDao.Properties.CompanyId.eq(company.getId()), EmployeeDao.Properties.Salary.ge(10000)).list(); 注意：如果查询调用.unique()的话，需注意本次查询的结果必须唯一，否则会报错。where中为查询条件，支持多条件查询以” , “隔开。 Query 使用Query可进行重复查询，更改查询条件参数即可，还是上面的例子。12345678910111213//查询Company表中名为Tencent的公司Company company = companyDao.queryBuilder().where(CompanyDao.Properties.CompanyName.eq("Tencent")).unique();//查询Employee表中属于Tencent公司且薪水水大于等于10000的EmployeeQuery query = employeeDao.queryBuilder().where(EmployeeDao.Properties.CompanyId.eq(company.getId()), EmployeeDao.Properties.Salary.ge(10000)).build();//修改查询条件参数query.setParameter(0, company.getId());query.setParameter(1, 11000);List&lt;Employee&gt; employeeList = query.list(); load(Long key) 根据主键查询一条记录1Company company = companyDao.load(1l); loadAll() 查询表中所有记录12List&lt;Company&gt; companyList = companyDao.loadAll();List&lt;Employee&gt; employeeList = employeeDao.loadAll(); 原声sql查询 推荐通过QueryBuilder和WhereCondition.StringCondition来实现原声sql查询。123Query query = companyDao.queryBuilder().where( new StringCondition("_ID IN " + "(SELECT USER_ID FROM USER_MESSAGE WHERE READ_FLAG = 0)")).build(); 也可使用queryRaw()或queryRawCreate()方法来实现。 多线程查询 如果数据量过大，对于数据库查询的操作是很耗时的，所以需要开启新的线程进行查询。123456789private void queryThread() &#123; final Query query = employeeDao.queryBuilder().build(); new Thread()&#123; @Override public void run() &#123; List list = query.forCurrentThread().list(); &#125; &#125;.start();&#125; 查询条件判断eq,noteq与like查询 eq判断值是否相等，通常用来具体查找，返回一条指定类型数据。 noteq与eq相反，判断值是否不等，通常用来模糊查找，返回指定类型的集合。 like相当于通配符查询，包含查询值的实体都会返回，同样模糊查找，返回指定类型的集合。 &gt;、&lt;、&gt;=、&lt;=查询 分别对应方法： &gt;: gt() &lt;: lt() &gt;=: ge() &lt;=: le() isNull与isNotNull 为空与不为空，判断数据库中有无数据。 排序 对查询结果进行排序，有升序与降序。1234List&lt;Employee&gt; employeeList = employeeDao.queryBuilder().where(EmployeeDao.Properties.CompanyId.eq(company.getId())).orderAsc(EmployeeDao.Properties.Salary).list(); 上例中的.orderAsc(EmployeeDao.Properties.Salary)就是对查询出来的Employee按工资进行升序排序。同理降序为.orderDesc(EmployeeDao.Properties.Salary)。 删除 删除主要有三种方式： deleteBykey(Long key) 根据key进行删除。举例：删除Tencent公司中薪水小于10000的人，需先查询出Employee表中属于Tencent公司且薪水小于10000的Employee实体，再进行删除。123456789101112131415161718192021//查询Company表中名为Tencent的公司Company companyTencent = companyDao.queryBuilder().where(CompanyDao.Properties.CompanyName.eq("Tencent")).unique();if (companyTencent != null) &#123; //查询Employee表中属于Tencent公司且薪水小于10000的Employee List&lt;Employee&gt; employeeList = employeeDao.queryBuilder() .where(EmployeeDao.Properties.CompanyId.eq(companyTencent.getId()), EmployeeDao.Properties.Salary.lt(10000)) .list(); if (employeeList != null) &#123; for (Employee employee : employeeList) &#123; //进行删除 employeeDao.deleteByKey(employee.getId()); &#125; &#125; else &#123; Log.e("greendao_test", "delete:deleteList为空"); &#125;&#125; else &#123; Log.e("greendao_test", "delete:company为空");&#125; delete(Employee entity) 根据实体进行删除。举例：删除名为Tencent的公司。12345//查询Company表中名为Tencent的公司Company companyTencent = companyDao.queryBuilder().where(CompanyDao.Properties.CompanyName.eq("Tencent")).unique();companyDao.delete(companyTencent); deleteAll() 若需删除表中所有实体，则调用此方法。举例：删除所有雇员。1employeeDao.deleteAll(); 更新 若需对某个已存入数据库实体的属性进行修改，则需进行update操作。举例：修改Netease公司中薪水小于等于13000人的名字1234567891011121314151617181920212223//查询Company表中名为Netease的公司Company companyNetease = companyDao.queryBuilder().where(CompanyDao.Properties.CompanyName.eq("Netease")).unique();if (companyNetease != null) &#123; //查询Employee表中查询Employee表中属于Netease公司且薪水小于等于13000人的Employee List&lt;Employee&gt; employeeList = employeeDao.queryBuilder() .where(EmployeeDao.Properties.CompanyId.eq(companyNetease.getId()), EmployeeDao.Properties.Salary.le(13000)) .list(); if (employeeList != null) &#123; for (Employee employee : employeeList) &#123; //修改属性 employee.setEmployeeName("baozi"); //进行更新 employeeDao.update(employee); &#125; &#125; else &#123; Log.e("greendao_test", "update:updateList为空"); &#125;&#125; else &#123; Log.e("greendao_test", "update:company为空");&#125; 总结 到此，这一篇关于GreenDao3.0的使用就讲解完毕了，可结合上一篇集成与注解详解一起看。 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者不懂的地方也可以在我Github上GreenDaoDemo项目的Issues中提出，我会及时解答。附上GreenDaoDemo的地址： GreenDaoDemo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GreenDao</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORM框架之GreenDao3.0集成与注解(一)]]></title>
    <url>%2F2017%2F07%2F10%2FORM%E6%A1%86%E6%9E%B6%E4%B9%8BGreenDao3.0%E9%9B%86%E6%88%90%E4%B8%8E%E6%B3%A8%E8%A7%A3(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[GreenDao简介 GreenDao是一个将对象映射到SQLite数据库中的轻量且快速的ORM数据库框架，本文将讲解如何集成GreenDao3.0环境，如何使用GreenDao自动生成代码及注解的使用。 GreenDao官网 GreenDao GitHub GreenDao3.0优势 GreenDao相较于ORMLite等其他数据库框架有以下优势： 1. 一个精简的库 2. 性能最大化 3. 内存开销最小化 4. 易于使用的 APIs 5. 对 Android 进行高度优化 而GreenDao3.0的版本主要使用注解方式定义实体类，通过gradle插件生成相应的代码。相较于3.0之前的版本集成步骤更为便捷，使用起来也更为简单。本文使用的版本为3.2.0。 集成项目下build.gradle GitHub中提示添加maven仓库，但是AndroidStudio项目已经默认包含了jcenter仓库，而jcenter仓库就是maven仓库的一个分支，因此不需要再添加仓库，直接添加classPath即可。123456789buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.2' classpath 'org.greenrobot:greendao-gradle-plugin:3.2.1' &#125;&#125; app下build.gradle 在app下build.gradle文件中我们需要声明GreenDao插件，及配置GreenDao生成dao路径等信息，声明GreenDao依赖。12345678910111213141516apply plugin: 'org.greenrobot.greendao'......greendao &#123; schemaVersion 1 //数据库版本号 daoPackage 'com.holmeslei.greendaodemo.database' //设置时生成代码的目录 targetGenDir 'src/main/java' //设置DaoMaster、DaoSession、Dao目录 //targetGenDirTest：设置生成单元测试目录 //generateTests：设置自动生成单元测试用例&#125;dependencies &#123; ...... compile 'org.greenrobot:greendao:3.2.0'&#125; 初始化实体编写实体类 集成好使用环境后需要初始化实体，首先编写实体类。这里演示使用公司Company与雇员Employer实体例子。使用@Entity注解。莫急，注解机制在之后小节有详细讲解。123456789@Entitypublic class Company &#123; @Id(autoincrement = true) //自增 private Long id; //主键 private String companyName; //公司名称 private String industry; //行业 @ToMany(referencedJoinProperty = "companyId") //设置外键companyId private List&lt;Employee&gt; employeeList; //公司与雇员建立一对多关系&#125; 12345678@Entitypublic class Employee &#123; @Id(autoincrement = true) private Long id; //主键 private long companyId; //指向Company主键 private String employeeName; //雇员姓名 private int salary; //薪水&#125; 生成代码 实体类与注解添加完毕后编译项目，就会为所有带注解的实体生成Dao文件，及DaoMaster与DaoSession。若未在build.gradle中配置过则默认生成目录为build/generated/source。若配置过则生成在配置的目录下。 注解 3.0之后最大的不同就是使用的注解来配置实体类属性，便捷且灵活。下面来看一下各类注解： 实体类注解123456789101112@Entity( schema = "myschema", active = true, nameInDb = "AWESOME_USERS", indexes = &#123; @Index(value = "name DESC", unique = true) &#125;, createInDb = false)public class Company &#123; ......&#125; @Entity：用于标识当前实体需要GreenDao生成代码。 schema：项目中存在多个Schema时，表明当前实体属于哪个Schema。 active：标记实体是否处于活动状态，活动状态才支持更新删除刷新等操作。 nameInDb：存储在数据库中的表名，不写默认与类名一致。 indexes：定义索引，可跨越多个列。 createInDb：标记创建数据库表，若有多个实体关联此表可设为false避免重复创建，默认为true。 属性注解 @Id :主键Long型，可以通过@Id(autoincrement = true)设置自增长。 @Property：设置一个非默认关系映射所对应的列名，默认是的使用字段名例如@Property (nameInDb=&quot;name&quot;)。 @NotNul：设置数据库表当前列不能为空。 @OrderBy：指定排序。 @Transient：添加此标记之后不会生成数据库表的列。 @Generated：为build之后GreenDao自动生成的注解，为防止重复，每一块代码生成后会加个hash作为标记。 索引注解123456789101112131415@Entitypublic class Company &#123; @Id(autoincrement = true) private Long id; @Index(unique = true) private String industry;&#125; @Entitypublic class Employee &#123; @Id(autoincrement = true) private Long id; @Unique private String employeeName;&#125; @Index：创建索引，通过设置name设置别名，设置unique添加约束。 @Unique：添加唯一约束与(unique = true)作用相同。 关系注解 @ToOne：定义与另一实体一对一的关联。 123456789101112131415@Entitypublic class Company &#123; @Id (autoincrement = true) private Long id; private long customerId; @ToOne(joinProperty = "employeeId") private Employee employee;&#125; @Entitypublic class Employee &#123; @Id(autoincrement = true) private Long id; private String employeeName;&#125; @ToMany：定义与多个实体对象一对多的关联，referencedJoinProperty为外键约束。 @JoinProperty：标明目标属性的源属性。 @JoinEntity：建立表连接关系。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//第一种：Employee实体通过外键companyId指向Company实体的主键Id建立一对多关联@Entitypublic class Company &#123; @Id(autoincrement = true) private Long id; private String companyName; private String industry; @ToMany(referencedJoinProperty = "companyId") private List&lt;Employee&gt; employeeList;&#125; @Entitypublic class Employee &#123; @Id(autoincrement = true) private Long id; private long companyId; private String employeeName; private int salary;&#125;//第二种：Employee以companyId为外键，与Company非主键不为空的键employeeTag建立一对多关联。@Entitypublic class Company &#123; @Id(autoincrement = true) private Long id; private String companyName; private String industry; @ToMany(joinProperties = &#123; @JoinProperty(name = "employeeTag", referencedName = "companyId") &#125;) private List&lt;Employee&gt; employeeList;&#125; @Entitypublic class Employee &#123; @Id(autoincrement = true) private Long id; private String employeeName; private int salary; @NotNull private String companyId;&#125; //第三种：通过第三者实体类建立关联，用的较少@Entitypublic class Employee &#123; @Id(autoincrement = true) private Long id; private String employeeName; private int salary; @ToMany @JoinEntity( entity = JoinEmployeeToCompany.class, sourceProperty = "employeeId", targetProperty = "companyId" ) private List&lt;Company&gt; companyList;&#125; @Entitypublic class JoinEmployeeToCompany &#123; @Id(autoincrement = true) private Long id; private Long employeeId; private Long companyId;&#125; @Entitypublic class Company &#123; @Id(autoincrement = true) private Long id; private String companyName; private String industry; &#125; 总结 到此，这一篇关于GreenDao3.0的集成与注解就讲解完毕了，欢迎参看下一篇关于如何使用GreenDao3.0对数据库进行增删改查。 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者不懂的地方也可以在我Github上GreenDaoDemo项目的Issues中提出，我会及时解答。附上GreenDaoDemo的地址： GreenDaoDemo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GreenDao</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DataBinding数据绑定基本讲解]]></title>
    <url>%2F2017%2F05%2F15%2FDataBinding%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%9F%BA%E6%9C%AC%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[DataBinding简介 DataBinding是基于MVVM思想实现数据与UI绑定的框架，有了Data Binding，在Android中也可以很方便的实现MVVM。它于2015年7月由Google在Studio1.3上引入，2016年4月在Studio2.0上得到正式支持。DataBinding是一个support库，最低支持到Android2.1（API Level 7+）。 在引入DataBinding之前，我们需要敲很多很鸡肋的代码，如 findViewById()、setText()，setVisibility()，setEnabled() 或 setOnClickListener() 等，通过 DataBinding , 我们可以通过声明式布局以精简的代码来绑定应用程序逻辑和布局，这样就不用编写大量的冗余的代码了。这一节我们来讲一讲DataBinding的基本实现之常量绑定、变量绑定与事件绑定。 初始化在build.gradle中添加123456android &#123; dataBinding &#123; enabled = true; &#125; ......&#125; 在xml文件最外层结构添加1234&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools"&gt; ......&lt;/layout&gt; 即是将最外层标签改为&lt;layout&gt;&lt;/layout&gt; 替换原setContentView方法1ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main); 命名规则：这里的ActivityMainBinding命名由来是其layout名称转换为驼峰形式再加上”Binding得到”。例如activity_main-&gt;ActivityMainBinding。 开始绑定常量绑定 在xml中：1234&lt;TextView android:id="@+id/text_view1" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; 在Activity中：1binding.textView1.setText("Helloworld"); 命名规则：控件id带下划线时，调用时使用其id的驼峰命名形式 。不带下划线时，调用时与id一致。例如id为text_view1，调用时使用binding.textView1。 变量绑定 首先创建一个简单的数据来源类MyBean：123456789101112131415161718192021222324252627package com.sherlock.databindingdemo;public class MyBean &#123; private String name; private int age; public MyBean(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 然后在xml文件layout标签下添加：123456&lt;data&gt; &lt;variable name="mybean" type="com.sherlock.databindingdemo.MyBean" /&gt; &lt;/data&gt;&lt;!--name：提供数据的bean的别名；type：bean的类名--&gt; 在控件中设置变量绑定：123456&lt;TextView android:id="@+id/text_view1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginRight="10dp" android:text="@&#123;mybean.name&#125;"/&gt; 在Activity中设置数据：12binding.setMybean(myBean);//binding.setVariable(BR.mybean,myBean); //另一种方法 注意：@{mybean.name}中的name必须为String类型，若要绑定别的类型，比如int类型，可以这样@{String.valueOf(mybean.age)}。 事件绑定 当然我们也可以用DataBinding实现事件绑定，它有两种实现方式。 第一种：首先添加一个事件回调类Presenter，这里演示Click与TextChange事件:123456789public class Presenter &#123; public void onTextChanged(CharSequence s, int start, int before, int count) &#123; myBean.setName(s.toString()); binding.setMybean(myBean); &#125; public void onClick(View view)&#123; Toast.makeText(MainActivity.this, "点击成功", Toast.LENGTH_SHORT).show(); &#125;&#125; 注意：使用这种事件绑定方式，Presenter中的方法需和控件监听方法完全一致。 在xml中：1234567891011121314151617&lt;data&gt; &lt;variable name="presenter" type="com.sherlock.databindingdemo.MainActivity.Presenter" /&gt;&lt;/data&gt;&lt;EditText android:layout_width="match_parent" android:layout_height="wrap_content" android:onTextChanged="@&#123;presenter.onTextChanged&#125;" /&gt; &lt;!--或者@&#123;presenter::onTextChanged&#125;--&gt;&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:onClick="@&#123;presenter.onClick&#125;" /&gt; &lt;!--或者@&#123;presenter::onClick&#125;--&gt; 在Activity中：1binding.setPresenter(new Presenter()); 第二种：也可以设置自定义的监听器Binding，可回传参数，需要使用Lambda表达式： 在xml中：12345&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:onClick="@&#123;() -&gt; presenter.onButtonClick(mybean)&#125;" /&gt; &lt;!--或者@&#123;(view) -&gt; presenter.onButtonClick(mybean)&#125;--&gt; 在Presenter中：123public void onButtonClick(MyBean myBean)&#123; Toast.makeText(MainActivity.this, myBean.getName(), Toast.LENGTH_SHORT).show();&#125; 注意：使用这种事件绑定，Presenter中的监听方法就不需要与View的监听方法完全一致了，而且可以获取View在事件中回传的数据。 总结 这一节到此DataBinding的常量，变量，事件绑定的用法就讲解完毕了，实际操作起来感觉目前AndroidStudio对DataBinding的支持还不够，排错有点费劲，有时会出现找不到DataBinding的错误，这时应先查看下是否由于自己修改了某个类名，而xml调用时没有修改导致。若没有问题则删除app下的build文件夹重新Rebuild下项目试试。 首次接触DataBinding，可能有写的不对的地方欢迎大神们留言指正，有什么疑惑或者不懂的地方也可以在我Github上DataBindingDemo项目的Issues中提出，我会及时解答。附上DataBindingDemo地址： DataBindingDemo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>DataBinding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Material Design之RecyclerView基本讲解与瀑布流的实现]]></title>
    <url>%2F2017%2F03%2F28%2FMaterial%20Design%E4%B9%8BRecyclerView%E5%9F%BA%E6%9C%AC%E8%AE%B2%E8%A7%A3%E4%B8%8E%E7%80%91%E5%B8%83%E6%B5%81%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[RecyclerView简介 RecyclerView是一种新的视图组，目标是为任何基于适配器的视图提供相似的渲染方式。它被作为ListView和GridView控件的继承者，具有更优的灵活性与可替代性。在最新的support-v7版本中提供支持。本文将讲解RecyclerView的简单实现，添加删除条目，点击事件添加与瀑布流的实现。 相关原理与简单实现添加依赖 在AndroidStudio的build.gradle中添加依赖： dependencies { ... compile &#39;com.android.support:recyclerview-v7:25.3.0&#39; } 在布局中使用 添加完依赖后就可以在布局中使用RecyclerView了： &lt;android.support.v7.widget.RecyclerView android:id="@+id/main_recyclerview" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; RecyclerView.Adapter RecyclerView封装了一种新型的适配器，与现在使用的适配器大同小异。它强制用户使用RecyclerView提供的ViewHolder，使用时主要需要重写onCreateViewHolder与onBindViewHolder方法。前者用来展现视图及其持有者，且只有真正需要一个新view时才会被回调，不需要检查是否已经被回收。后者用来绑定数据到View上。 import android.content.Context; import android.support.v7.widget.RecyclerView; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; import java.util.List; public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; { private Context context; private List&lt;String&gt; list; private LayoutInflater inflater; public MyAdapter(Context context, List&lt;String&gt; list) { this.context = context; this.list = list; inflater = LayoutInflater.from(context); } @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = inflater.inflate(R.layout.item_recyclerview, parent, false); MyViewHolder holder = new MyViewHolder(view); return holder; } @Override public void onBindViewHolder(MyViewHolder holder, int position) { holder.textView.setText(list.get(position)); } @Override public int getItemCount() { return list.size(); } class MyViewHolder extends RecyclerView.ViewHolder { TextView textView; public MyViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.item_textview); } } } LayoutManager RecyclerView通过布局管理器LayoutManager控制每一个item如何进行排列摆放，何时展示和隐藏。回收或重用一个View时LayoutManager会向适配器请求新的数据来替换旧的数据，这种机制避免了创建过多的View和频繁的调用findViewById方法，目前其自带的主要有以下三种： - LinearLayoutManager：ListView样式 - GridLayoutManager：GridView样式 - StaggeredGridLayoutManager：瀑布流样式 ItemDecoration RecyclerView并不能像ListView一样直接在xml布局中修改item分割线样式。需要在Activity动态设置，当然更推荐在单个条目布局中设置margin或者padding来实现分割线效果，这里提供一个分割线。 import android.content.Context; import android.content.res.TypedArray; import android.graphics.Canvas; import android.graphics.Rect; import android.graphics.drawable.Drawable; import android.support.v7.widget.LinearLayoutManager; import android.support.v7.widget.RecyclerView; import android.view.View; public class DividerItemDecoration extends RecyclerView.ItemDecoration { private static final int[] ATTRS = new int[]{ android.R.attr.listDivider }; public static final int HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL; public static final int VERTICAL_LIST = LinearLayoutManager.VERTICAL; private Drawable mDivider; private int mOrientation; public DividerItemDecoration(Context context, int orientation) { final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); a.recycle(); setOrientation(orientation); } public void setOrientation(int orientation) { if (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) { throw new IllegalArgumentException("invalid orientation"); } mOrientation = orientation; } @Override public void onDraw(Canvas c, RecyclerView parent) { if (mOrientation == VERTICAL_LIST) { drawVertical(c, parent); } else { drawHorizontal(c, parent); } } public void drawVertical(Canvas c, RecyclerView parent) { final int left = parent.getPaddingLeft(); final int right = parent.getWidth() - parent.getPaddingRight(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int top = child.getBottom() + params.bottomMargin; final int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); } } public void drawHorizontal(Canvas c, RecyclerView parent) { final int top = parent.getPaddingTop(); final int bottom = parent.getHeight() - parent.getPaddingBottom(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int left = child.getRight() + params.rightMargin; final int right = left + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); } } @Override public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) { if (mOrientation == VERTICAL_LIST) { outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); } else { outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); } } } ItemAnimator ItemAnimator会根据适配器上收到的通知来动画显示视图组的修改，比如item的添加与删除。DefaultItemAnimator已经能很好的展现动画效果了。 RecyclerView初始化 若想初始化一个RecyclerView使其进入工作状态，你需要在Activity中做以下的操作： RecyclerView recyclerView = (RecyclerView)findViewById(R.id.recycler_view_main); MyAdapter adapter = new MyAdapter(this, list); //设置RecyclerView保持固定的大小 recyclerView.setHasFixedSize(true); //设置适配器 recyclerView.setAdapter(adapter); //设置RecyclerView ListView样式布局管理 recyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)); //设置RecyclerView的Item分割线 recyclerView.addItemDecoration(new DividerItemDecoration(this, DividerItemDecoration.VERTICAL_LIST)); //设置RecyclerView的动画 recyclerView.setItemAnimator(new DefaultItemAnimator()); //设置RecyclerView GridView样式 //recyclerView.setLayoutManager(new GridLayoutManager(MainActivity.this, 3)); //设置RecyclerView 水平GridView样式 //recyclerView.setLayoutManager(new StaggeredGridLayoutManager(5, StaggeredGridLayoutManager.HORIZONTAL)); //设置RecyclerView 瀑布流样式 //recyclerView.setLayoutManager(new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL)); 点击事件与添加删除Item 美中不足的是RecyclerView并没有提供像ListView一样的Item点击与Item长点击事件，不提供咱们就自己造，通过接口回调来实现。 Adapter中import android.content.Context; import android.support.v7.widget.RecyclerView; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; import java.util.ArrayList; public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; { private Context context; private LayoutInflater inflater; protected ArrayList&lt;String&gt; datas; private onItemClickedListener onItemClickedListener; public MyAdapter(Context context, ArrayList&lt;String&gt; datas) { this.context = context; this.datas = datas; inflater = LayoutInflater.from(context); } public void setOnItemClickedListener(MyAdapter.onItemClickedListener onItemClickedListener) { this.onItemClickedListener = onItemClickedListener; } @Override public void onBindViewHolder(MyViewHolder holder, int position) { holder.textView.setText(datas.get(position)); } @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = inflater.inflate(R.layout.item_recycler_view, parent, false); MyViewHolder myViewHolder = new MyViewHolder(view); return myViewHolder; } @Override public int getItemCount() { return datas.size(); } /** * 添加条目 */ public void addItem(int position) { datas.add(position, "xulei"); // notifyDataSetChanged(); notifyItemInserted(position);//调用这个才有动画效果 } /** * 移除条目 */ public void removeItem(int position) { datas.remove(position); notifyItemRemoved(position); } class MyViewHolder extends RecyclerView.ViewHolder { TextView textView; public MyViewHolder(View itemView) { super(itemView); //初始化控件 textView = (TextView) itemView.findViewById(R.id.item_textview); //设置当前条目单击监听 itemView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { if (onItemClickedListener != null) onItemClickedListener.onClick(view, getAdapterPosition());//可立刻获取到当前position // onItemClickedListener.onClick(view, getLayoutPosition());//需等当前视图更新完才能获取到当前position，&lt;16ms。 } }); //设置当前条目长按监听 itemView.setOnLongClickListener(new View.OnLongClickListener() { @Override public boolean onLongClick(View view) { if (onItemClickedListener != null) onItemClickedListener.onLongClick(view, getAdapterPosition()); return false; } }); } } /** * 点击回调的接口 */ interface onItemClickedListener { void onClick(View view, int position); void onLongClick(View view, int position); } } Activity中 在Activity中实例化Adapter之后添加如下代码： adapter.setOnItemClickedListener(new MyAdapter.onItemClickedListener() { @Override public void onClick(View view, int position) { adapter.addItem(position); Toast.makeText(MainActivity.this, "点击click:" + position, Toast.LENGTH_SHORT).show(); } @Override public void onLongClick(View view, int position) { adapter.removeItem(position); Toast.makeText(MainActivity.this, "长按click:" + position, Toast.LENGTH_SHORT).show(); } }); 瀑布流的实现 想实现瀑布流的样式通过使用RecyclerView也很容易就能实现。 首先在Activity中设置LayoutManager时选择：recyclerView.setLayoutManager(new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL)); 修改Adapter 瀑布流自然是每个条目的高度不同才能出现瀑布的效果（水平布局则是宽度不同），那么只需在每个条目绑定数据时动态改变下其高度即可，贴出瀑布流Adapter代码： import android.content.Context; import android.view.ViewGroup; import java.util.ArrayList; import java.util.List; public class StaggerAdapter extends MyAdapter { private List&lt;Integer&gt; heights; public StaggerAdapter(Context context, ArrayList&lt;String&gt; datas) { super(context, datas); heights = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; datas.size(); i++) { heights.add((int) (100 + Math.random() * 300)); } } @Override public void onBindViewHolder(MyViewHolder holder, int position) { ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams(); layoutParams.height = heights.get(position); // layoutParams.width = heights.get(position); holder.itemView.setLayoutParams(layoutParams); holder.textView.setText(datas.get(position)); } } 总结 通过实践发现RecyclerView相较于ListView与GridView确实强大很多，更加的灵活与方便，提高了开发效率。但也有不足之处，如并未封装点击事件的回调，确实是比较头疼。期待Google的完善。附上GitHub源码：RecyclerViewDemoRecyclerViewDevelop]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AlarmManager+Notification实现定时通知提醒功能]]></title>
    <url>%2F2016%2F12%2F13%2FAlarmManager%2BNotification%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E9%80%9A%E7%9F%A5%E6%8F%90%E9%86%92%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[AlarmManager简介 AlarmManager实质是一个全局的定时器，是Android中常用的一种系统级别的提示服务，在指定时间或周期性启动其它组件（包括Activity,Service,BroadcastReceiver）。本文将讲解一下如何使用AlarmManager实现定时提醒功能。 闹钟配置周期闹钟12345Intent intent = new Intent();intent.setAction(GlobalValues.TIMER_ACTION_REPEATING);PendingIntent sender = PendingIntent.getBroadcast(context, 0, intent, 0);AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);alarm.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + 5 * 1000, 3 * 1000, sender); 1setRepeating(int type,long startTime,long intervalTime,PendingIntent pi) 该方法用于设置周期性执行的定时服务。type：闹钟类型，startTime：闹钟首次执行时间，intervalTime：闹钟两次执行的间隔时间，pi：闹钟响应动作。1setInexactRepeating(int type,long startTime,long intervalTime,PendingIntent pi) 该方法也用于设置周期定式服务，与上一种类似。不过其两个闹钟执行的间隔时间不是固定的。它相对而言更省电一些，因为系统可能会将几个差不多的闹钟合并为一个来执行，减少设备的唤醒次数。 intervalTime内置变量间隔一天： INTERVAL_DAY间隔半天： INTERVAL_HALF_DAY间隔15分钟： INTERVAL_FIFTEEN_MINUTES间隔半个小时： INTERVAL_HALF_HOUR间隔一个小时： INTERVAL_HOUR 定时闹钟123456789//获得系统提供的AlarmManager服务的对象AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);//Intent设置要启动的组件，这里启动广播Intent myIntent = new Intent();myIntent.setAction(GlobalValues.TIMER_ACTION);//PendingIntent对象设置动作,启动的是Activity还是Service,或广播!PendingIntent sender = PendingIntent.getBroadcast(context, 0, myIntent,0);//注册闹钟alarm.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + 5 * 1000, sender); 1set(int type,long startTime,PendingIntent pi) 该方法用于设置一次性定时服务。type：闹钟类型，startTime：闹钟执行时间，pi：闹钟响应动作。 取消闹钟123456Intent myIntent = new Intent();myIntent.setAction(GlobalValues.TIMER_ACTION);//myIntent.setAction(GlobalValues.TIMER_ACTION_REPEATING);PendingIntent sender = PendingIntent.getBroadcast(context, 0, myIntent,0);AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);alarm.cancel(sender); 设置多个闹钟： 若连续设置多个闹钟，则只有最后一个闹钟会生效，那么这种情况我们怎么处理呢？其实很简单。我们可以给每个闹钟设置唯一的id，传入getBroadcast()第二个参数。在这里我是每设置一个id则自增1存入Shareprefrence里，保证id唯一性。1234 //给每个闹钟设置不同ID防止覆盖int alarmId = SharedPreUtils.getInteger(context, "alarm_id", 0);SharedPreUtils.setInteger(context, "alarm_id", ++alarmId);PendingIntent sender = PendingIntent.getBroadcast(context, alarmId, myIntent, 0); 在取消闹钟时我们也可以根据这个id关闭不同的闹钟。 参数详解type：闹钟类型ELAPSED_REALTIME： 在指定的延时过后，发送广播，但不唤醒设备（闹钟在睡眠状态下不可用）。如果在系统休眠时闹钟触发，它将不会被传递，直到下一次设备唤醒。ELAPSED_REALTIME_WAKEUP： 在指定的延时过后，发送广播，并唤醒设备（即使关机也会执行operation所对应的组件） 。延时是要把系统启动的时间SystemClock.elapsedRealtime()算进去的。RTC： 指定当系统调用System.currentTimeMillis()方法返回的值与triggerAtTime相等时启动operation所对应的设备（在指定的时刻，发送广播，但不唤醒设备）。如果在系统休眠时闹钟触发，它将不会被传递，直到下一次设备唤醒（闹钟在睡眠状态下不可用）。RTC_WAKEUP： 指定当系统调用System.currentTimeMillis()方法返回的值与triggerAtTime相等时启动operation所对应的设备（在指定的时刻，发送广播，并唤醒设备）。即使系统关机也会执行operation所对应的组件。POWER_OFF_WAKEUP： 表示闹钟在手机关机状态下也能正常进行提示功能，所以是5个状态中用的最多的状态之一，该状态下闹钟也是用绝对时间，状态值为4；不过本状态好像受SDK版本影响，某些版本并不支持。 long intervalTime：执行时间 闹钟的第一次执行时间，以毫秒为单位，可以自定义时间，不过一般使用当前时间。需要注意的是，本属性与第一个属性（type）密切相关，如果第一个参数对应的闹钟使用的是相对时间（ELAPSED_REALTIME和ELAPSED_REALTIME_WAKEUP），那么本属性就得使用相对时间（相对于系统启动时间来说），比如当前时间就表示为：SystemClock.elapsedRealtime();如果第一个参数对应的闹钟使用的是绝对时间（RTC、RTC_WAKEUP、POWER_OFF_WAKEUP），那么本属性就得使用绝对时间，比如当前时间就表示为：System.currentTimeMillis() long startTime：间隔时间 对于周期定时方式来说，存在本属性，表示两次闹钟执行的间隔时间，也是以毫秒为单位。 PendingIntent pi：执行动作 是闹钟的执行动作，比如发送一个广播、给出提示等等。PendingIntent是Intent的封装类。需要注意的是，如果是通过启动服务来实现闹钟提示的话，PendingIntent对象的获取就应该采用Pending.getService(Context c,int i,Intent intent,int j)方法；如果是通过广播来实现闹钟提示的话，PendingIntent对象的获取就应该采用PendingIntent.getBroadcast(Context c,int i,Intent intent,int j)方法；如果是采用Activity的方式来实现闹钟提示的话，PendingIntent对象的获取就应该采用PendingIntent.getActivity(Context c,int i,Intent intent,int j)方法。如果这三种方法错用了的话，虽然不会报错，但是看不到闹钟提示效果。。 广播配置新建闹钟BroadCastReceiver：1234567891011121314151617181920212223242526272829public class AlarmReceiver extends BroadcastReceiver &#123; private NotificationManager m_notificationMgr = null; private static final int NOTIFICATION_FLAG = 3; @Override public void onReceive(Context context, Intent intent) &#123; m_notificationMgr = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVIC if (intent.getAction().equals(GlobalValues.TIMER_ACTION_REPEATING)) &#123; Log.e("alarm_receiver", "周期闹钟"); &#125; else if (intent.getAction().equals(GlobalValues.TIMER_ACTION)) &#123; Log.e("alarm_receiver", "定时闹钟"); Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.logo); Intent intent1 = new Intent(context, WriteDiaryActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent1, 0); Notification notify = new Notification.Builder(context) .setSmallIcon(R.drawable.logo) // 设置状态栏中的小图片，尺寸一般建议在24×24 .setLargeIcon(bitmap) // 这里也可以设置大图标 .setTicker("亲情日历") // 设置显示的提示文字 .setContentTitle("亲情日历") // 设置显示的标题 .setContentText("您有日记提醒哦") // 消息的详细内容 .setContentIntent(pendingIntent) // 关联PendingIntent .setNumber(1) // 在TextView的右方显示的数字，可以在外部定义一个变量，点击累加setNumber(count),这时显示的和 .getNotification(); // 需要注意build()是在API level16及之后增加的，在API11中可以使用getNotificatin()来 notify.flags |= Notification.FLAG_AUTO_CANCEL; NotificationManager manager = (NotificationManager) context.getSystemService(Context.NOTIF manager.notify(NOTIFICATION_FLAG, notify); bitmap.recycle(); //回收bitmap &#125; &#125;&#125; 注册BroadCastReceiver： 最后别忘了在清单里注册广播。1234567&lt;!--闹钟接收广播--&gt;&lt;receiver android:name=".util.service.AlarmReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="com.e_eduspace.TIMER_ACTION_REPEATING" /&gt; &lt;action android:name="com.e_eduspace.TIMER_ACTION" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 附件常量：123456public class GlobalValues &#123; // 周期性的闹钟 public final static String TIMER_ACTION_REPEATING = "com.e_eduspace.TIMER_ACTION_REPEATING"; // 定时闹钟 public final static String TIMER_ACTION = "com.e_eduspace.TIMER_ACTION";&#125; 工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.e_eduspace.familycalendar.util;import android.app.AlarmManager;import android.app.PendingIntent;import android.content.Context;import android.content.Intent;import com.prolificinteractive.materialcalendarview.CalendarDay;/** * 闹钟定时工具类 * * @author xulei * @time 2016/12/13 10:03 */public class AlarmTimer &#123; /** * 设置周期性闹钟 * * @param context * @param firstTime * @param cycTime * @param action * @param AlarmManagerType 闹钟的类型，常用的有5个值：AlarmManager.ELAPSED_REALTIME、 * AlarmManager.ELAPSED_REALTIME_WAKEUP、AlarmManager.RTC、 * AlarmManager.RTC_WAKEUP、AlarmManager.POWER_OFF_WAKEUP */ public static void setRepeatingAlarmTimer(Context context, long firstTime, long cycTime, String action, int AlarmManagerType) &#123; Intent myIntent = new Intent(); myIntent.setAction(action); PendingIntent sender = PendingIntent.getBroadcast(context, 0, myIntent, 0); AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE); alarm.setRepeating(AlarmManagerType, firstTime, cycTime, sender); //param1：闹钟类型，param1：闹钟首次执行时间，param1：闹钟两次执行的间隔时间，param1：闹钟响应动作。 &#125; /** * 设置定时闹钟 * * @param context * @param cycTime * @param action * @param AlarmManagerType 闹钟的类型，常用的有5个值：AlarmManager.ELAPSED_REALTIME、 * AlarmManager.ELAPSED_REALTIME_WAKEUP、AlarmManager.RTC、 * AlarmManager.RTC_WAKEUP、AlarmManager.POWER_OFF_WAKEUP */ public static void setAlarmTimer(Context context, long cycTime, String action, int AlarmManagerType, CalendarDay date) &#123; Intent myIntent = new Intent(); //传递定时日期 myIntent.putExtra("date", date); myIntent.setAction(action); //给每个闹钟设置不同ID防止覆盖 int alarmId = SharedPreUtils.getInteger(context, "alarm_id", 0); SharedPreUtils.setInteger(context, "alarm_id", ++alarmId); PendingIntent sender = PendingIntent.getBroadcast(context, alarmId, myIntent, 0); AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE); alarm.set(AlarmManagerType, cycTime, sender); &#125; /** * 取消闹钟 * * @param context * @param action */ public static void cancelAlarmTimer(Context context, String action) &#123; Intent myIntent = new Intent(); myIntent.setAction(action); PendingIntent sender = PendingIntent.getBroadcast(context, 0, myIntent,0); AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE); alarm.cancel(sender); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AlarmManager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络请求框架之Retrofit2.0基本讲解]]></title>
    <url>%2F2016%2F04%2F29%2F%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A1%86%E6%9E%B6%E4%B9%8BRetrofit2.0%E5%9F%BA%E6%9C%AC%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Retrofit2.0简介 Retrofit是一套RESTful架构的Android(Java)客户端实现，基于注解，提供JSON to POJO(Plain Ordinary Java Object,简单Java对象)，POJO to JSON，网络请求(POST，GET,PUT，DELETE等)封装。用官方自己的介绍就是: A type-safe REST client for Android and Java 现已更新到2.0的版本，与1.0版本的使用上还是不小的差别，我也是第一次用，这里主要和大家研究研究2.0版本简单使用。也可参详官方示例。 准备工作添加权限 首先添加网络请求权限1&lt;uses-permission android:name="android.permission.INTERNET"/&gt; 添加依赖 Retrofit2.0版本后只支持okhttp请求，也已经封装好了，就不需要添加okhttp的依赖了。1234dependencies &#123; compile 'com.squareup.retrofit2:retrofit:2.0.2' compile 'com.squareup.retrofit2:converter-gson:2.0.0-beta3'&#125; 简单使用 接下来瞧一瞧Retrofit初始化以及如何请求数据。 初始化Retrofit对象12345public static final String BASE_URL = "https://api.github.com/";Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .build(); BASE_URL就是你请求的Server地址。1.addConverterFactory(GsonConverterFactory.create()) Retrofit2.0不提供返回JSON数据的默认解析方式，需要手动指定，支持Jackson等多种解析方式。需要哪种就添加相应的依赖，这里添加的是Retrofit提供的converter-gson依赖。有点不爽的就是不支持FastJson解析，有需要的话可以自己写一个FastjsonConverterFactory继承Converter.Factory实现。 虽然Retrofit2.0后只支持okhttp请求，但你也可以自定义一个okhttp再配置进Retrofit。1234567891011121314OkHttpClient client = new OkHttpClient();client.interceptors().add(new Interceptor() &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Response response = chain.proceed(chain.request()); // Do anything with response here return response; &#125;Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .client(client) .addConverterFactory(GsonConverterFactory.create()) .build();&#125;); 定义请求接口 实现转换HTTP API为Java接口，Retrofit提供了5种内置的注解：GET、POST、PUT、DELETE和HEAD，在注解中指定的资源的相对URL。1234public interface NetWorkService &#123; @GET("users/basil2style") Call&lt;DataBean&gt; getData();&#125; 使用替换块和参数进行动态更新,替换块是{ and }包围的字母数字组成的字符串，相应的参数必须使用相同的字符串被@Path进行注释。12345@GET("repos/&#123;params1&#125;/&#123;params2&#125;/contributors")Call&lt;List&lt;DataBean2&gt;&gt; getData( @Path("params1") String params1, @Path("params2") String params2,); 当我们调用getData()这个方法的时候，Retrofit会创建这个URL。如果我们传入Square和Retrofit字符串，分别作为owner和repo参数。我们就会得到这个URL：https://api.github.com/repos/square/retrofit/contributors 添加查询参数12@GET("repos/square/&#123;retrofit&#125;/contributors")Call&lt;List&lt;DataBean2&gt;&gt; groupData(@Path("retrofit") String retrofit, @Query("sort") String sort); 当我们调用getData()方法时，传入一个查询参数字符串”ok”,这样我们就能得到URL：https://api.github.com/repos/square/retrofit/contributors?sort=ok 当然如果查询参数过多，我们也可以使用Map进行组合再传进来。12@GET("repos/square/&#123;retrofit&#125;/contributors")Call&lt;List&lt;DataBean2&gt;&gt; getData(@Path("repos") String repos, @QueryMap Map&lt;String, String&gt; parameters); 请求数据 Retrifot支持同步和异步的请求方式，先使用Retrofit类生成接口NetWorkService的实现。1NetWorkService service = retrofit.create(NetWorkService.class); 同步请求12Call&lt;DataBean&gt; call = service.getData(Square,Retrofit);DataBean bean = call.execute().body(); 注意同步请求不可在主线程执行，你懂得。且call只能执行execute()方法一次，若要再次请求可通过Call&lt;DataBean&gt; call = call.clone()来再复制一个Call对象。 异步请求1234567891011call.enqueue(new Callback&lt;DataBean&gt;() &#123; @Override public void onResponse(Call&lt;DataBean&gt; call, Response&lt;DataBean&gt; response) &#123; Toast.makeText(MainActivity.this, "请求成功", Toast.LENGTH_SHORT).show(); DataBean bean = response.body(); tvMain.setText(bean.toString()); &#125; @Override public void onFailure(Call&lt;DataBean&gt; call, Throwable t) &#123; &#125;&#125;); 当我们执行的同步或异步加入队列后，可以随时使用call.cancel()方法取消请求。 注意 注解中参数的写法与BASE_URL的拼接一定要注意，请看以下写法。 错误示例1 BASE_URL：https://api.github.com/repos/square Get注解： @GET(“/basil2style”) 结果URL： https://api.github.com/basil2style 错误示例2 BASE_URL：https://api.github.com/repos/square Get注解： @GET(“basil2style”) 结果URL： https://api.github.com/repos/basil2style 推荐写法 BASE_URL：https://api.github.com/repos/square/ Get注解： @GET(“basil2style”) 结果URL： https://api.github.com/repos/square/basil2style 总结 Retrofit2.0的基本实现讲解完毕，Retrofit+Okhttp+Gson可以算是目前来说相当快的超级网络请求框架了。相比较于Volley都快不少，亲测结果很爽。小伙伴们赶紧整起来吧！ 技术渣一枚，有写的不对的地方欢迎大神们留言指正，有什么疑惑或者不懂的地方也可以在我Github上Retrofit2Demo项目的Issues中提出，我会及时解答。附上Retrofit2Demo的地址： Retrofit2Demo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用神器Stetho调试Volley]]></title>
    <url>%2F2016%2F04%2F19%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%A5%9E%E5%99%A8Stetho%E8%B0%83%E8%AF%95Volley%2F</url>
    <content type="text"><![CDATA[Stetho简介 Stetho 是 Facebook 开源的一个 Android 调试工具。是一个 Chrome Developer Tools 的扩展，可用来检测应用的网络、数据库、WebKit 等方面的功能。开发者也可通过它的 dumpapp 工具提供强大的命令行接口来访问应用内部。无需root查看sqlite文件、sharedpreference文件等等。更多详细介绍可以进入Stetho官网。 Stetho结合OkHttp使用添加依赖1234// Gradle dependency on Stetho dependencies &#123; compile 'com.facebook.stetho:stetho:1.1.1' &#125; Stetho初始化配置在App的Application中完成初始化。123456789101112public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); Stetho.initialize( Stetho.newInitializerBuilder(this) .enableDumpapp( Stetho.defaultDumperPluginsProvider(this)) .enableWebKitInspector( Stetho.defaultInspectorModulesProvider(this)) .build()); &#125;&#125; 官网中使用OkHttp为实例，使用如下12OkHttpClient client = new OkHttpClient();client.networkInterceptors().add(new StethoInterceptor()); 然后就可以运行App进行调试，基本上可以满足调试需求了。 Stetho结合Volley使用官网中Stetho是结合OkHttp的使用，如果项目中使用Volley做为网络请求框架，可以做如下修改。还是使用OkHttp做为Volley中HttpStack的实现，我们知道，Volley中网络请求在Android2.3及以上基于HttpURLConnection，2.3以下基于HttpClient实现，通过增加HttpStack的具体实现即可。这里使用Bryan Stern分享的代码。（网页可能被墙，可以通过VPN访问。需要VPN的可以点击这里） 添加依赖123compile 'com.facebook.stetho:stetho:1.1.1'compile 'com.facebook.stetho:stetho-okhttp:1.1.1'compile 'com.squareup.okhttp:okhttp:2.3.0' Stetho初始化配置123OkHttpClient client = new OkHttpClient();client.networkInterceptors().add(new StethoInterceptor());mRequestQueue = Volley.newRequestQueue(getApplicationContext(), new OkHttpStack(client)); 好了，基本上这样就能使用Stetho神器调试你的App了，感觉到强大了么~。 补充：使用中遇到的坑 Stetho inspect窗口空白 如果出现调试窗口空白，先升级下Chrome吧。升级最新版后再试一下（我被这个坑了）。 Stetho inspect窗口还是空白 如果Chrome是最新版，无论如何刷新都是空白，那么恭喜你你可能被墙了~用VPN试试吧 可以戳这里哦 我的测试代码和效果图如下：自定义Application类：12345678910111213141516171819202122232425262728293031public class MyAppliation extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); context = getApplicationContext(); instance = this; Stetho.initialize( Stetho.newInitializerBuilder(this) .enableDumpapp(Stetho.defaultDumperPluginsProvider(this)) .enableWebKitInspector(Stetho.defaultInspectorModulesProvider(this)) .build()); &#125; /** * @return The Volley Request queue */ public RequestQueue getRequestQueue() &#123; // lazy initialize the request queue, the queue instance will be // created when it is accessed for the first time synchronized (App.class) &#123; if (mRequestQueue == null) &#123; OkHttpClient client = new OkHttpClient(); client.networkInterceptors().add(new StethoInterceptor()); mRequestQueue = Volley.newRequestQueue(getApplicationContext(), new OkHttpStack(client)); &#125; &#125; return mRequestQueue; &#125;&#125; Activity类代码： 123456789101112131415161718192021222324252627282930public class MainActivity extends Activity &#123; private TextView tv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout_main); tv = (TextView)findViewById(R.id.tv); RequestQueue queue = App.getInstance().getRequestQueue(); String url = "https://publicobject.com/helloworld.txt"; StringRequest request = new StringRequest(Request.Method.GET, url, new Response.Listener&lt;String&gt;() &#123; @Override public void onResponse(String s) &#123; LogUtil.d(s); tv.setText(s); &#125; &#125;, new com.android.volley.Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError volleyError) &#123; LogUtil.e(volleyError.toString()); &#125; &#125;); queue.add(request); SharedPrfUtil.setInt("uid",669); SharedPrfUtil.setString("username","dongye"); &#125;&#125; 实现效果如下图：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Stetho</tag>
      </tags>
  </entry>
</search>
